{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Pact Developer Tutorials What is Pact? Pact is a human-readable smart contract language. It allows anyone to write clearly, directly and safely onto a blockchain \u2014 a true innovation for secure and simple smart contract development. Pact will enable you to create entirely new business models and on-chain services. How to use the Pact Developer Tutorials Pact Developer Tutorials offer the training needed to learn the Pact programming language. They teach skills from beginner to advanced that are designed to help you develop blockchain applications with Pact. Prerequisites These free tutorials have no prerequisites. Learn whenever and however you want using the documentation and complimentary videos for each lesson. Get Started Start with our Beginner Tutorial Series which covers Pact\u2019s fundamental concepts, followed by real smart contract projects you can deploy to our Testnet. Connect with our community Join the Discord Channel for community discussion Follow the Pact GitHub page for the latest updates on Pact development Ask questions about Pact on Stack Overflow using #pact-lang Get the latest Kadena updates from our Newsletter or Twitter","title":"Welcome to the Pact Developer Tutorials"},{"location":"#welcome-to-the-pact-developer-tutorials","text":"","title":"Welcome to the Pact Developer Tutorials"},{"location":"#what-is-pact","text":"Pact is a human-readable smart contract language. It allows anyone to write clearly, directly and safely onto a blockchain \u2014 a true innovation for secure and simple smart contract development. Pact will enable you to create entirely new business models and on-chain services.","title":"What is Pact?"},{"location":"#how-to-use-the-pact-developer-tutorials","text":"Pact Developer Tutorials offer the training needed to learn the Pact programming language. They teach skills from beginner to advanced that are designed to help you develop blockchain applications with Pact.","title":"How to use the Pact Developer Tutorials"},{"location":"#prerequisites","text":"These free tutorials have no prerequisites. Learn whenever and however you want using the documentation and complimentary videos for each lesson.","title":"Prerequisites"},{"location":"#get-started","text":"Start with our Beginner Tutorial Series which covers Pact\u2019s fundamental concepts, followed by real smart contract projects you can deploy to our Testnet.","title":"Get Started"},{"location":"#connect-with-our-community","text":"Join the Discord Channel for community discussion Follow the Pact GitHub page for the latest updates on Pact development Ask questions about Pact on Stack Overflow using #pact-lang Get the latest Kadena updates from our Newsletter or Twitter","title":"Connect with our community"},{"location":"advanced/coming-soon/","text":"Coming Soon We're working hard to bring you more tutorials! These advanced Pact Tutorials are currently under development. Stay in touch while you wait Subscribe to our YouTube channel to access the latest Pact tutorials. Join the Discord Channel for community discussion Follow the Pact GitHub page for the latest updates on Pact development Ask questions about Pact on Stack Overflow using #pact-lang Get the latest Kadena updates and workshop announcements from our Newsletter or on Twitter @kadena_io View our Pact Beginner Tutorials to get an overview of the Pact language basics.","title":"Coming Soon"},{"location":"advanced/coming-soon/#coming-soon","text":"We're working hard to bring you more tutorials! These advanced Pact Tutorials are currently under development.","title":"Coming Soon"},{"location":"advanced/coming-soon/#stay-in-touch-while-you-wait","text":"Subscribe to our YouTube channel to access the latest Pact tutorials. Join the Discord Channel for community discussion Follow the Pact GitHub page for the latest updates on Pact development Ask questions about Pact on Stack Overflow using #pact-lang Get the latest Kadena updates and workshop announcements from our Newsletter or on Twitter @kadena_io View our Pact Beginner Tutorials to get an overview of the Pact language basics.","title":"Stay in touch while you wait"},{"location":"beginner/contract-interaction/","text":"Pact Contract Interaction Welcome to this tutorial on Pact Contract Interaction! Topics covered in this tutorial Pact Contract Interaction Overview Project Overview Project Environment Setup Auth Pact File Payments Pact File Payments REPL File Run the Smart Contract Review The goal of this tutorial is to learn the basics of building interactions between modules in Pact. You will go over some of the fundamentals, then build a smart contract that allows users to both make and authorize payments using multiple Pact modules. Key Takeaway Modules can make use of functions within other modules. This is done first with use , and then by calling the functions from within the module you are using. Each of these files are then loaded into the REPL where you can specify function calls and test interactions between these modules. Pact Contract Interaction Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Pact Contract Interaction Overview Contract interaction allows you to set up more complex smart contracts by working with modules across multiple files. Having access to separate files allows you to break up your smart contracts into more manageable sizes. It also allows you to use helpful files that others have created. In the image below, you can see that there are 2 files, module-1 and module-2 . In this case, module-2 is using module-1 to call functions that exist within the module. The REPL file then loads and uses both of these modules to call functions and facilitate the interaction. The three most helpful Pact functions to keep in mind for Contract Interaction are load , use , and function calls . Load Load and evaluate a file. (load file.repl ) Use Import an existing module into a namespace. (use MODULE) Once the interaction is set up between files, all function calls can be done the same as if the function existed within that file. Project Overview The idea of working with multiple modules and files is easiest to demonstrate with an example. For that reason, the rest of this tutorial is focused on getting you up and running with your own project. Before getting started with this application, take a look at the visual overview. This provides a summary of each of the features you will be creating for the Pact Contract Interaction project. The goal of this project is to write a function in auth.pact to use within payments.pact . Payments.pact will then use auth.pact to call specific functions. You will then load modules from both of these files into the payments.repl file to run the interaction between these contracts. Project Files Each number in the image corresponds to one of the files you will work with. auth.pact Responsible for authorizing users. payments.pact Responsible for handling payments between users. Payments.repl Loads and runs modules from both auth.pact and payments.pact. Note Both auth.pact and payments.pact are smart contracts that you have worked with in previous tutorials. If you would like to learn more about these smart contracts, feel free to view each of their tutorials. Auth Module: Project: Rotatable Wallet Payments Module: Accounts and Transfers There\u2019s not much code to write for this project. Most of it has been written previously in the tutorials linked above. For this tutorial, focus on understanding the interactions between the smart contracts, and to take some time to study how the functions are interacting with each other. Making the conceptual leap toward understanding the interactions between modules is going to be extremely valuable as you make more complicated smart contracts. Project Environment Setup To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the interaction directory to begin working on this project. cd pact-lang.org-code/interaction Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like. 1. Auth Pact File The first step of this project is to write the function that you will call from the payments smart contract. You will write this function within the auth smart contract. Note Navigate to 1-start/auth.pact or to 2-challenges/1-auth-pact depending on how you prefer to follow along. 1.1 Enforce User Auth The function you will write will enforce user authentication for payments made with accounts. This will be a valuable function for restricting access to either admins or account users, ensuring each user is the only person that has control over their account. Code Challenge Define a function enforce-user-auth that you can use to verify user authorization. Challenge Solution Note A function similar to this is covered in Challenge 4.2 in Project Rotatable Wallet . You can look back to this challenge for more information to help get you started. 2. Payments Pact File Next, you will work on the payments.pact file. The goal is to use the auth module, then call the function you wrote within the payments module to specify authorization for users. Note Navigate to 1-start/payments.pact or to 2-challenges/2-payments-pact depending on how you prefer to follow along. 2.1 Use Auth The first step is to get access to the auth module. You can do this with the Pact special form use . The syntax for use looks like this. (use MODULE) It\u2019s simple but extremely powerful! This is what will allow you to call functions from the auth module. Code Challenge Take a moment now to use the auth module from within the payments module. Challenge Solution 2.2 Create Account For this application, it\u2019s important that only the administrator has access to create an account. This is a good use case for the enforce-user-auth function you wrote in the auth module. Since you now have access to the auth module, you can begin working with its functions. You can call these functions the same as you would call any other function. ( function-name parameter ) Take some time now to add this new functionality to your smart contract. Code Challenge Call enforce-user-auth from within the create-account function to authorize that the user is an administrator. Challenge Solution 2.3 Get Balance Another time you may want to authorize a user is when checking the balance of an account. The payment modules get-balance function is an excellent use case for this. This time, both the administrator and the owner of the account should have access to view the account balance. Similar to before, check for authorization within the get-balance function. Code Challenge Call enforce-user-auth from within the get-balance function to authorize that function is called by the administrator. Challenge Solution 2.4 Pay Finally, it\u2019s important that payments are authorized by the owner of the account. This will ensure that only the person who has the money is able to send it to others. Code Challenge Finish off the payment module by authorizing that the payment is being sent by the owner of the account. Challenge Solution That completes the payment module. You are now ready to set up this contract interaction using the payments.repl file! 3. Payments REPL File You can now finish this project by completing on the payments.repl file. Note Navigate to 1-start/payments.repl or to 2-challenges/3-payments-repl depending on how you prefer to follow along. The goal is to use both the auth and payments module, then coordinate interactions between them. 3.1 Load Auth Module To get started, you need access to the auth module from within the payments.repl file. This is done using load . ( load file.pact ) Try using load to complete the code challenge. Code Challenge Load the auth module into the payments.repl file. Challenge Solution Note Transactions and loading are covered in more detail in Testing Pact Code in the SDK . 3.2 Load Payments Module Next, you need to load the payments module into the payments.repl file. This can be done the same way as you did with the auth module. Code Challenge Load the payments module into the payments.repl file. Challenge Solution 3.3 Use Auth Module You now have access to both the auth and payments module from within the payments.repl file. After loading each file, you also need to specify that you are using them. Like before, this can be done with the special form use . ( use MODULE ) Code Challenge Use the auth module from within the payments.repl file. Challenge Solution 3.4 Use Payments Module Finally, you need to use the payments module. Write one final line of code that uses the payments module and completes your set up for contract interaction. Code Challenge Use the payments module from within the payments.repl file. Challenge Solution You are now finished setting up your contract interaction. Congratulations! 4. Run REPL File After completing your contract interaction project, you can now see it all work together. To do this, navigate back to your terminal. From the terminal, you can navigate into 1-start folder if you have worked within this directory. If not, you can also navigate to the 3-finish folder for an example of the completed application. cd 3-finish Open Pact. pact Load the payments.repl file. (load payments.repl ) The output to your terminal should look similar to the image shown below. Note For more information on running files from the terminal, view Testing Pact Code in the SDK . Review Congratulations on completing this introduction to Pact Contract Interaction! In this tutorial, you learned the basics of contract interaction and built a smart contract that allowed users to both make and authorize payments. This allowed you to extend the functionality of your smart contract to include multiple files, and you can now use this to build more complex smart contracts in any project. Take a look back at some of the modules you have written or examples that you\u2019ve come across. Are there any interesting new ways that you think these contracts could work together? Give it a try and see if you can come up with an entirely new smart contract that combines these interesting features in new ways!","title":"10. Contract Interaction"},{"location":"beginner/contract-interaction/#pact-contract-interaction","text":"Welcome to this tutorial on Pact Contract Interaction! Topics covered in this tutorial Pact Contract Interaction Overview Project Overview Project Environment Setup Auth Pact File Payments Pact File Payments REPL File Run the Smart Contract Review The goal of this tutorial is to learn the basics of building interactions between modules in Pact. You will go over some of the fundamentals, then build a smart contract that allows users to both make and authorize payments using multiple Pact modules. Key Takeaway Modules can make use of functions within other modules. This is done first with use , and then by calling the functions from within the module you are using. Each of these files are then loaded into the REPL where you can specify function calls and test interactions between these modules.","title":"Pact Contract Interaction"},{"location":"beginner/contract-interaction/#pact-contract-interaction-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact Contract Interaction Tutorial"},{"location":"beginner/contract-interaction/#pact-contract-interaction-overview","text":"Contract interaction allows you to set up more complex smart contracts by working with modules across multiple files. Having access to separate files allows you to break up your smart contracts into more manageable sizes. It also allows you to use helpful files that others have created. In the image below, you can see that there are 2 files, module-1 and module-2 . In this case, module-2 is using module-1 to call functions that exist within the module. The REPL file then loads and uses both of these modules to call functions and facilitate the interaction. The three most helpful Pact functions to keep in mind for Contract Interaction are load , use , and function calls . Load Load and evaluate a file. (load file.repl ) Use Import an existing module into a namespace. (use MODULE) Once the interaction is set up between files, all function calls can be done the same as if the function existed within that file.","title":"Pact Contract Interaction Overview"},{"location":"beginner/contract-interaction/#project-overview","text":"The idea of working with multiple modules and files is easiest to demonstrate with an example. For that reason, the rest of this tutorial is focused on getting you up and running with your own project. Before getting started with this application, take a look at the visual overview. This provides a summary of each of the features you will be creating for the Pact Contract Interaction project. The goal of this project is to write a function in auth.pact to use within payments.pact . Payments.pact will then use auth.pact to call specific functions. You will then load modules from both of these files into the payments.repl file to run the interaction between these contracts. Project Files Each number in the image corresponds to one of the files you will work with. auth.pact Responsible for authorizing users. payments.pact Responsible for handling payments between users. Payments.repl Loads and runs modules from both auth.pact and payments.pact. Note Both auth.pact and payments.pact are smart contracts that you have worked with in previous tutorials. If you would like to learn more about these smart contracts, feel free to view each of their tutorials. Auth Module: Project: Rotatable Wallet Payments Module: Accounts and Transfers There\u2019s not much code to write for this project. Most of it has been written previously in the tutorials linked above. For this tutorial, focus on understanding the interactions between the smart contracts, and to take some time to study how the functions are interacting with each other. Making the conceptual leap toward understanding the interactions between modules is going to be extremely valuable as you make more complicated smart contracts.","title":"Project Overview"},{"location":"beginner/contract-interaction/#project-environment-setup","text":"To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the interaction directory to begin working on this project. cd pact-lang.org-code/interaction Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like.","title":"Project Environment Setup"},{"location":"beginner/contract-interaction/#1-auth-pact-file","text":"The first step of this project is to write the function that you will call from the payments smart contract. You will write this function within the auth smart contract. Note Navigate to 1-start/auth.pact or to 2-challenges/1-auth-pact depending on how you prefer to follow along.","title":"1. Auth Pact File"},{"location":"beginner/contract-interaction/#11-enforce-user-auth","text":"The function you will write will enforce user authentication for payments made with accounts. This will be a valuable function for restricting access to either admins or account users, ensuring each user is the only person that has control over their account. Code Challenge Define a function enforce-user-auth that you can use to verify user authorization. Challenge Solution Note A function similar to this is covered in Challenge 4.2 in Project Rotatable Wallet . You can look back to this challenge for more information to help get you started.","title":"1.1 Enforce User Auth"},{"location":"beginner/contract-interaction/#2-payments-pact-file","text":"Next, you will work on the payments.pact file. The goal is to use the auth module, then call the function you wrote within the payments module to specify authorization for users. Note Navigate to 1-start/payments.pact or to 2-challenges/2-payments-pact depending on how you prefer to follow along.","title":"2. Payments Pact File"},{"location":"beginner/contract-interaction/#21-use-auth","text":"The first step is to get access to the auth module. You can do this with the Pact special form use . The syntax for use looks like this. (use MODULE) It\u2019s simple but extremely powerful! This is what will allow you to call functions from the auth module. Code Challenge Take a moment now to use the auth module from within the payments module. Challenge Solution","title":"2.1 Use Auth"},{"location":"beginner/contract-interaction/#22-create-account","text":"For this application, it\u2019s important that only the administrator has access to create an account. This is a good use case for the enforce-user-auth function you wrote in the auth module. Since you now have access to the auth module, you can begin working with its functions. You can call these functions the same as you would call any other function. ( function-name parameter ) Take some time now to add this new functionality to your smart contract. Code Challenge Call enforce-user-auth from within the create-account function to authorize that the user is an administrator. Challenge Solution","title":"2.2 Create Account"},{"location":"beginner/contract-interaction/#23-get-balance","text":"Another time you may want to authorize a user is when checking the balance of an account. The payment modules get-balance function is an excellent use case for this. This time, both the administrator and the owner of the account should have access to view the account balance. Similar to before, check for authorization within the get-balance function. Code Challenge Call enforce-user-auth from within the get-balance function to authorize that function is called by the administrator. Challenge Solution","title":"2.3 Get Balance"},{"location":"beginner/contract-interaction/#24-pay","text":"Finally, it\u2019s important that payments are authorized by the owner of the account. This will ensure that only the person who has the money is able to send it to others. Code Challenge Finish off the payment module by authorizing that the payment is being sent by the owner of the account. Challenge Solution That completes the payment module. You are now ready to set up this contract interaction using the payments.repl file!","title":"2.4 Pay"},{"location":"beginner/contract-interaction/#3-payments-repl-file","text":"You can now finish this project by completing on the payments.repl file. Note Navigate to 1-start/payments.repl or to 2-challenges/3-payments-repl depending on how you prefer to follow along. The goal is to use both the auth and payments module, then coordinate interactions between them.","title":"3. Payments REPL File"},{"location":"beginner/contract-interaction/#31-load-auth-module","text":"To get started, you need access to the auth module from within the payments.repl file. This is done using load . ( load file.pact ) Try using load to complete the code challenge. Code Challenge Load the auth module into the payments.repl file. Challenge Solution Note Transactions and loading are covered in more detail in Testing Pact Code in the SDK .","title":"3.1 Load Auth Module"},{"location":"beginner/contract-interaction/#32-load-payments-module","text":"Next, you need to load the payments module into the payments.repl file. This can be done the same way as you did with the auth module. Code Challenge Load the payments module into the payments.repl file. Challenge Solution","title":"3.2 Load Payments Module"},{"location":"beginner/contract-interaction/#33-use-auth-module","text":"You now have access to both the auth and payments module from within the payments.repl file. After loading each file, you also need to specify that you are using them. Like before, this can be done with the special form use . ( use MODULE ) Code Challenge Use the auth module from within the payments.repl file. Challenge Solution","title":"3.3 Use Auth Module"},{"location":"beginner/contract-interaction/#34-use-payments-module","text":"Finally, you need to use the payments module. Write one final line of code that uses the payments module and completes your set up for contract interaction. Code Challenge Use the payments module from within the payments.repl file. Challenge Solution You are now finished setting up your contract interaction. Congratulations!","title":"3.4 Use Payments Module"},{"location":"beginner/contract-interaction/#4-run-repl-file","text":"After completing your contract interaction project, you can now see it all work together. To do this, navigate back to your terminal. From the terminal, you can navigate into 1-start folder if you have worked within this directory. If not, you can also navigate to the 3-finish folder for an example of the completed application. cd 3-finish Open Pact. pact Load the payments.repl file. (load payments.repl ) The output to your terminal should look similar to the image shown below. Note For more information on running files from the terminal, view Testing Pact Code in the SDK .","title":"4. Run REPL File"},{"location":"beginner/contract-interaction/#review","text":"Congratulations on completing this introduction to Pact Contract Interaction! In this tutorial, you learned the basics of contract interaction and built a smart contract that allowed users to both make and authorize payments. This allowed you to extend the functionality of your smart contract to include multiple files, and you can now use this to build more complex smart contracts in any project. Take a look back at some of the modules you have written or examples that you\u2019ve come across. Are there any interesting new ways that you think these contracts could work together? Give it a try and see if you can come up with an entirely new smart contract that combines these interesting features in new ways!","title":"Review"},{"location":"beginner/hello-world-with-pact/","text":"Hello World with Pact Welcome to this Hello World with Pact Tutorial! In this tutorial, you'll learn how to create, deploy, and run functions on a Hello World smart contract with Pact. Topics covered in this tutorial Hello World Overview Write the Smart Contract Deploy to the Testnet Call the Deployed Contract The goal of this tutorial is to help you get familiar with the essential Pact concepts needed to write, deploy, and run a smart contract. Learning these concepts will help you to create more complex smart contracts later in the series. Key Takeaway It\u2019s simple to create and deploy a Hello World smart contract with Pact. You can deploy smart contracts from the online editor, call its functions, and view the output from the REPL. Hello World with Pact Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Hello World Overview To get started, navigate to the Pact online editor at pact.kadena.io/ . Once on the site, you can open the \u201cHello World\u201d module. To do this, navigate to the module explorer on the tool panel and open the \u201cHello World\u201d example. Note If you\u2019re not familiar with the module explorer, you can learn more here . You can also copy the code below and paste it into your editor. ;; ;; Hello, world! smart contract/module ;; ;;--------------------------------- ;; ;; Create an admin-keyset and add some key, for loading this contract! ;; ;; Make sure the message is signed with this added key as well. ;; ;;--------------------------------- ;; Keysets cannot be created in code, thus we read them in ;; from the load message data. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ;; Define the module. ( module helloWorld admin-keyset A smart contract to greet the world. ( defun hello ( name ) Do the hello-world dance ( format Hello {}! [ name ])) ) ;; and say hello! ( hello world ) This code can also be found here on our GitHub. Write the Smart Contract Create a Keyset As you can see, the \u201cHello World\u201d smart contract starts by defining and reading a keyset. Keysets are a way to specify credentials for a user of the smart contract. The code you write within the smart contract can restrict access to users that own the keysets you define. You will see this done in the Hello World module. Line 16 (shown below) defines and reads a keyset named admin-keyset. ( define-keyset admin-keyset ( read-keyset admin-keyset )) Error If you look on line 16 line you will notice the following error. No such key in message: \u201cadmin-keyset\u201d This error exists because you are reading a keyset that does not exist. To get rid of this error you need to create a keyset named admin-keyset using the panel on the right. Steps to create a keyset Navigate to ENV Data Keysets from the right panel Enter admin-keyset Click Create The error message should now be gone. Create the Module Now that you have created a keyset, it\u2019s time to build the module for your smart contract. Modules are essential in Pact. They contain all the logic needed to run your smart contract. The syntax used to create a module is shown below. This line defines a module named helloWorld. It also gives the admin-keyset access to the code within this module. ( module helloWorld admin-keyset ;; MODULE CODE GOES HERE ) Define a Function The next step is to create the contract functions. Functions are defined within Pact modules using the keyword defun . For this smart contract, you\u2019ll define a function named hello that takes a parameter called name . ( defun hello ( name ) ;; FUNCTION CODE GOES HERE ) Do The Hello World Dance Within this function, you\u2019ll write a formatted line to output into the REPL. You can do this using the keyword format . Format allows you to manipulate strings and will help you specify the output of the function. ( format Hello {}! [ name ]) This line outputs a string to the REPL that says Hello followed by the string input to the function parameter name . The module for this smart contract is already complete! While this module is pretty simple, it gives you a great start to begin building more complex smart contracts. Say Hello World! The final step in this smart contract is to write \u201cHello World\u201d to the REPL. To do this, write a line below the module that calls the function and provide the input for name. ( hello world ) The line above calls the function hello and specifies the name as \u201cworld\u201d. You can change this input to any name you\u2019d like. Load into REPL Having written the smart contract, you are ready to load it into the REPL. A REPL is an interactive computing environment. It stands for read, eval, print, loop. This REPL exists within the online editor allowing you to run Pact code from within the browser. To load a contract into the REPL, select the Load into REPL button at the top of your editor. If everything is working correctly, you will see the REPL open up on the right side of your screen with the Hello World message as shown below. ;; Welcome to the Pact interactive repl ;; Use LOAD into REPL button to execute editor text ;; then just type at the pact prompt to interact! ;; ;; To reset the REPL type reset ! Hello world! pact If you can see this message, your Hello World smart contract is running from within the REPL. Deploy to the Testnet Loading into the REPL helps you test that your contract is working correctly, but it doesn't deploy it to a blockchain. When you're ready, you'll need to complete a few more steps to deploy your Hello World smart contract. Here\u2019s a quick summary of the steps needed to deploy to the blockchain. Step 1: Update Module Name Step 2: Update admin-keyset Name Step 3: Update Code Step 4: Create a Key Step 5: Set your deployment settings Update Module Name First, you need to update the module name. This name needs to be unique across all module names that exist on the blockchain. Choose any unique name you\u2019d like. For example, my module name is helloWorld-tutorial (choose a unique name that is different than mine). ( module helloWorld-tutorial admin-keyset ;; code goes here ) Note This unique module name is a requirement caused by a feature in Pact that allows you to upgrade your smart contracts. You will explore this idea in further detail later when you learn about upgrading contracts. Error You may come across the following error message when you attempt to deploy your contract. terminal ERROR: Command execution failed: (read-keyset \"admin-keyset-hel...: Failure: No such key in message: \"admin-keyset-helloworld\" This error means that an existing module on the blockchain already has the name you chose. Update the module name and redeploy the contract to resolve this error. Update admin-keyset Name Along with a unique module name, you\u2019ll also need a unique keyset name. This unique keyset ensures that only users with the keyset you define can gain access to the module. Delete the admin-keyset and create a new keyset with any unique name you like. The example below shows a new keyset named admin-keyset-helloworld . Update Code Having created a new keyset, you now need to update the code to match the name of the keyset you created. This name appears a few times in the smart contract so be careful to update each one. ( define-keyset admin-keyset-helloworld ( read-keyset admin-keyset-helloworld )) ( module helloWorld-tutorial admin-keyset-helloworld ( defun hello ( name ) ( format Hello {}! [ name ])) ) ( hello world ) Create a Key The purpose of the keyset is to hold keys that you can use to sign and verify your identity. When loading the contract to the REPL you were able to get away without having this key. To deploy your contract you need to make this key. You can create a key by completing the following steps. Select Enter Key Name Type the Key name Click Generate A simple convention for creating your key is to name it similar to the keyset. After creating your key, you\u2019ll see a checkbox appear under the admin-keyset with the name of the key. Select this checkbox to associate this key with the keyset. Set your deployment settings At the top of the screen, select Deploy . This will open a box that allows you to set your deployment settings. Once in the deployment settings, select either test-chain-01 or test-chain-02 to deploy your contract. Next, select the checkbox to sign this deployment with the key you created. Finally, select \"deploy contract\". If everything worked correctly, you should now see the string \u201cHello World!\u201d appear on the right panel as a message. At this point, you have deployed your Hello World smart contract with Pact. Congratulations! Call the Deployed Contract A fantastic feature of deploying to the blockchain is that anyone can now run the deployed code. You can check for yourself and run the function available on your own \u201cHello World\u201d smart contract. Module Explorer To do this, you\u2019ll need to first find the contract from the module explorer. Start by selecting the module explorer from the tool panel. Once there, navigate to the Deployed Contracts section and type the name of your contract. The name of your contract will be the same name as the module you created. After it appears, select view to see functions that are available for your smart contract. Find Function After selecting view , you should see the function named hello as an available option. Click call to open the screen that allows you to place your inputs into this function. Call Function Once on the Function: hello screen, you\u2019re ready to call your function. Steps to call a function Provide a string to pass in as an input. Be sure to surround this string in quotes. Select the checkbox to sign this call with the key. Click call to call your function. See the Output If everything worked out correctly, you should see the new function call appear as a new message! Now you can you call functions on the code you\u2019ve written, and you can call that code after it exists on the blockchain. You can use this same idea to call functions on any other contracts that have been deployed to the blockchain. Try for yourself to see if you can make function calls on other smart contracts. Review Congratulations on completing this tutorial! Throughout this tutorial you built, deployed, and ran functions on your Hello World smart contract with Pact. You\u2019re now prepared to play around and try anything you\u2019d like. You can create and define new keysets, change the parameters, or add anything that comes to mind. If you get lost, you can always go back to the module explorer to reload the original code. You can also visit the documentation using the link on the top right of the screen. Here you'll find more information about terminology, syntax, and other important ideas. If you\u2019re up for it, you can also load in different modules using the explorer to see how a different program looks.","title":"3. Hello World"},{"location":"beginner/hello-world-with-pact/#hello-world-with-pact","text":"Welcome to this Hello World with Pact Tutorial! In this tutorial, you'll learn how to create, deploy, and run functions on a Hello World smart contract with Pact. Topics covered in this tutorial Hello World Overview Write the Smart Contract Deploy to the Testnet Call the Deployed Contract The goal of this tutorial is to help you get familiar with the essential Pact concepts needed to write, deploy, and run a smart contract. Learning these concepts will help you to create more complex smart contracts later in the series. Key Takeaway It\u2019s simple to create and deploy a Hello World smart contract with Pact. You can deploy smart contracts from the online editor, call its functions, and view the output from the REPL.","title":"Hello World with Pact"},{"location":"beginner/hello-world-with-pact/#hello-world-with-pact-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Hello World with Pact Tutorial"},{"location":"beginner/hello-world-with-pact/#hello-world-overview","text":"To get started, navigate to the Pact online editor at pact.kadena.io/ . Once on the site, you can open the \u201cHello World\u201d module. To do this, navigate to the module explorer on the tool panel and open the \u201cHello World\u201d example. Note If you\u2019re not familiar with the module explorer, you can learn more here . You can also copy the code below and paste it into your editor. ;; ;; Hello, world! smart contract/module ;; ;;--------------------------------- ;; ;; Create an admin-keyset and add some key, for loading this contract! ;; ;; Make sure the message is signed with this added key as well. ;; ;;--------------------------------- ;; Keysets cannot be created in code, thus we read them in ;; from the load message data. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ;; Define the module. ( module helloWorld admin-keyset A smart contract to greet the world. ( defun hello ( name ) Do the hello-world dance ( format Hello {}! [ name ])) ) ;; and say hello! ( hello world ) This code can also be found here on our GitHub.","title":"Hello World Overview"},{"location":"beginner/hello-world-with-pact/#write-the-smart-contract","text":"","title":"Write the Smart Contract"},{"location":"beginner/hello-world-with-pact/#create-a-keyset","text":"As you can see, the \u201cHello World\u201d smart contract starts by defining and reading a keyset. Keysets are a way to specify credentials for a user of the smart contract. The code you write within the smart contract can restrict access to users that own the keysets you define. You will see this done in the Hello World module. Line 16 (shown below) defines and reads a keyset named admin-keyset. ( define-keyset admin-keyset ( read-keyset admin-keyset )) Error If you look on line 16 line you will notice the following error. No such key in message: \u201cadmin-keyset\u201d This error exists because you are reading a keyset that does not exist. To get rid of this error you need to create a keyset named admin-keyset using the panel on the right.","title":"Create a Keyset"},{"location":"beginner/hello-world-with-pact/#steps-to-create-a-keyset","text":"Navigate to ENV Data Keysets from the right panel Enter admin-keyset Click Create The error message should now be gone.","title":"Steps to create a keyset"},{"location":"beginner/hello-world-with-pact/#create-the-module","text":"Now that you have created a keyset, it\u2019s time to build the module for your smart contract. Modules are essential in Pact. They contain all the logic needed to run your smart contract. The syntax used to create a module is shown below. This line defines a module named helloWorld. It also gives the admin-keyset access to the code within this module. ( module helloWorld admin-keyset ;; MODULE CODE GOES HERE )","title":"Create the Module"},{"location":"beginner/hello-world-with-pact/#define-a-function","text":"The next step is to create the contract functions. Functions are defined within Pact modules using the keyword defun . For this smart contract, you\u2019ll define a function named hello that takes a parameter called name . ( defun hello ( name ) ;; FUNCTION CODE GOES HERE )","title":"Define a Function"},{"location":"beginner/hello-world-with-pact/#do-the-hello-world-dance","text":"Within this function, you\u2019ll write a formatted line to output into the REPL. You can do this using the keyword format . Format allows you to manipulate strings and will help you specify the output of the function. ( format Hello {}! [ name ]) This line outputs a string to the REPL that says Hello followed by the string input to the function parameter name . The module for this smart contract is already complete! While this module is pretty simple, it gives you a great start to begin building more complex smart contracts.","title":"Do The Hello World Dance"},{"location":"beginner/hello-world-with-pact/#say-hello-world","text":"The final step in this smart contract is to write \u201cHello World\u201d to the REPL. To do this, write a line below the module that calls the function and provide the input for name. ( hello world ) The line above calls the function hello and specifies the name as \u201cworld\u201d. You can change this input to any name you\u2019d like.","title":"Say Hello World!"},{"location":"beginner/hello-world-with-pact/#load-into-repl","text":"Having written the smart contract, you are ready to load it into the REPL. A REPL is an interactive computing environment. It stands for read, eval, print, loop. This REPL exists within the online editor allowing you to run Pact code from within the browser. To load a contract into the REPL, select the Load into REPL button at the top of your editor. If everything is working correctly, you will see the REPL open up on the right side of your screen with the Hello World message as shown below. ;; Welcome to the Pact interactive repl ;; Use LOAD into REPL button to execute editor text ;; then just type at the pact prompt to interact! ;; ;; To reset the REPL type reset ! Hello world! pact If you can see this message, your Hello World smart contract is running from within the REPL.","title":"Load into REPL"},{"location":"beginner/hello-world-with-pact/#deploy-to-the-testnet","text":"Loading into the REPL helps you test that your contract is working correctly, but it doesn't deploy it to a blockchain. When you're ready, you'll need to complete a few more steps to deploy your Hello World smart contract. Here\u2019s a quick summary of the steps needed to deploy to the blockchain. Step 1: Update Module Name Step 2: Update admin-keyset Name Step 3: Update Code Step 4: Create a Key Step 5: Set your deployment settings","title":"Deploy to the Testnet"},{"location":"beginner/hello-world-with-pact/#update-module-name","text":"First, you need to update the module name. This name needs to be unique across all module names that exist on the blockchain. Choose any unique name you\u2019d like. For example, my module name is helloWorld-tutorial (choose a unique name that is different than mine). ( module helloWorld-tutorial admin-keyset ;; code goes here ) Note This unique module name is a requirement caused by a feature in Pact that allows you to upgrade your smart contracts. You will explore this idea in further detail later when you learn about upgrading contracts. Error You may come across the following error message when you attempt to deploy your contract. terminal ERROR: Command execution failed: (read-keyset \"admin-keyset-hel...: Failure: No such key in message: \"admin-keyset-helloworld\" This error means that an existing module on the blockchain already has the name you chose. Update the module name and redeploy the contract to resolve this error.","title":"Update Module Name"},{"location":"beginner/hello-world-with-pact/#update-admin-keyset-name","text":"Along with a unique module name, you\u2019ll also need a unique keyset name. This unique keyset ensures that only users with the keyset you define can gain access to the module. Delete the admin-keyset and create a new keyset with any unique name you like. The example below shows a new keyset named admin-keyset-helloworld .","title":"Update admin-keyset Name"},{"location":"beginner/hello-world-with-pact/#update-code","text":"Having created a new keyset, you now need to update the code to match the name of the keyset you created. This name appears a few times in the smart contract so be careful to update each one. ( define-keyset admin-keyset-helloworld ( read-keyset admin-keyset-helloworld )) ( module helloWorld-tutorial admin-keyset-helloworld ( defun hello ( name ) ( format Hello {}! [ name ])) ) ( hello world )","title":"Update Code"},{"location":"beginner/hello-world-with-pact/#create-a-key","text":"The purpose of the keyset is to hold keys that you can use to sign and verify your identity. When loading the contract to the REPL you were able to get away without having this key. To deploy your contract you need to make this key. You can create a key by completing the following steps. Select Enter Key Name Type the Key name Click Generate A simple convention for creating your key is to name it similar to the keyset. After creating your key, you\u2019ll see a checkbox appear under the admin-keyset with the name of the key. Select this checkbox to associate this key with the keyset.","title":"Create a Key"},{"location":"beginner/hello-world-with-pact/#set-your-deployment-settings","text":"At the top of the screen, select Deploy . This will open a box that allows you to set your deployment settings. Once in the deployment settings, select either test-chain-01 or test-chain-02 to deploy your contract. Next, select the checkbox to sign this deployment with the key you created. Finally, select \"deploy contract\". If everything worked correctly, you should now see the string \u201cHello World!\u201d appear on the right panel as a message. At this point, you have deployed your Hello World smart contract with Pact. Congratulations!","title":"Set your deployment settings"},{"location":"beginner/hello-world-with-pact/#call-the-deployed-contract","text":"A fantastic feature of deploying to the blockchain is that anyone can now run the deployed code. You can check for yourself and run the function available on your own \u201cHello World\u201d smart contract.","title":"Call the Deployed Contract"},{"location":"beginner/hello-world-with-pact/#module-explorer","text":"To do this, you\u2019ll need to first find the contract from the module explorer. Start by selecting the module explorer from the tool panel. Once there, navigate to the Deployed Contracts section and type the name of your contract. The name of your contract will be the same name as the module you created. After it appears, select view to see functions that are available for your smart contract.","title":"Module Explorer"},{"location":"beginner/hello-world-with-pact/#find-function","text":"After selecting view , you should see the function named hello as an available option. Click call to open the screen that allows you to place your inputs into this function.","title":"Find Function"},{"location":"beginner/hello-world-with-pact/#call-function","text":"Once on the Function: hello screen, you\u2019re ready to call your function. Steps to call a function Provide a string to pass in as an input. Be sure to surround this string in quotes. Select the checkbox to sign this call with the key. Click call to call your function.","title":"Call Function"},{"location":"beginner/hello-world-with-pact/#see-the-output","text":"If everything worked out correctly, you should see the new function call appear as a new message! Now you can you call functions on the code you\u2019ve written, and you can call that code after it exists on the blockchain. You can use this same idea to call functions on any other contracts that have been deployed to the blockchain. Try for yourself to see if you can make function calls on other smart contracts.","title":"See the Output"},{"location":"beginner/hello-world-with-pact/#review","text":"Congratulations on completing this tutorial! Throughout this tutorial you built, deployed, and ran functions on your Hello World smart contract with Pact. You\u2019re now prepared to play around and try anything you\u2019d like. You can create and define new keysets, change the parameters, or add anything that comes to mind. If you get lost, you can always go back to the module explorer to reload the original code. You can also visit the documentation using the link on the top right of the screen. Here you'll find more information about terminology, syntax, and other important ideas. If you\u2019re up for it, you can also load in different modules using the explorer to see how a different program looks.","title":"Review"},{"location":"beginner/online-editor/","text":"Pact Online Editor Welcome to this tutorial on the Pact Online Editor! In this tutorial, you\u2019ll learn about the Pact Online editor, a powerful tool for developing smart contracts with Pact. Topics covered in this tutorial Introduction to the Editor Navigation Bar Code Editor Tool Panel The goal of this tutorial is to get you familiar with each of the editor\u2019s powerful features so that you can use it to build smart contracts using pact. Key Takeaway The Pact Online Editor is a robust development environment for Pact. It gives you access to many useful features for smart contract development. These features allow you to easily build and test contracts before deploying them to either your private chain or Chainweb . Pact Online Editor Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Introduction to the Editor The Pact Online Editor is a web-based REPL that allows you to write Pact code, manage keysets, deploy smart contracts, and explore other smart contracts. These and many other features make the online editor an ideal place to build, test, and deploy your smart contracts. To get started with the Pact Online Editor, navigate to pact.kadena.io/ . Basic Layout Here you'll see a clean and intuitive layout, giving you access to the tools you need without cluttering the developer experience. The interface consists of three main sections; the code editor , the navigation bar , and the tool panel . Code Editor An area for writing and editing your smart contracts. Navigation Bar Includes relevant documentation links and allows you to load code into the REPL or deploy smart contract. Tool Panel Provides essential functionality needed to manage keys, interact with the REPL, view messages, explore modules, and more. Each of these features helps provide an intuitive developer experience. These features make smart contract development both fun and rewarding. Navigation Bar You can locate the navigation bar at the top of the screen. It allows you to load your contract into the REPL, or to deploy the contract to a live network. It also shows the Pact version number and links to these tutorials, the Pact language documentation and the Kadena homepage. Load into REPL Selecting \u201cLoad into REPL\u201d loads text from the editor into the REPL and executes the commands. After selecting this button, you\u2019ll also notice that it opens an interactive terminal you can use to run Pact commands. You\u2019ll use this feature often when exploring the REPL later in this tutorial. Deploy The deploy button is used to deploy smart contracts onto the blockchain. Select Deploy to view the features available to you. Here you\u2019ll have the option to choose a server, set a few settings, sign the transaction and more. This tutorial doesn't go over the details of each of these options. If you'd like, view Hello World with Pact for a full description of smart contract deployment with the Online Editor. You can close this window by either hitting cancel or the X on the top right. Navigation The navigation bar also provides some necessary information and links to help you get started with Pact. Pact Version 2.6.1 At the time of this tutorial, Pact is currently on version 2.6.1. As this continues to update its likely that some of the features we explore will continue to improve. Available Links Links to the Pact tutorials, developer documentation and Kadena homepage can also be found on the navigation bar. Documentation Provides an in-depth look at the Pact programming language. Tutorials Learn more about Pact by completing tutorials like this. Kadena Explore the Kadena blockchain, which is the enterprise-grade blockchain that Pact runs on. Newsletter You can also join the newsletter to stay up to date on the latest Kadena and Pact information here . Code Editor The code editor provides a familiar editing interface. It comes equipped with both inline error reporting and formal verification . Inline Error Reporting Inline error reporting ensures that you have clear direction on how to fix errors that may exist in your code. For example, if you look at line 17 of your smart contract you\u2019ll see the error shown above. This and other errors types state the issue and help you to fix problems that may be affecting your smart contract. Error You can fix this error by creating an admin-keyset. Creating an admin-keyset can be done using the tool panel which we\u2019ll discuss more shortly. Formal Verification The online editor also supports formal verification. Formal verification is a process for automatically testing the correctness of your code. It mathematically proves that your contract has absolutely no security vulnerabilities. It also alerts you to any potential errors and vulnerabilities helping you create secure code quickly and effectively. Formal verification is a tremendous innovation for smart contract languages. For more information on how this helps you develop safer smart contracts, read our Medium post Pact Formal Verification: Making Blockchain Smart Contracts Safer. Tool Panel The tool panel gives you access to many beneficial features while developing smart contracts. It helps you set-up your environment, run commands in the interactive REPL, read messages, and explore other modules that exist on the network. Env The first option available to you in the tool panel is the environment. Select Env to view sections for addressing errors and creating and managing data and wallets from the UI. Manage Errors Errors can be viewed and fixed using the errors section. As you can see here, it currently shows an error that there is no such key in the message \u2018admin-keyset\u2019. This error is the same as what you saw previously in the editor. To fix this error, select the fix button on the right side of the screen. As you\u2019ll see, this creates a keyset for you in the data section below. This along with many other errors and warnings can be fixed using this simple tool. Coming up you\u2019ll see how to create this keyset manually. Remove the admin-keyset by selecting the x to the right of the recently created keyset. Create and Manage Keysets The data section allows you to create and manage keysets. To get started, select the input Enter Keyset Name type admin-keyset then click create . You should now see admin-keyset appear under your list of available keysets. Tip You can delete keys using the x over on the right. You\u2019ll also see a dropdown that allows you to select keys-all, keys-2, and keys-any. These options refer to the number of key signatures required to validate a transaction. For more information on this and a more in-depth explanation of keys in Pact, see the tutorial on Pact Keysets. Result Each key created has a JSON representation available for programmatic access. In the Result tab, you can see the keys you have created shown in JSON. Raw You can also create keysets using the JSON format rather than the user interface. Creating keysets with JSON is done using the Raw tab. To create a new key, specify a keyset name , keys , and pred , similar to the format seen in the Result tab. Info Pred Stands for \u201cPredicate Function\u201d. A predicate function is a boolean value function evaluating to either true or false. In this case, it will be one of the options keys-any , keys-2 , or keys-all as you had seen in the keysets tab. Predicate functions specify which keys need to sign the transaction for it to be valid. Add Key As the name suggests, keysets are used to hold keys. You can create these keys in the section below Data named Wallet. To create a wallet, first, enter a key name then select Generate . I\u2019ll name mine admin-key, but you can choose whatever you\u2019d like You should now see the key name, the public key, and the private key you generated. This key is useful any time you'd like to deploy or interact with a smart contract. REPL A great way to get started with Pact is to jump in and start writing code for yourself. The REPL helps you to do this quickly and allows you to run Pact commands from directly within the browser. Try running some of the commands shown below to get started with the REPL. Add numbers Pact uses prefix notation for math operators. Prefix notation is standard in LISP-like languages like Pact. What this means is that the operator precedes the two values it\u2019s operating on. (+ 2 2) 4 Strings Concatenate strings using +. Try saying Hello REPL. pact (+ Hello REPL ) \u201cHello REPL\u201d Try More Commands You can view many more commands in the Pact Syntax Documentation and Built-in Functions Documentation . Try running a few for yourself to learn more about the Pact programming langauge. Run Commands from the Code Editor It\u2019s also possible to run REPL commands from the code editor . To get started, delete the existing code from the code editor and select REPL from the tool panel. To run commands using the editor, enter a command and then select Load into REPL at the top of the screen. Experiment with other commands yourself by running some of the ones shown previously. Messages Code editors often provide messages to developers that help them identify errors and log outputs. These are useful ways to debug programs and fix potential issues with your contract. In the Pact Online Editor, these messages can be seen in the messages tab in the Toolbar. Module Explorer Another powerful tool provided by the editor is the Module Explorer . The module explorer allows you to load example contracts, deployed contracts, and to run functions that exist on any contracts that exist on the network! Click on the button module explorer to get started. Here you\u2019ll see a section for example contracts and a section for deployed contracts . Example Contracts The example contracts section allows you to load example contracts directly into your editor. You can use this code however you\u2019d like, and can always come back here to reload the code again if needed. When you first loaded pact.kadena.io/ the Formal Verification contract shown here is automatically loaded. Select view open to reload this contract. View other Smart Contracts You can also view other smart contracts. Select View Open on any smart contract to load its code into the code editor. View Functions You can view a summary of functions that exist within any smart contract from within the module explorer . After selecting View , you will see an overview of these functions. The image below shows the functions in the example Simple Payment . Deployed Contracts You can also view any contract that has been deployed to the network using the Module Explorer. You can search by name, by chain, or by navigating the pages using the arrow buttons. Once you find a particular contract, select view . From here you can look at each function on the contract, and when you\u2019re ready, select open to see the contract code. You can also call functions on modules from within the editor. For more information on calling functions, see Hello World with Pact. Review Congratulations! You have completed your introduction to the Pact Online Editor . The Pact Online Editor is an excellent tool built to make developing smart contracts with Pact both fun and simple. Topic Summary Throughout this tutorial, you explored each core feature of the editor's interface. This included each of the following topics. Introduction to the Editor Navigation Bar Code Editor Tool Panel Take some time now to explore each of the features we discussed and get used to navigating this new environment. As you continue with Pact, you\u2019ll use this tool regularly to help explore new ideas, write smart contracts, manage keysets, and explore modules. Throughout these tutorials, you\u2019ll use this tool very often. By getting used to these core features, you're on your way to making amazing new applications using Pact.","title":"2. Online Editor"},{"location":"beginner/online-editor/#pact-online-editor","text":"Welcome to this tutorial on the Pact Online Editor! In this tutorial, you\u2019ll learn about the Pact Online editor, a powerful tool for developing smart contracts with Pact. Topics covered in this tutorial Introduction to the Editor Navigation Bar Code Editor Tool Panel The goal of this tutorial is to get you familiar with each of the editor\u2019s powerful features so that you can use it to build smart contracts using pact. Key Takeaway The Pact Online Editor is a robust development environment for Pact. It gives you access to many useful features for smart contract development. These features allow you to easily build and test contracts before deploying them to either your private chain or Chainweb .","title":"Pact Online Editor"},{"location":"beginner/online-editor/#pact-online-editor-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact Online Editor Tutorial"},{"location":"beginner/online-editor/#introduction-to-the-editor","text":"The Pact Online Editor is a web-based REPL that allows you to write Pact code, manage keysets, deploy smart contracts, and explore other smart contracts. These and many other features make the online editor an ideal place to build, test, and deploy your smart contracts. To get started with the Pact Online Editor, navigate to pact.kadena.io/ .","title":"Introduction to the Editor"},{"location":"beginner/online-editor/#basic-layout","text":"Here you'll see a clean and intuitive layout, giving you access to the tools you need without cluttering the developer experience. The interface consists of three main sections; the code editor , the navigation bar , and the tool panel . Code Editor An area for writing and editing your smart contracts. Navigation Bar Includes relevant documentation links and allows you to load code into the REPL or deploy smart contract. Tool Panel Provides essential functionality needed to manage keys, interact with the REPL, view messages, explore modules, and more. Each of these features helps provide an intuitive developer experience. These features make smart contract development both fun and rewarding.","title":"Basic Layout"},{"location":"beginner/online-editor/#navigation-bar","text":"You can locate the navigation bar at the top of the screen. It allows you to load your contract into the REPL, or to deploy the contract to a live network. It also shows the Pact version number and links to these tutorials, the Pact language documentation and the Kadena homepage.","title":"Navigation Bar"},{"location":"beginner/online-editor/#load-into-repl","text":"Selecting \u201cLoad into REPL\u201d loads text from the editor into the REPL and executes the commands. After selecting this button, you\u2019ll also notice that it opens an interactive terminal you can use to run Pact commands. You\u2019ll use this feature often when exploring the REPL later in this tutorial.","title":"Load into REPL"},{"location":"beginner/online-editor/#deploy","text":"The deploy button is used to deploy smart contracts onto the blockchain. Select Deploy to view the features available to you. Here you\u2019ll have the option to choose a server, set a few settings, sign the transaction and more. This tutorial doesn't go over the details of each of these options. If you'd like, view Hello World with Pact for a full description of smart contract deployment with the Online Editor. You can close this window by either hitting cancel or the X on the top right.","title":"Deploy"},{"location":"beginner/online-editor/#navigation","text":"The navigation bar also provides some necessary information and links to help you get started with Pact. Pact Version 2.6.1 At the time of this tutorial, Pact is currently on version 2.6.1. As this continues to update its likely that some of the features we explore will continue to improve.","title":"Navigation"},{"location":"beginner/online-editor/#available-links","text":"Links to the Pact tutorials, developer documentation and Kadena homepage can also be found on the navigation bar. Documentation Provides an in-depth look at the Pact programming language. Tutorials Learn more about Pact by completing tutorials like this. Kadena Explore the Kadena blockchain, which is the enterprise-grade blockchain that Pact runs on. Newsletter You can also join the newsletter to stay up to date on the latest Kadena and Pact information here .","title":"Available Links"},{"location":"beginner/online-editor/#code-editor","text":"The code editor provides a familiar editing interface. It comes equipped with both inline error reporting and formal verification .","title":"Code Editor"},{"location":"beginner/online-editor/#inline-error-reporting","text":"Inline error reporting ensures that you have clear direction on how to fix errors that may exist in your code. For example, if you look at line 17 of your smart contract you\u2019ll see the error shown above. This and other errors types state the issue and help you to fix problems that may be affecting your smart contract. Error You can fix this error by creating an admin-keyset. Creating an admin-keyset can be done using the tool panel which we\u2019ll discuss more shortly.","title":"Inline Error Reporting"},{"location":"beginner/online-editor/#formal-verification","text":"The online editor also supports formal verification. Formal verification is a process for automatically testing the correctness of your code. It mathematically proves that your contract has absolutely no security vulnerabilities. It also alerts you to any potential errors and vulnerabilities helping you create secure code quickly and effectively. Formal verification is a tremendous innovation for smart contract languages. For more information on how this helps you develop safer smart contracts, read our Medium post Pact Formal Verification: Making Blockchain Smart Contracts Safer.","title":"Formal Verification"},{"location":"beginner/online-editor/#tool-panel","text":"The tool panel gives you access to many beneficial features while developing smart contracts. It helps you set-up your environment, run commands in the interactive REPL, read messages, and explore other modules that exist on the network.","title":"Tool Panel"},{"location":"beginner/online-editor/#env","text":"The first option available to you in the tool panel is the environment. Select Env to view sections for addressing errors and creating and managing data and wallets from the UI.","title":"Env"},{"location":"beginner/online-editor/#manage-errors","text":"Errors can be viewed and fixed using the errors section. As you can see here, it currently shows an error that there is no such key in the message \u2018admin-keyset\u2019. This error is the same as what you saw previously in the editor. To fix this error, select the fix button on the right side of the screen. As you\u2019ll see, this creates a keyset for you in the data section below. This along with many other errors and warnings can be fixed using this simple tool. Coming up you\u2019ll see how to create this keyset manually. Remove the admin-keyset by selecting the x to the right of the recently created keyset.","title":"Manage Errors"},{"location":"beginner/online-editor/#create-and-manage-keysets","text":"The data section allows you to create and manage keysets. To get started, select the input Enter Keyset Name type admin-keyset then click create . You should now see admin-keyset appear under your list of available keysets. Tip You can delete keys using the x over on the right. You\u2019ll also see a dropdown that allows you to select keys-all, keys-2, and keys-any. These options refer to the number of key signatures required to validate a transaction. For more information on this and a more in-depth explanation of keys in Pact, see the tutorial on Pact Keysets.","title":"Create and Manage Keysets"},{"location":"beginner/online-editor/#result","text":"Each key created has a JSON representation available for programmatic access. In the Result tab, you can see the keys you have created shown in JSON.","title":"Result"},{"location":"beginner/online-editor/#raw","text":"You can also create keysets using the JSON format rather than the user interface. Creating keysets with JSON is done using the Raw tab. To create a new key, specify a keyset name , keys , and pred , similar to the format seen in the Result tab. Info Pred Stands for \u201cPredicate Function\u201d. A predicate function is a boolean value function evaluating to either true or false. In this case, it will be one of the options keys-any , keys-2 , or keys-all as you had seen in the keysets tab. Predicate functions specify which keys need to sign the transaction for it to be valid.","title":"Raw"},{"location":"beginner/online-editor/#add-key","text":"As the name suggests, keysets are used to hold keys. You can create these keys in the section below Data named Wallet. To create a wallet, first, enter a key name then select Generate . I\u2019ll name mine admin-key, but you can choose whatever you\u2019d like You should now see the key name, the public key, and the private key you generated. This key is useful any time you'd like to deploy or interact with a smart contract.","title":"Add Key"},{"location":"beginner/online-editor/#repl","text":"A great way to get started with Pact is to jump in and start writing code for yourself. The REPL helps you to do this quickly and allows you to run Pact commands from directly within the browser. Try running some of the commands shown below to get started with the REPL. Add numbers Pact uses prefix notation for math operators. Prefix notation is standard in LISP-like languages like Pact. What this means is that the operator precedes the two values it\u2019s operating on. (+ 2 2) 4 Strings Concatenate strings using +. Try saying Hello REPL. pact (+ Hello REPL ) \u201cHello REPL\u201d Try More Commands You can view many more commands in the Pact Syntax Documentation and Built-in Functions Documentation . Try running a few for yourself to learn more about the Pact programming langauge. Run Commands from the Code Editor It\u2019s also possible to run REPL commands from the code editor . To get started, delete the existing code from the code editor and select REPL from the tool panel. To run commands using the editor, enter a command and then select Load into REPL at the top of the screen. Experiment with other commands yourself by running some of the ones shown previously.","title":"REPL"},{"location":"beginner/online-editor/#messages","text":"Code editors often provide messages to developers that help them identify errors and log outputs. These are useful ways to debug programs and fix potential issues with your contract. In the Pact Online Editor, these messages can be seen in the messages tab in the Toolbar.","title":"Messages"},{"location":"beginner/online-editor/#module-explorer","text":"Another powerful tool provided by the editor is the Module Explorer . The module explorer allows you to load example contracts, deployed contracts, and to run functions that exist on any contracts that exist on the network! Click on the button module explorer to get started. Here you\u2019ll see a section for example contracts and a section for deployed contracts .","title":"Module Explorer"},{"location":"beginner/online-editor/#example-contracts","text":"The example contracts section allows you to load example contracts directly into your editor. You can use this code however you\u2019d like, and can always come back here to reload the code again if needed. When you first loaded pact.kadena.io/ the Formal Verification contract shown here is automatically loaded. Select view open to reload this contract. View other Smart Contracts You can also view other smart contracts. Select View Open on any smart contract to load its code into the code editor.","title":"Example Contracts"},{"location":"beginner/online-editor/#view-functions","text":"You can view a summary of functions that exist within any smart contract from within the module explorer . After selecting View , you will see an overview of these functions. The image below shows the functions in the example Simple Payment .","title":"View Functions"},{"location":"beginner/online-editor/#deployed-contracts","text":"You can also view any contract that has been deployed to the network using the Module Explorer. You can search by name, by chain, or by navigating the pages using the arrow buttons. Once you find a particular contract, select view . From here you can look at each function on the contract, and when you\u2019re ready, select open to see the contract code. You can also call functions on modules from within the editor. For more information on calling functions, see Hello World with Pact.","title":"Deployed Contracts"},{"location":"beginner/online-editor/#review","text":"Congratulations! You have completed your introduction to the Pact Online Editor . The Pact Online Editor is an excellent tool built to make developing smart contracts with Pact both fun and simple. Topic Summary Throughout this tutorial, you explored each core feature of the editor's interface. This included each of the following topics. Introduction to the Editor Navigation Bar Code Editor Tool Panel Take some time now to explore each of the features we discussed and get used to navigating this new environment. As you continue with Pact, you\u2019ll use this tool regularly to help explore new ideas, write smart contracts, manage keysets, and explore modules. Throughout these tutorials, you\u2019ll use this tool very often. By getting used to these core features, you're on your way to making amazing new applications using Pact.","title":"Review"},{"location":"beginner/pact-accounts-and-transfers/","text":"Pact Accounts and Transfers Welcome to this tutorial on Accounts and Transfers with Pact! This tutorial covers the following topics Project Environment Setup Module and Keysets Define Schema and Table Functions Create Table Create Accounts Make Payments Deploy Smart Contract The goal of this tutorial is to help you build an application that transfers value between two accounts. To do this, you\u2019ll build a smart contract that implements this functionality named Simple Payments. This is an important function of smart contracts and will set you up to create more complex applications using accounts and transfers. Key Takeaway Accounts and transfers are a key feature of many smart contracts. Using Pact, you can define tables that track account keysets and values, allowing you to set and update these values as needed. Pact Accounts and Transfers Subscribe to our YouTube channel to access the latest Pact tutorials. Project Overview To get started with this application, take a look at the visual overview. This provides a summary of each of the features you will be creating for the simple payment smart contract. As you can see, you will create a payments module including 3 functions; create-account , get-balance , and pay . These functions will store data on a payments-table which manages payments between 2 accounts Sarah and James . Now that you have a basic understanding of the requirements, you can start building the project for yourself! Project Environment Setup To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the loans directory to begin working on this project. cd pact-lang.org-code/payments Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like to. 1. Module and Keyset The first step is to set up the module and keysets for the smart contract. Code Challenge Define and read the admin-keyset, create the payments module, and give the admin-keyset access to the module. Challenge Solution Note If you\u2019re unfamiliar with modules and keyset, our Pact Modules Tutorial is a great place to get started. 2. Define Schema and Table The next step is to define the schema and table for the smart contract. The payments-table , will keep track of the balance of the accounts and associate that to the account\u2019s keyset. Payments Table fieldname fieldtype balance decimal keyset keyset Code Challenge Define a schema and table with columns balance and keyset . Challenge Solution Note Schema definitions are introduced in the Pact Schemas and Tables Tutorial . 3. Functions This smart contract will contain 3 functions create-account, get-balance, and pay. Each of these are essential functions to allow users to manage their accounts. Note You can review each of the function types in the Schemas and Tables Tutorial as well as the Pact Language Basics Tutorial . 3.1 Create Account First, add a function that allows the administrator to create accounts. This will allow you to add as many accounts as you\u2019d like. Code Challenge Create a function create-account that allows administrator to create accounts. Challenge Solution Note Try using enforce to regulate who has access to create an account. 3.2 Get Balance Now that you can create accounts, it is helpful to be able to view the balance of these accounts. In this case, we\u2019ll allow both users and administrators to view the balance. Code Challenge Create a function get-balance that allows administrators and users to view the balance of their account. Challenge Solution 3.3 Pay Next, you\u2019ll create the function that allows one account to pay another account. This allows accounts to transfer value from their account to another to begin making payments and managing their finances. Code Challenge Create a function pay that allows an account to pay another account. Challenge Solution 4. Create Table You have now completed the module. Outside of the module you can create the table that you defined earlier. Code Challenge Create the payments-table . Challenge Solution Note At this point you have completed the module. You will notice the previous challenge containing a final parenthesis to close out the module. The remaining steps are meant to help you call functions from within the module you created to put your smart contract to use. 5. Create Accounts The next step is to create the accounts that will transfer value. For this tutorial, create 2 accounts. Sarah James To do this, you use the create-account function built earlier. This function takes 3 arguments; id , initial-balance , and keyset . Code Challenge Call the create-account function to create accounts for Sarah and James . Challenge Solution 6. Make Payment The final step is to make a payment from one account to another. You can do this using the pay function created earlier. Code Challenge Use the pay function to transfer 25.0 to James from Sarah\u2019s account. After making the payment, read the balance of both Sarah and James. Challenge Solution Deploy the Smart Contract Congratulations, at this point you have completed the Simple Payment smart contract! If you\u2019d like, you can try deploying this smart contract. You can deploy this contract using the Pact Online Editor or from the Pact Atom SDK . If you choose to deploy this locally, you\u2019ll need the REPL file which you can find inside of the repository you cloned. For help getting started and deploying in each of these environments, try the following tutorials. Pact Online Editor Pact Development on Atom SDK Tutorial Review Congratulations on completing the Accounts and Transfers Tutorial ! In this tutorial, you built a Simple Payment application that creates accounts, views account balances, and makes payments between accounts. This is an important function of smart contracts and will set you up to create more complex applications using accounts and transfers. This is a key feature of many smart contracts and can be extended into all types of use cases. Take some time now to experiment with these features to try them out in creative new ways.","title":"9. Accounts and Transfers"},{"location":"beginner/pact-accounts-and-transfers/#pact-accounts-and-transfers","text":"Welcome to this tutorial on Accounts and Transfers with Pact! This tutorial covers the following topics Project Environment Setup Module and Keysets Define Schema and Table Functions Create Table Create Accounts Make Payments Deploy Smart Contract The goal of this tutorial is to help you build an application that transfers value between two accounts. To do this, you\u2019ll build a smart contract that implements this functionality named Simple Payments. This is an important function of smart contracts and will set you up to create more complex applications using accounts and transfers. Key Takeaway Accounts and transfers are a key feature of many smart contracts. Using Pact, you can define tables that track account keysets and values, allowing you to set and update these values as needed.","title":"Pact Accounts and Transfers"},{"location":"beginner/pact-accounts-and-transfers/#pact-accounts-and-transfers_1","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact Accounts and Transfers"},{"location":"beginner/pact-accounts-and-transfers/#project-overview","text":"To get started with this application, take a look at the visual overview. This provides a summary of each of the features you will be creating for the simple payment smart contract. As you can see, you will create a payments module including 3 functions; create-account , get-balance , and pay . These functions will store data on a payments-table which manages payments between 2 accounts Sarah and James . Now that you have a basic understanding of the requirements, you can start building the project for yourself!","title":"Project Overview"},{"location":"beginner/pact-accounts-and-transfers/#project-environment-setup","text":"To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the loans directory to begin working on this project. cd pact-lang.org-code/payments Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like to.","title":"Project Environment Setup"},{"location":"beginner/pact-accounts-and-transfers/#1-module-and-keyset","text":"The first step is to set up the module and keysets for the smart contract. Code Challenge Define and read the admin-keyset, create the payments module, and give the admin-keyset access to the module. Challenge Solution Note If you\u2019re unfamiliar with modules and keyset, our Pact Modules Tutorial is a great place to get started.","title":"1. Module and Keyset"},{"location":"beginner/pact-accounts-and-transfers/#2-define-schema-and-table","text":"The next step is to define the schema and table for the smart contract. The payments-table , will keep track of the balance of the accounts and associate that to the account\u2019s keyset. Payments Table fieldname fieldtype balance decimal keyset keyset Code Challenge Define a schema and table with columns balance and keyset . Challenge Solution Note Schema definitions are introduced in the Pact Schemas and Tables Tutorial .","title":"2. Define Schema and Table"},{"location":"beginner/pact-accounts-and-transfers/#3-functions","text":"This smart contract will contain 3 functions create-account, get-balance, and pay. Each of these are essential functions to allow users to manage their accounts. Note You can review each of the function types in the Schemas and Tables Tutorial as well as the Pact Language Basics Tutorial .","title":"3. Functions"},{"location":"beginner/pact-accounts-and-transfers/#31-create-account","text":"First, add a function that allows the administrator to create accounts. This will allow you to add as many accounts as you\u2019d like. Code Challenge Create a function create-account that allows administrator to create accounts. Challenge Solution Note Try using enforce to regulate who has access to create an account.","title":"3.1 Create Account"},{"location":"beginner/pact-accounts-and-transfers/#32-get-balance","text":"Now that you can create accounts, it is helpful to be able to view the balance of these accounts. In this case, we\u2019ll allow both users and administrators to view the balance. Code Challenge Create a function get-balance that allows administrators and users to view the balance of their account. Challenge Solution","title":"3.2 Get Balance"},{"location":"beginner/pact-accounts-and-transfers/#33-pay","text":"Next, you\u2019ll create the function that allows one account to pay another account. This allows accounts to transfer value from their account to another to begin making payments and managing their finances. Code Challenge Create a function pay that allows an account to pay another account. Challenge Solution","title":"3.3 Pay"},{"location":"beginner/pact-accounts-and-transfers/#4-create-table","text":"You have now completed the module. Outside of the module you can create the table that you defined earlier. Code Challenge Create the payments-table . Challenge Solution Note At this point you have completed the module. You will notice the previous challenge containing a final parenthesis to close out the module. The remaining steps are meant to help you call functions from within the module you created to put your smart contract to use.","title":"4. Create Table"},{"location":"beginner/pact-accounts-and-transfers/#5-create-accounts","text":"The next step is to create the accounts that will transfer value. For this tutorial, create 2 accounts. Sarah James To do this, you use the create-account function built earlier. This function takes 3 arguments; id , initial-balance , and keyset . Code Challenge Call the create-account function to create accounts for Sarah and James . Challenge Solution","title":"5. Create Accounts"},{"location":"beginner/pact-accounts-and-transfers/#6-make-payment","text":"The final step is to make a payment from one account to another. You can do this using the pay function created earlier. Code Challenge Use the pay function to transfer 25.0 to James from Sarah\u2019s account. After making the payment, read the balance of both Sarah and James. Challenge Solution","title":"6. Make Payment"},{"location":"beginner/pact-accounts-and-transfers/#deploy-the-smart-contract","text":"Congratulations, at this point you have completed the Simple Payment smart contract! If you\u2019d like, you can try deploying this smart contract. You can deploy this contract using the Pact Online Editor or from the Pact Atom SDK . If you choose to deploy this locally, you\u2019ll need the REPL file which you can find inside of the repository you cloned. For help getting started and deploying in each of these environments, try the following tutorials. Pact Online Editor Pact Development on Atom SDK Tutorial","title":"Deploy the Smart Contract"},{"location":"beginner/pact-accounts-and-transfers/#review","text":"Congratulations on completing the Accounts and Transfers Tutorial ! In this tutorial, you built a Simple Payment application that creates accounts, views account balances, and makes payments between accounts. This is an important function of smart contracts and will set you up to create more complex applications using accounts and transfers. This is a key feature of many smart contracts and can be extended into all types of use cases. Take some time now to experiment with these features to try them out in creative new ways.","title":"Review"},{"location":"beginner/pact-keysets/","text":"Pact Keysets This tutorial introduces another essential feature in Pact known as keysets. We\u2019ll discuss what keysets are, why they\u2019re important, and how they help regulate access to Pact modules. Tutorial Overview Introduction to Keysets Create a Keyset Define and Read a Keyset Create Keys Sign to Deploy a Contract Sign to Call a Function Sign to Run a Contract Key Takeaway Pact Keysets specify authorization to different parts of the smart contract. They determine which accounts have access to which parts of the program. They also contain keys which are an important part of acquiring the signatures needed to verify a transaction. Pact Keysets Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Introduction to Keysets Pact Keysets specify authorization to different parts of the smart contract. They determine which accounts have access to and update various parts of the program. Create a Keyset The first step toward working with keysets is to create one. Creating a keyset can be done using the online editor within the environment section. Navigate to pact.kadena.io Steps to create a keyset On the right panel navigate to ENV Data Keysets Enter a Keyset Name Enter admin-keyset Click Create You should now see admin-keyset appear under your list of available keysets. This keyset is now added into the browser\u2019s local storage. When you begin working locally, this keyset will need to exist in the .repl file that you create along with your .pact file. You will learn more about this process in later tutorials. Define and Read a Keyset After creating a keyset, you need to both define and read this keyset from within the smart contract you create. This is done using a pair of built-in functions; define-keyset and read-keyset . Here is the syntax used to define and read a keyset named \u201cadmin-keyset\u201d. ( define-keyset admin-keyset ( read-keyset admin-keyset )) Keysets guard the logic encoded within a module, these functions should be placed above the module and will fail if written within the module code. Note The single quote, \u2018, preceding the admin-keyset is an alternative way to represent a string rather than using double quotes. It is, in this case, referred to as a symbol and helps syntactically represent a unique item during runtime. Create Keys The keyset you have created is meant to hold keys. These keys are used to sign and verify transactions that occur from within the module. Steps to create a key On the right panel navigate to ENV Wallet Enter a key name Enter admin-key Click Generate You should now see the key name, the public key, and the private key of the key you generated. While one key is enough to get started, this tutorial will show you some other key options that are available to you. For that reason, take some time now to generate two more keys. Generate two more keys admin-key-2 admin-key-3 After creating these keys, notice that they are all available as checkboxes under the admin-keyset . Select each of these checkboxes now. You\u2019re now ready to use these keys to help understand predicate functions. Predicate Functions Alongside the keyset you created, you will see a dropdown that allows you to select keys-all, keys-2, and keys-any . These options are referred to as the predicate functions in your keyset. A predicate function is a boolean value function evaluating to either true or false. In this case, it will be one of the options keys-any , keys-2 , or keys-all as you had seen in the keysets tab. Predicate functions specify which keys need to sign the transaction for it to be valid. keys-all All available keys must sign the transaction to verify it. keys-2 Two keys must sign the transaction to verify it. keys-any Any single key can sign the transaction to verify it. The keys that the predicate function is referring to are those you selected with the checkboxes Which option to choose? Determining which is appropriate for your application depends on what you are trying to accomplish. In cases where all members of a group are equal, and it is important for each of them to sign the transaction, then you will use keys-all. If there are many members of the group but only a few need to verify the transaction, keys-2 could work well. And if anyone signing is enough to verify the transaction, select keys-any. Note In simple smart contracts, you will generally have a simple keyset, a single key, and a default value of keys-all for your predicate function. Result Each key created has an equivalent JSON representation you can view from the Result tab. Notice that this JSON object includes the name of your keyset, the public key of each of the keys you added to the keyset, and the current value of the predicate function you selected. Raw You can also create keysets using the JSON format rather than the user interface. Creating keysets with JSON is done using the Raw tab. This format will be used in real DApps or in .repl files for simulation. It allows you to copy your JSON formatted keysets to test and deploy on pact-web, allowing you simply copy and paste into this box rather than re-creating everything from scratch. To create a new key, specify a keyset name , keys , and pred , similar to the format seen in the Result tab. While keysets tab is a simple way to create new keysets on the website, raw tab is a simpler way of inputting keysets that already exist. Note Keysets created here will not appear in the Keysets tab, but they will appear in the Result tab. Sign to Deploy a Contract Verifying transactions with keysets is important when deploying a smart contract. You can check this out for yourself from the deployment screen in the online editor. Where to find the sign tab From pact.kadena.io select Deploy From the deployment settings screen, choose Sign You should now see the following screen, which includes the keysets and specified keys from within the module. To deploy the smart contract, you will need to select a number of keys using the checkbox to the right as specified in the predicate function. This will ensure that your smart contract is successfully verified. Note There are a few necessary changes you will need to make to your smart contract to deploy it that are unrelated to keysets. For that reason, you won\u2019t be deploying your contract in this tutorial. You can check out the Hello World with Pact tutorial if you\u2019d like support on deploying a smart contract. Sign to Call a Function Calling a function on a deployed contract is another time where key signatures become valuable. Note You cannot call any functions from the sample contracts in the Online Editors Module Explorer. Contracts must first be deployed to a blockchain before you are able to call them. For this and future examples, be sure to look under deployed contracts to call functions. To get started, view the helloWorld smart contract in the module explorer and call the hello function. Steps to call the hello function Select Module Explorer Search helloWorld Select View Select _Call After calling the function, you should see a screen showing the Parameters of the function. Select the Sign tab to the right of Parameters to view the keys available to use for signatures. Here you should again see each of the keys you have available to sign the transaction. In this case, the helloWorld contract does not have any signature restrictions so you can call the function without these. That said, it\u2019s also fine to sign with a key now to get some practice. Select the checkbox next to one of the admin-keys , and go back to the function parameters screen. Type \u201cPact Keys\u201d (or whatever you prefer) as a Parameter and click Call to call the function. After calling the function, you should see \u201cHello Pact Keys\u201d appear in the messages tab. You have now verified a transaction using a key signature on a deployed smart contract. Again, it wasn\u2019t required for this specific contract but this is a very simple way to get familiar with the process for when you need it later. Sign to Call a Function It\u2019s helpful to go through a process where you actually have restrictions on running code based on the keysets you have available. These restrictions can affect both your ability to load a contract into the REPL and the ability to call functions on a deployed contract. One example that does a good job exploring keysets and restrictions is the Simple Payment example. Navigate to Simple Payment example Select Module Explorer Examples Simple Payment Open You will be building a smart contract like this for yourself in a later tutorial. For now, you\u2019ll focus on a few critical areas that illustrate how to set keyset restrictions from within a module. Enforce-keyset Throughout the module, you\u2019ll notice the following built-in function. enforce-keyset This function executes a guard or defined keyset name to enforce desired predicate logic. You can find an example of this on row 28 of the Simple Payments smart contract which is summarized below. ...code ;; row 14: define keyset to guard module ( define-keyset admin-keyset ( read-keyset admin-keyset )) ...code ( defun create-account ( id initial-balance keyset ) ;; row 27: Must be administrator. ( enforce-keyset admin-keyset ) ...code Here is how the code sample above is working Before the module, the admin-keyset is defined and read. Once in the contract, a function named create-account is created that takes keyset as a parameter. Upon running the function, enforce-keyset is called to check the caller is the owner of admin-keyset . If the caller is the owner of admin-keyset, the function continues. If the caller is not the owner of the admin-keyset, the function fails. Using this method, you can check that the caller of any function is the owner of a keyset that you specify. Challenge Try running this code in the online editor using Load into REPL. You\u2019ll notice an error appear. Can you fix the error based on what you have learned so far? When you get the following response you have successfully fixed the first error. interactive :61:31: No such key in message: sarah-keyset !!! Feeling Stuck? Create a keyset named admin-keyset from within the Env to remove this error. In the next section, you will address the remaining errors. Enforce-one Keyset Another useful built-in function for checking keysets is known as enforce-one . enforce-one This built-in function runs a series of tests in a specific order to check that one of the following statements are true. You can find an example of this on row row 38 of the Simple Payments contract and is summarized below. ...code ;; row 14: define keyset to guard module ( define-keyset admin-keyset ( read-keyset admin-keyset )) ...code ;; Row 34: define keyset to guard module ( defun get-balance ( id ) Only users or admin can read balance. ( with-read payments-table id { balance := balance , keyset := keyset } ( enforce-one Access denied [( enforce-keyset keyset ) ( enforce-keyset admin-keyset )]) balance )) ...code ;; row 60: create accounts ( create-account Sarah 100.25 ( read-keyset sarah-keyset )) ( create-account James 250.0 ( read-keyset james-keyset )) ...code Similar to the previous example, this example is enforcing that the caller be the owner of the admin-keyset . Unlike the previous example, it is also allowing the caller to be the owner of their account. Note Enforce-one is meant for running all types of tests. It is not specific to checking for keysets. In this context, it is running tests to check keysets and works as an effective way to enforce that a specific keyset exists. Notice how it is doing this using enforce-one paired with enforce-keyset . Enforce-one starts a series of tests to check that any of the following lines are true. If one of them is true, the caller will gain access to run the rest of the function. If neither of them is true, the caller will get a response that their request has been denied since they are not the owner of one of the required keys. What this means is that both the admin and owner of the account can view their balance, but no one else can. Bug Try running the code in the online editor using Load into REPL. You\u2019ll notice an error appear. Can you fix the error based on what you have learned so far? When you get the following response you have successfully fixed the first error. James s balance is 275.0 Solution Create two keysets from within the Env to remove this error. sarah-keyset james-keyset After creating these keysets the response signifies that you have successfully deployed the smart contract into the REPL. Question Investigate the smart contract to try and determine why you are getting the response that James's balance is 275.0. Can you tell what is happening in this smart contract to produce this outcome? If you cannot tell, don\u2019t worry. You will get a much more detailed overview of this smart contract in a later tutorial. Deploy the Contract You are now ready to deploy the Simple Payments smart contract. For information on deploying a smart contract, view Deploy to the Testnet from the Hello World with Pact tutorial. Deployed Payments Contract Function Call Now that you have the appropriate keys and keysets, you can also run the deployed version of this smart contract. From the module explorer, view the module deployed in the previous section. Select the get-balance function to attempt to view James\u2019 balance. To do this, select parameters, and type \u201cJames\u201d as the id. Next, sign the contract with either the admin-key or the james-key . As shown earlier, each of these should have the authority to read James\u2019 account balance. After selecting call, you should see the James\u2019 balance displayed. If you\u2019d like to test that it is working correctly, you can also try to make this function call by signing with sarah-key . When doing this, you should receive an error since Sarah is only permitted to view her own balance. Using these ideas, you can call any function on the smart contract by giving the proper function parameters and signing the transactions with the appropriate keys. Review That wraps up this tutorial on Pact Keysets. As you learned, Pact Keysets allow you to specify authorization to different parts of the smart contract. They help determine which accounts have access to which parts of the programs you create. Throughout this tutorial you to created, defined, and read keysets. You also created keys, were introduced to predicate functions, and learned a few other options available to work with keys from the online editor. You also saw where to go to utilize these keys both when deploying a contract and calling a function. Finally, you experimented with running an existing smart contracts that had built-in keyset restrictions. Managing permissions can be difficult, and really depends on the needs of your application. For that reason, it\u2019s difficult to show all of the possibilities that may come up with keysets. That said, this tutorial tried to give a strong foundation for what options are available, and variations of these ideas will come up often in later tutorials. Take some time now to experiment with keys and keysets, and when you\u2019re ready, move on to our next tutorial.","title":"6. Keysets"},{"location":"beginner/pact-keysets/#pact-keysets","text":"This tutorial introduces another essential feature in Pact known as keysets. We\u2019ll discuss what keysets are, why they\u2019re important, and how they help regulate access to Pact modules. Tutorial Overview Introduction to Keysets Create a Keyset Define and Read a Keyset Create Keys Sign to Deploy a Contract Sign to Call a Function Sign to Run a Contract Key Takeaway Pact Keysets specify authorization to different parts of the smart contract. They determine which accounts have access to which parts of the program. They also contain keys which are an important part of acquiring the signatures needed to verify a transaction.","title":"Pact Keysets"},{"location":"beginner/pact-keysets/#pact-keysets-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact Keysets Tutorial"},{"location":"beginner/pact-keysets/#introduction-to-keysets","text":"Pact Keysets specify authorization to different parts of the smart contract. They determine which accounts have access to and update various parts of the program.","title":"Introduction to Keysets"},{"location":"beginner/pact-keysets/#create-a-keyset","text":"The first step toward working with keysets is to create one. Creating a keyset can be done using the online editor within the environment section. Navigate to pact.kadena.io Steps to create a keyset On the right panel navigate to ENV Data Keysets Enter a Keyset Name Enter admin-keyset Click Create You should now see admin-keyset appear under your list of available keysets. This keyset is now added into the browser\u2019s local storage. When you begin working locally, this keyset will need to exist in the .repl file that you create along with your .pact file. You will learn more about this process in later tutorials.","title":"Create a Keyset"},{"location":"beginner/pact-keysets/#define-and-read-a-keyset","text":"After creating a keyset, you need to both define and read this keyset from within the smart contract you create. This is done using a pair of built-in functions; define-keyset and read-keyset . Here is the syntax used to define and read a keyset named \u201cadmin-keyset\u201d. ( define-keyset admin-keyset ( read-keyset admin-keyset )) Keysets guard the logic encoded within a module, these functions should be placed above the module and will fail if written within the module code. Note The single quote, \u2018, preceding the admin-keyset is an alternative way to represent a string rather than using double quotes. It is, in this case, referred to as a symbol and helps syntactically represent a unique item during runtime.","title":"Define and Read a Keyset"},{"location":"beginner/pact-keysets/#create-keys","text":"The keyset you have created is meant to hold keys. These keys are used to sign and verify transactions that occur from within the module. Steps to create a key On the right panel navigate to ENV Wallet Enter a key name Enter admin-key Click Generate You should now see the key name, the public key, and the private key of the key you generated. While one key is enough to get started, this tutorial will show you some other key options that are available to you. For that reason, take some time now to generate two more keys. Generate two more keys admin-key-2 admin-key-3 After creating these keys, notice that they are all available as checkboxes under the admin-keyset . Select each of these checkboxes now. You\u2019re now ready to use these keys to help understand predicate functions.","title":"Create Keys"},{"location":"beginner/pact-keysets/#predicate-functions","text":"Alongside the keyset you created, you will see a dropdown that allows you to select keys-all, keys-2, and keys-any . These options are referred to as the predicate functions in your keyset. A predicate function is a boolean value function evaluating to either true or false. In this case, it will be one of the options keys-any , keys-2 , or keys-all as you had seen in the keysets tab. Predicate functions specify which keys need to sign the transaction for it to be valid. keys-all All available keys must sign the transaction to verify it. keys-2 Two keys must sign the transaction to verify it. keys-any Any single key can sign the transaction to verify it. The keys that the predicate function is referring to are those you selected with the checkboxes","title":"Predicate Functions"},{"location":"beginner/pact-keysets/#which-option-to-choose","text":"Determining which is appropriate for your application depends on what you are trying to accomplish. In cases where all members of a group are equal, and it is important for each of them to sign the transaction, then you will use keys-all. If there are many members of the group but only a few need to verify the transaction, keys-2 could work well. And if anyone signing is enough to verify the transaction, select keys-any. Note In simple smart contracts, you will generally have a simple keyset, a single key, and a default value of keys-all for your predicate function.","title":"Which option to choose?"},{"location":"beginner/pact-keysets/#result","text":"Each key created has an equivalent JSON representation you can view from the Result tab. Notice that this JSON object includes the name of your keyset, the public key of each of the keys you added to the keyset, and the current value of the predicate function you selected.","title":"Result"},{"location":"beginner/pact-keysets/#raw","text":"You can also create keysets using the JSON format rather than the user interface. Creating keysets with JSON is done using the Raw tab. This format will be used in real DApps or in .repl files for simulation. It allows you to copy your JSON formatted keysets to test and deploy on pact-web, allowing you simply copy and paste into this box rather than re-creating everything from scratch. To create a new key, specify a keyset name , keys , and pred , similar to the format seen in the Result tab. While keysets tab is a simple way to create new keysets on the website, raw tab is a simpler way of inputting keysets that already exist. Note Keysets created here will not appear in the Keysets tab, but they will appear in the Result tab.","title":"Raw"},{"location":"beginner/pact-keysets/#sign-to-deploy-a-contract","text":"Verifying transactions with keysets is important when deploying a smart contract. You can check this out for yourself from the deployment screen in the online editor. Where to find the sign tab From pact.kadena.io select Deploy From the deployment settings screen, choose Sign You should now see the following screen, which includes the keysets and specified keys from within the module. To deploy the smart contract, you will need to select a number of keys using the checkbox to the right as specified in the predicate function. This will ensure that your smart contract is successfully verified. Note There are a few necessary changes you will need to make to your smart contract to deploy it that are unrelated to keysets. For that reason, you won\u2019t be deploying your contract in this tutorial. You can check out the Hello World with Pact tutorial if you\u2019d like support on deploying a smart contract.","title":"Sign to Deploy a Contract"},{"location":"beginner/pact-keysets/#sign-to-call-a-function","text":"Calling a function on a deployed contract is another time where key signatures become valuable. Note You cannot call any functions from the sample contracts in the Online Editors Module Explorer. Contracts must first be deployed to a blockchain before you are able to call them. For this and future examples, be sure to look under deployed contracts to call functions. To get started, view the helloWorld smart contract in the module explorer and call the hello function. Steps to call the hello function Select Module Explorer Search helloWorld Select View Select _Call After calling the function, you should see a screen showing the Parameters of the function. Select the Sign tab to the right of Parameters to view the keys available to use for signatures. Here you should again see each of the keys you have available to sign the transaction. In this case, the helloWorld contract does not have any signature restrictions so you can call the function without these. That said, it\u2019s also fine to sign with a key now to get some practice. Select the checkbox next to one of the admin-keys , and go back to the function parameters screen. Type \u201cPact Keys\u201d (or whatever you prefer) as a Parameter and click Call to call the function. After calling the function, you should see \u201cHello Pact Keys\u201d appear in the messages tab. You have now verified a transaction using a key signature on a deployed smart contract. Again, it wasn\u2019t required for this specific contract but this is a very simple way to get familiar with the process for when you need it later.","title":"Sign to Call a Function"},{"location":"beginner/pact-keysets/#sign-to-call-a-function_1","text":"It\u2019s helpful to go through a process where you actually have restrictions on running code based on the keysets you have available. These restrictions can affect both your ability to load a contract into the REPL and the ability to call functions on a deployed contract. One example that does a good job exploring keysets and restrictions is the Simple Payment example. Navigate to Simple Payment example Select Module Explorer Examples Simple Payment Open You will be building a smart contract like this for yourself in a later tutorial. For now, you\u2019ll focus on a few critical areas that illustrate how to set keyset restrictions from within a module.","title":"Sign to Call a Function"},{"location":"beginner/pact-keysets/#enforce-keyset","text":"Throughout the module, you\u2019ll notice the following built-in function. enforce-keyset This function executes a guard or defined keyset name to enforce desired predicate logic. You can find an example of this on row 28 of the Simple Payments smart contract which is summarized below. ...code ;; row 14: define keyset to guard module ( define-keyset admin-keyset ( read-keyset admin-keyset )) ...code ( defun create-account ( id initial-balance keyset ) ;; row 27: Must be administrator. ( enforce-keyset admin-keyset ) ...code Here is how the code sample above is working Before the module, the admin-keyset is defined and read. Once in the contract, a function named create-account is created that takes keyset as a parameter. Upon running the function, enforce-keyset is called to check the caller is the owner of admin-keyset . If the caller is the owner of admin-keyset, the function continues. If the caller is not the owner of the admin-keyset, the function fails. Using this method, you can check that the caller of any function is the owner of a keyset that you specify. Challenge Try running this code in the online editor using Load into REPL. You\u2019ll notice an error appear. Can you fix the error based on what you have learned so far? When you get the following response you have successfully fixed the first error. interactive :61:31: No such key in message: sarah-keyset !!! Feeling Stuck? Create a keyset named admin-keyset from within the Env to remove this error. In the next section, you will address the remaining errors.","title":"Enforce-keyset"},{"location":"beginner/pact-keysets/#enforce-one-keyset","text":"Another useful built-in function for checking keysets is known as enforce-one . enforce-one This built-in function runs a series of tests in a specific order to check that one of the following statements are true. You can find an example of this on row row 38 of the Simple Payments contract and is summarized below. ...code ;; row 14: define keyset to guard module ( define-keyset admin-keyset ( read-keyset admin-keyset )) ...code ;; Row 34: define keyset to guard module ( defun get-balance ( id ) Only users or admin can read balance. ( with-read payments-table id { balance := balance , keyset := keyset } ( enforce-one Access denied [( enforce-keyset keyset ) ( enforce-keyset admin-keyset )]) balance )) ...code ;; row 60: create accounts ( create-account Sarah 100.25 ( read-keyset sarah-keyset )) ( create-account James 250.0 ( read-keyset james-keyset )) ...code Similar to the previous example, this example is enforcing that the caller be the owner of the admin-keyset . Unlike the previous example, it is also allowing the caller to be the owner of their account. Note Enforce-one is meant for running all types of tests. It is not specific to checking for keysets. In this context, it is running tests to check keysets and works as an effective way to enforce that a specific keyset exists. Notice how it is doing this using enforce-one paired with enforce-keyset . Enforce-one starts a series of tests to check that any of the following lines are true. If one of them is true, the caller will gain access to run the rest of the function. If neither of them is true, the caller will get a response that their request has been denied since they are not the owner of one of the required keys. What this means is that both the admin and owner of the account can view their balance, but no one else can. Bug Try running the code in the online editor using Load into REPL. You\u2019ll notice an error appear. Can you fix the error based on what you have learned so far? When you get the following response you have successfully fixed the first error. James s balance is 275.0 Solution Create two keysets from within the Env to remove this error. sarah-keyset james-keyset After creating these keysets the response signifies that you have successfully deployed the smart contract into the REPL. Question Investigate the smart contract to try and determine why you are getting the response that James's balance is 275.0. Can you tell what is happening in this smart contract to produce this outcome? If you cannot tell, don\u2019t worry. You will get a much more detailed overview of this smart contract in a later tutorial.","title":"Enforce-one Keyset"},{"location":"beginner/pact-keysets/#deploy-the-contract","text":"You are now ready to deploy the Simple Payments smart contract. For information on deploying a smart contract, view Deploy to the Testnet from the Hello World with Pact tutorial.","title":"Deploy the Contract"},{"location":"beginner/pact-keysets/#deployed-payments-contract-function-call","text":"Now that you have the appropriate keys and keysets, you can also run the deployed version of this smart contract. From the module explorer, view the module deployed in the previous section. Select the get-balance function to attempt to view James\u2019 balance. To do this, select parameters, and type \u201cJames\u201d as the id. Next, sign the contract with either the admin-key or the james-key . As shown earlier, each of these should have the authority to read James\u2019 account balance. After selecting call, you should see the James\u2019 balance displayed. If you\u2019d like to test that it is working correctly, you can also try to make this function call by signing with sarah-key . When doing this, you should receive an error since Sarah is only permitted to view her own balance. Using these ideas, you can call any function on the smart contract by giving the proper function parameters and signing the transactions with the appropriate keys.","title":"Deployed Payments Contract Function Call"},{"location":"beginner/pact-keysets/#review","text":"That wraps up this tutorial on Pact Keysets. As you learned, Pact Keysets allow you to specify authorization to different parts of the smart contract. They help determine which accounts have access to which parts of the programs you create. Throughout this tutorial you to created, defined, and read keysets. You also created keys, were introduced to predicate functions, and learned a few other options available to work with keys from the online editor. You also saw where to go to utilize these keys both when deploying a contract and calling a function. Finally, you experimented with running an existing smart contracts that had built-in keyset restrictions. Managing permissions can be difficult, and really depends on the needs of your application. For that reason, it\u2019s difficult to show all of the possibilities that may come up with keysets. That said, this tutorial tried to give a strong foundation for what options are available, and variations of these ideas will come up often in later tutorials. Take some time now to experiment with keys and keysets, and when you\u2019re ready, move on to our next tutorial.","title":"Review"},{"location":"beginner/pact-language-basics/","text":"Pact Language Basics Welcome to this tutorial on the Pact Language Basics! In this tutorial you'll learn some fundamental concepts you need to get started with Pact. You\u2019ll review some of the built-in functions Pact provides, review the language syntax, and write a few functions for yourself. Topics covered in this tutorial Pact Language Reference Pact Syntax Basic Commands Built in Functions Create Functions Key Takeaway The Pact Language Reference includes an overview of the syntax, basic commands, and built-in functions you\u2019ll use to create smart contracts. By getting familiar with these commands, you\u2019ll be prepared to build simple and safe smart contracts with the Pact programming language. Follow Along Open the online editor at pact.kadena.io to follow along with this tutorial. You can run each of the commands described to get more familiar with the Pact programming language. View the Pact Online Code Editor Tutorial for more information on running Pact commands. Pact Language Basics Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Get Started To get started with the Pact Language Basics, navigate to the Pact Smart Contract Language reference . The Pact Smart Contract Language reference describes the syntax and semantics of the Pact language. If you haven\u2019t already, take some time to review this documentation to better understand the Pact language. Pact Language Syntax Start by reviewing the language syntax . Pact syntax can be found using the navigation on the left or by scrolling down to \u201cSyntax\u201d on the home page. Try running each of the commands on this page in the Pact Online Editor . Along with those presented in the documentation, this tutorial reviews some of the more common commands you\u2019ll work with when developing smart contracts. Basic Commands Running basic operations in Pact is simple. Try running each of the commands below in your editor to get more familiar with basic Pact commands. Note If you are comfortable with data types from other languages, feel free to skip to the built-in functions section. Pact follows conventional standards that are reviewed here to help those get started who may be new to programming. Integer An integer is any whole number value that does not include a decimal. pact 19 19 Decimals Decimals are any values that include a decimal. pact 25.3 25.3 Strings Try to run the following string. Do you know what is causing the error? pact hello :0:0: Cannot resolve hello What went wrong? The issue is that Pact does not know what hello means. To make it a string, remember to put quotes around it. pact hello hello There is also an alternative way to represent strings using Pact. pact `hello hello Preceding strings with a single ` is commonly used to mark unique items such as function or table names. It does not support whitespace or multi-line strings, but can be a helpful way to identify strings more succinctly. These are referred to as symbols . Boolean Booleans include true and false. pact true true List Pact allows you to express lists using brackets. pact [ Alice Dinesh Lee ] [ Alice Dinesh Lee ] Objects Pact also has objects that closely resemble Javascript objects. Objects are key-value as shown below. pact { type : cat , name : Scratchy , age : 6 } { type : cat , name : Scratchy , age : 6} This object describes a pet cat named Scratchy who\u2019s 6 years old. Make a List of Objects Pact also allows you to make a list of objects. pact [ { type : cat , name : Scratchy , age : 6 } { type : dog , name : Fluffy , age : 3 } ] [{ type : cat , name : Scratchy , age : 6} { type : dog , name : Fluffy , age : 3}] The list above includes a cat named Scratchy, a dog named Fluffy, and gives them both an age value. Time Time has many different properties and is supported by Pact. Look through the following example along with the supporting summary of time formats to better understand one possibility of representing time with Pact. pact (format-time %Y-%m-%dT%H:%M:%S%N (time 2016-07-23T13:30:45Z )) 2016-07-23T13:30:45+00:00 The following table provides a summary of time formats in the order of the example shown above. format purpose %Y year, no padding. %m month of year, 0-padded to two chars, \"01\"\u2013\"12\" %d day of month, 0-padded to two chars, \"01\"\u2013\"31\" T Text character placed in formatting to separate date from time. This is meant to help make this differentiation but is not part of an actual time format. %H hour of day (24-hour), 0-padded to two chars, \"00\"\u2013\"23\" %M minute of hour, 0-padded to two chars, \"00\"\u2013\"59\" %S second of minute (without decimal part), 0-padded to two chars, \"00\"\u2013\"60\" %N ISO 8601 style numeric time zone (e.g., \"-06:00\" or \"+01:00\") /EXTENSION/ View the language reference for more time formats . Parenthesis When working more sophisticated programs in Pact, you\u2019ll quickly notice the heavy use of parentheses. This syntax comes from Pacts LISP like syntax and is common in all LISP like languages. Below is an example helloWorld module in Pact. Notice the use of parentheses to mark each statement including modules, functions, and logic. ( module helloWorld admin-keyset ( defun hello ( name ) ( format Hello {}! [ name ])) ) Comments Comments are creating using \" \" or ' ' to clearly describe the purpose of the code. Here is the same helloWorld smart contract with comments included in the module. ( module helloWorld admin-keyset A smart contract to greet the world. ( defun hello ( name ) Do the hello-world dance ( format Hello {}! [ name ])) ) Built-in Functions After getting familiar with the Pact language syntax, you are ready to start working with some of Pacts built-in functions. To access the Pact built-in functions , navigate to Built-in Functions using the navigation on the left. As you\u2019ll see, there are many functions organized into a few key categories. Pact Standard Library Built-in Function Categories General Database Time Operators Keysets Capabilities REPL-only functions While many of these are valuable to learn, this tutorial will focus on only a few of them to get you started. Many other functions will come up in later tutorials as they become relevant to the programs you create. Arithmetic Operators Some of the simplest built in functions are the arithmetic operations. In Pact you can also add, subtract, multiply, or divide by changing the operator. Note Pact uses prefix notation for math operators. This is common in LISP like languages like Pact. Prefix notation means that the operator precedes the 2 values it\u2019s performing the operation on. Add 2 Numbers For example, by typing the following operation into your terminal should return 25. pact (* 5 5) 25 Other math operations can be performed by changing multiply to add , subtract , or divide . Combine Expressions Pact\u2019s simple expression syntax makes it easy to build more complicated expressions by nesting parentheses. Have a look at the expression below followed by its Pact equivalent. Can you tell how this expression is evaluated? ;; Example: 5 + 2 - 4 = 3 ;; Pact ( + 5 ( - 2 4 ) ) = 3 In this case, Pact evaluates 2 - 4, to get -2, then evaluates -2 + 5 to get the final answer of 3. Comparison Operators Another group of helpful operators is the comparison operators. These check whether values are equal, not equal, greater than, less than, and includes other common comparisons. Here\u2019s a table showing each of the comparison operators available in Pact. Along with arithmetic operators and comparison operators, Pact supports boolean, exponential, rounding, and many other common operators. You can learn more about each of these in the operator documentation. != True if X does not equal Y. (!= \"hello\" \"goodbye\") = true True if X Y. ( 1 3) = true = True if X = Y. ( = 5.24 2.52) = false = True if X equals Y. (= [1 2 3] [1 2 3]) = true True if X Y. ( 1 3) = false = True if X = Y. ( = 1 3) = false Along with arithmetic operators and comparison operators, Pact supports boolean, exponential, rounding, and many other common operators. You can learn more about each of these in the operator documentation . General Built-in Functions General functions are responsible for common tasks like manipulating lists, assigning values, checking values, and have many other use cases. At The first function listed on this page is at . To run the at function, type the following command into your terminal and hit enter. pact (at 1 [1 2 3]) 2 As you can see, I get a result of 2, which is the 1st index of this list. You can also search for other values by changing the index. Try updating this to look at index 2 and you should get back a 3. Get a Value from an Object You can also use At to get the value from an object. By specifying the object key, you can return the value of that key from the object. pact (at name { type : cat , name : Scratchy , age : 6 }) Scratchy Bind Bind allows you to map a variable to a value from within an object. To create a binding, use the keyword bind followed by a source object. Follow this object with another object containing a specific value within the source using the := symbol. pact (bind { a : 1, b : 2 } { a := a-value } a-value) 1 Example Bindings are valuable when you want to bind the values of a table to a variable. Here is a brief example showing how they can be used within a function. ( defun pay ( from to ) ( with-read payments from { balance := from-bal } ...code ) This example reads a table named payments that includes a user from that is sending a balance. A binding is used in this case to map the balance , which is a column in the table, to the value of from-bal that is provided by the user. This allows you to call the balance of the user using the variable balance rather than the variable from-bal . Map Map allows you to apply a specific operation to all elements within a list and return the results. To create a mapping, use the keyword map followed by the operation and the list. pact (map (+ 1) [1 2 3]) [2 3 4] After running this command, a new list is returned with the value 1 added to each element within the original list. You can also use this operation to map other values, including strings. For example, if you have a list of names, you can map \u201cHello \u201d to each of them to returning a friendly message for each list item. pact (map (+ Hello ) [ Kadena Pact Standard Library ]) [ Hello Kadena Hello Pact Hello Standard Library ] After running this command, a new list is returned with the value \u201cHello \u201d added to each element within the original list. Note You can use any of the operators available in Pact when creating a mapping. Format Format allows you to piece messages together using a mix of strings and variables. Formatting is great to use any time you need to send messages to your users. To get started with the format function, paste the example from the documentation into your terminal. When you run this, you\u2019ll see that what you get back is a string that inserts the variables provided in the postfix into the original string where the brackets are located. ( format My {} has {} [ dog fleas ]) My dog has fleas You can now place whatever values you\u2019d like into this string. The first set of curly brackets corresponds to the first value in the list, the 2nd corresponds to the 2nd, and so on for as many values as exist. Prepare to Write Functions Coming up, you\u2019ll create a few functions for yourself. You can do this in the Pact Online Editor to get some practice creating and running functions. Before creating your functions, take a moment to create a keyset and module. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module myModule admin-keyset ;; DEFINE FUNCTION HERE ) Writing your functions within the module will allow you to run the programs you create. Create a Function While many built-in functions are provided for you with the Pact Standard Library, you\u2019ll often create your own functions. Here is the syntax used to create a function in Pact. ( defun returnPhrase ( a b ) ;; COMMANDS GO HERE ) In this example, a function named returnPhrase will accept inputs a and b. Format a String For your first function, try creating a phrase using the built-in format function from earlier. ( format My {} has {} [ dog fleas ]) My dog has fleas By creating a function, you can take any two inputs from a user and return a formatted string value. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module myModule admin-keyset ( defun returnPhrase ( a b ) ( format My {} has {} [ a b ]) ) ) ( returnPhrase dog fleas ) Select Load into REPL to see the output. You can now change these inputs to any values you\u2019d like. I\u2019ll try \u201ccat\u201d and \u201cclaws\u201d. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module myModule admin-keyset ( defun returnPhrase ( a b ) ( format My {} has {} [ a b ]) ) ) ( returnPhrase cat claws ) Select Load into REPL to see the new phrase. Add 2 Numbers Before wrapping up, try creating a function using one of the math operations from earlier. Here is the command used to add two numbers. pact (+ 5 5) 10 Try creating a function that takes any two numbers as input, adds them together, and returns their sum. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ;; Define the module. ( module myModule admin-keyset ( defun addNumbers ( a b ) ( + a b ) ) ) ;; Call the function ( addNumbers 12 7 ) You can now provide any two values to add with this function. Review That wraps up this introduction to the Pact Standard Library. Throughout this tutorial, we introduced the basics of the Pact programming language. You went over the Pact Standard Library, basic syntax, commands, and built-in functions. You also wrote a few functions for yourself. If you\u2019re familiar with other programming languages, a lot of these ideas should be familiar. The goal here was to make sure you know where to find helpful resources and are prepared to start writing smart contracts for yourself. If you\u2019re new to programming, this tutorial hopefully helped you better understand some of the fundamental concepts of programming. You're now ready to try some new ideas for yourself. Take some time to explore the documentation and try a few more of the Pact built-in functions. Smart contracts you create will depend on you being familiar with these basic ideas. You'll see plenty more examples of these concepts throughout the upcoming tutorials.","title":"4. Language Basics"},{"location":"beginner/pact-language-basics/#pact-language-basics","text":"Welcome to this tutorial on the Pact Language Basics! In this tutorial you'll learn some fundamental concepts you need to get started with Pact. You\u2019ll review some of the built-in functions Pact provides, review the language syntax, and write a few functions for yourself. Topics covered in this tutorial Pact Language Reference Pact Syntax Basic Commands Built in Functions Create Functions Key Takeaway The Pact Language Reference includes an overview of the syntax, basic commands, and built-in functions you\u2019ll use to create smart contracts. By getting familiar with these commands, you\u2019ll be prepared to build simple and safe smart contracts with the Pact programming language. Follow Along Open the online editor at pact.kadena.io to follow along with this tutorial. You can run each of the commands described to get more familiar with the Pact programming language. View the Pact Online Code Editor Tutorial for more information on running Pact commands.","title":"Pact Language Basics"},{"location":"beginner/pact-language-basics/#pact-language-basics-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact Language Basics Tutorial"},{"location":"beginner/pact-language-basics/#get-started","text":"To get started with the Pact Language Basics, navigate to the Pact Smart Contract Language reference . The Pact Smart Contract Language reference describes the syntax and semantics of the Pact language. If you haven\u2019t already, take some time to review this documentation to better understand the Pact language.","title":"Get Started"},{"location":"beginner/pact-language-basics/#pact-language-syntax","text":"Start by reviewing the language syntax . Pact syntax can be found using the navigation on the left or by scrolling down to \u201cSyntax\u201d on the home page. Try running each of the commands on this page in the Pact Online Editor . Along with those presented in the documentation, this tutorial reviews some of the more common commands you\u2019ll work with when developing smart contracts.","title":"Pact Language Syntax"},{"location":"beginner/pact-language-basics/#basic-commands","text":"Running basic operations in Pact is simple. Try running each of the commands below in your editor to get more familiar with basic Pact commands. Note If you are comfortable with data types from other languages, feel free to skip to the built-in functions section. Pact follows conventional standards that are reviewed here to help those get started who may be new to programming.","title":"Basic Commands"},{"location":"beginner/pact-language-basics/#integer","text":"An integer is any whole number value that does not include a decimal. pact 19 19","title":"Integer"},{"location":"beginner/pact-language-basics/#decimals","text":"Decimals are any values that include a decimal. pact 25.3 25.3","title":"Decimals"},{"location":"beginner/pact-language-basics/#strings","text":"Try to run the following string. Do you know what is causing the error? pact hello :0:0: Cannot resolve hello What went wrong? The issue is that Pact does not know what hello means. To make it a string, remember to put quotes around it. pact hello hello There is also an alternative way to represent strings using Pact. pact `hello hello Preceding strings with a single ` is commonly used to mark unique items such as function or table names. It does not support whitespace or multi-line strings, but can be a helpful way to identify strings more succinctly. These are referred to as symbols .","title":"Strings"},{"location":"beginner/pact-language-basics/#boolean","text":"Booleans include true and false. pact true true","title":"Boolean"},{"location":"beginner/pact-language-basics/#list","text":"Pact allows you to express lists using brackets. pact [ Alice Dinesh Lee ] [ Alice Dinesh Lee ]","title":"List"},{"location":"beginner/pact-language-basics/#objects","text":"Pact also has objects that closely resemble Javascript objects. Objects are key-value as shown below. pact { type : cat , name : Scratchy , age : 6 } { type : cat , name : Scratchy , age : 6} This object describes a pet cat named Scratchy who\u2019s 6 years old.","title":"Objects"},{"location":"beginner/pact-language-basics/#make-a-list-of-objects","text":"Pact also allows you to make a list of objects. pact [ { type : cat , name : Scratchy , age : 6 } { type : dog , name : Fluffy , age : 3 } ] [{ type : cat , name : Scratchy , age : 6} { type : dog , name : Fluffy , age : 3}] The list above includes a cat named Scratchy, a dog named Fluffy, and gives them both an age value.","title":"Make a List of Objects"},{"location":"beginner/pact-language-basics/#time","text":"Time has many different properties and is supported by Pact. Look through the following example along with the supporting summary of time formats to better understand one possibility of representing time with Pact. pact (format-time %Y-%m-%dT%H:%M:%S%N (time 2016-07-23T13:30:45Z )) 2016-07-23T13:30:45+00:00 The following table provides a summary of time formats in the order of the example shown above. format purpose %Y year, no padding. %m month of year, 0-padded to two chars, \"01\"\u2013\"12\" %d day of month, 0-padded to two chars, \"01\"\u2013\"31\" T Text character placed in formatting to separate date from time. This is meant to help make this differentiation but is not part of an actual time format. %H hour of day (24-hour), 0-padded to two chars, \"00\"\u2013\"23\" %M minute of hour, 0-padded to two chars, \"00\"\u2013\"59\" %S second of minute (without decimal part), 0-padded to two chars, \"00\"\u2013\"60\" %N ISO 8601 style numeric time zone (e.g., \"-06:00\" or \"+01:00\") /EXTENSION/ View the language reference for more time formats .","title":"Time"},{"location":"beginner/pact-language-basics/#parenthesis","text":"When working more sophisticated programs in Pact, you\u2019ll quickly notice the heavy use of parentheses. This syntax comes from Pacts LISP like syntax and is common in all LISP like languages. Below is an example helloWorld module in Pact. Notice the use of parentheses to mark each statement including modules, functions, and logic. ( module helloWorld admin-keyset ( defun hello ( name ) ( format Hello {}! [ name ])) )","title":"Parenthesis"},{"location":"beginner/pact-language-basics/#comments","text":"Comments are creating using \" \" or ' ' to clearly describe the purpose of the code. Here is the same helloWorld smart contract with comments included in the module. ( module helloWorld admin-keyset A smart contract to greet the world. ( defun hello ( name ) Do the hello-world dance ( format Hello {}! [ name ])) )","title":"Comments"},{"location":"beginner/pact-language-basics/#built-in-functions","text":"After getting familiar with the Pact language syntax, you are ready to start working with some of Pacts built-in functions. To access the Pact built-in functions , navigate to Built-in Functions using the navigation on the left. As you\u2019ll see, there are many functions organized into a few key categories. Pact Standard Library Built-in Function Categories General Database Time Operators Keysets Capabilities REPL-only functions While many of these are valuable to learn, this tutorial will focus on only a few of them to get you started. Many other functions will come up in later tutorials as they become relevant to the programs you create.","title":"Built-in Functions"},{"location":"beginner/pact-language-basics/#arithmetic-operators","text":"Some of the simplest built in functions are the arithmetic operations. In Pact you can also add, subtract, multiply, or divide by changing the operator. Note Pact uses prefix notation for math operators. This is common in LISP like languages like Pact. Prefix notation means that the operator precedes the 2 values it\u2019s performing the operation on.","title":"Arithmetic Operators"},{"location":"beginner/pact-language-basics/#add-2-numbers","text":"For example, by typing the following operation into your terminal should return 25. pact (* 5 5) 25 Other math operations can be performed by changing multiply to add , subtract , or divide .","title":"Add 2 Numbers"},{"location":"beginner/pact-language-basics/#combine-expressions","text":"Pact\u2019s simple expression syntax makes it easy to build more complicated expressions by nesting parentheses. Have a look at the expression below followed by its Pact equivalent. Can you tell how this expression is evaluated? ;; Example: 5 + 2 - 4 = 3 ;; Pact ( + 5 ( - 2 4 ) ) = 3 In this case, Pact evaluates 2 - 4, to get -2, then evaluates -2 + 5 to get the final answer of 3.","title":"Combine Expressions"},{"location":"beginner/pact-language-basics/#comparison-operators","text":"Another group of helpful operators is the comparison operators. These check whether values are equal, not equal, greater than, less than, and includes other common comparisons. Here\u2019s a table showing each of the comparison operators available in Pact. Along with arithmetic operators and comparison operators, Pact supports boolean, exponential, rounding, and many other common operators. You can learn more about each of these in the operator documentation. != True if X does not equal Y. (!= \"hello\" \"goodbye\") = true True if X Y. ( 1 3) = true = True if X = Y. ( = 5.24 2.52) = false = True if X equals Y. (= [1 2 3] [1 2 3]) = true True if X Y. ( 1 3) = false = True if X = Y. ( = 1 3) = false Along with arithmetic operators and comparison operators, Pact supports boolean, exponential, rounding, and many other common operators. You can learn more about each of these in the operator documentation .","title":"Comparison Operators"},{"location":"beginner/pact-language-basics/#general-built-in-functions","text":"General functions are responsible for common tasks like manipulating lists, assigning values, checking values, and have many other use cases.","title":"General Built-in Functions"},{"location":"beginner/pact-language-basics/#at","text":"The first function listed on this page is at . To run the at function, type the following command into your terminal and hit enter. pact (at 1 [1 2 3]) 2 As you can see, I get a result of 2, which is the 1st index of this list. You can also search for other values by changing the index. Try updating this to look at index 2 and you should get back a 3.","title":"At"},{"location":"beginner/pact-language-basics/#get-a-value-from-an-object","text":"You can also use At to get the value from an object. By specifying the object key, you can return the value of that key from the object. pact (at name { type : cat , name : Scratchy , age : 6 }) Scratchy","title":"Get a Value from an Object"},{"location":"beginner/pact-language-basics/#bind","text":"Bind allows you to map a variable to a value from within an object. To create a binding, use the keyword bind followed by a source object. Follow this object with another object containing a specific value within the source using the := symbol. pact (bind { a : 1, b : 2 } { a := a-value } a-value) 1 Example Bindings are valuable when you want to bind the values of a table to a variable. Here is a brief example showing how they can be used within a function. ( defun pay ( from to ) ( with-read payments from { balance := from-bal } ...code ) This example reads a table named payments that includes a user from that is sending a balance. A binding is used in this case to map the balance , which is a column in the table, to the value of from-bal that is provided by the user. This allows you to call the balance of the user using the variable balance rather than the variable from-bal .","title":"Bind"},{"location":"beginner/pact-language-basics/#map","text":"Map allows you to apply a specific operation to all elements within a list and return the results. To create a mapping, use the keyword map followed by the operation and the list. pact (map (+ 1) [1 2 3]) [2 3 4] After running this command, a new list is returned with the value 1 added to each element within the original list. You can also use this operation to map other values, including strings. For example, if you have a list of names, you can map \u201cHello \u201d to each of them to returning a friendly message for each list item. pact (map (+ Hello ) [ Kadena Pact Standard Library ]) [ Hello Kadena Hello Pact Hello Standard Library ] After running this command, a new list is returned with the value \u201cHello \u201d added to each element within the original list. Note You can use any of the operators available in Pact when creating a mapping.","title":"Map"},{"location":"beginner/pact-language-basics/#format","text":"Format allows you to piece messages together using a mix of strings and variables. Formatting is great to use any time you need to send messages to your users. To get started with the format function, paste the example from the documentation into your terminal. When you run this, you\u2019ll see that what you get back is a string that inserts the variables provided in the postfix into the original string where the brackets are located. ( format My {} has {} [ dog fleas ]) My dog has fleas You can now place whatever values you\u2019d like into this string. The first set of curly brackets corresponds to the first value in the list, the 2nd corresponds to the 2nd, and so on for as many values as exist.","title":"Format"},{"location":"beginner/pact-language-basics/#prepare-to-write-functions","text":"Coming up, you\u2019ll create a few functions for yourself. You can do this in the Pact Online Editor to get some practice creating and running functions. Before creating your functions, take a moment to create a keyset and module. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module myModule admin-keyset ;; DEFINE FUNCTION HERE ) Writing your functions within the module will allow you to run the programs you create.","title":"Prepare to Write Functions"},{"location":"beginner/pact-language-basics/#create-a-function","text":"While many built-in functions are provided for you with the Pact Standard Library, you\u2019ll often create your own functions. Here is the syntax used to create a function in Pact. ( defun returnPhrase ( a b ) ;; COMMANDS GO HERE ) In this example, a function named returnPhrase will accept inputs a and b.","title":"Create a Function"},{"location":"beginner/pact-language-basics/#format-a-string","text":"For your first function, try creating a phrase using the built-in format function from earlier. ( format My {} has {} [ dog fleas ]) My dog has fleas By creating a function, you can take any two inputs from a user and return a formatted string value. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module myModule admin-keyset ( defun returnPhrase ( a b ) ( format My {} has {} [ a b ]) ) ) ( returnPhrase dog fleas ) Select Load into REPL to see the output. You can now change these inputs to any values you\u2019d like. I\u2019ll try \u201ccat\u201d and \u201cclaws\u201d. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module myModule admin-keyset ( defun returnPhrase ( a b ) ( format My {} has {} [ a b ]) ) ) ( returnPhrase cat claws ) Select Load into REPL to see the new phrase.","title":"Format a String"},{"location":"beginner/pact-language-basics/#add-2-numbers_1","text":"Before wrapping up, try creating a function using one of the math operations from earlier. Here is the command used to add two numbers. pact (+ 5 5) 10 Try creating a function that takes any two numbers as input, adds them together, and returns their sum. ( define-keyset admin-keyset ( read-keyset admin-keyset )) ;; Define the module. ( module myModule admin-keyset ( defun addNumbers ( a b ) ( + a b ) ) ) ;; Call the function ( addNumbers 12 7 ) You can now provide any two values to add with this function.","title":"Add 2 Numbers"},{"location":"beginner/pact-language-basics/#review","text":"That wraps up this introduction to the Pact Standard Library. Throughout this tutorial, we introduced the basics of the Pact programming language. You went over the Pact Standard Library, basic syntax, commands, and built-in functions. You also wrote a few functions for yourself. If you\u2019re familiar with other programming languages, a lot of these ideas should be familiar. The goal here was to make sure you know where to find helpful resources and are prepared to start writing smart contracts for yourself. If you\u2019re new to programming, this tutorial hopefully helped you better understand some of the fundamental concepts of programming. You're now ready to try some new ideas for yourself. Take some time to explore the documentation and try a few more of the Pact built-in functions. Smart contracts you create will depend on you being familiar with these basic ideas. You'll see plenty more examples of these concepts throughout the upcoming tutorials.","title":"Review"},{"location":"beginner/pact-modules/","text":"Pact Modules This tutorial introduces an essential feature in Pact known as modules. We\u2019ll discuss what modules are, why they\u2019re important, and how they relate to smart contracts. Tutorial Overview Introduction to Pact Modules Create a Module Example Modules Key Takeaway A Pact Module contains the logic necessary to create your application. It is where all code is written to for a smart contract. All API and data definitions exist within the Module. Pact Modules Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Introduction to Pact Modules A Pact Module contains the logic necessary to create your application. It is where all code is written to for a smart contract. All API and data definitions exist within the Module. Modules contain the following code Schema Definitions Table Definitions Functions Definitions Pact Special Functions Const Values Modules do not contain the following code While modules contain the code needed to create a smart contract, some things are not included in a module. Keysets Table Creation Function Calls For more information on keysets, see our Pact Keysets Tutorial. Module vs Smart Contract When starting with Pact, you\u2019ll often create single modules that contain the full functionality of your smart contract. This raises an important question... Why aren\u2019t modules called smart contracts? The reason for this becomes clear once you begin creating more complicated smart contracts. These smart contracts will often contain many modules that work together to create your application. The goal of each module should be to create a focused set of functionality and clear organization within your files. While one module can make one smart contract, many modules can also make one smart contract. For that reason, we refer to the logic within a Pact file as a module. For more information see modules in the developer documentation. Create a Module To create a module, you write the module keyword and name followed by the keyset that has access to call this module. Here is a module named example that gives access to an admin-keyset . ;; define and read keysets ( module example admin-keyset ;; module code goes here ) ;; function calls The entire module is written within these parentheses. The top level code, like keysets, are defined outside of these parentheses. The basic idea of modules is simple, but the structure of the code and the actual logic within the module can get pretty complicated. For that reason, it\u2019s helpful to start by focusing on the basic syntax and structure of existing modules. Example Modules You can find examples using the Module Explorer in the Pact Online Editor . Hello World From the Module Explorer, open the Hello World Smart Contract. If you\u2019re interested, this smart contract is explained in depth in the Hello World with Pact . Notice that the pattern of this smart contract is similar to the outline described above. ;; define and read keysets ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module helloWorld admin-keyset ;; module code goes here ( defun hello ( name ) ( format Hello {}! [ name ])) ) ;; function calls ( hello world ) In this case, the module code only contains a simple function named hello . Later modules will include much more complexity. Simple Payment Next, take some time to look through the simple payment module. From the Module Explorer, select open on Simple Payment to open this smart contract in the online editor. Once again, you\u2019ll notice the same pattern. This time, the smart contract includes a few other features. Included in the Simple Payment Smart Contract Schema Definitions Table Definitions Table Creation Functions Function Calls View the summary of this contract below and take some time to investigate the actual code provided in the Simple Payment Module . ;; define and read keysets ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module payments admin-keyset ;; module code goes here ;; define schemas ;; ex. defschema payments... ;; define tables ;; ex. deftable payments-table:{payments}) ;; define functions ;; ex. defun create-account... ;; ex. defun get-balance... ;; ex. defun pay... ) ;; create tables ;; ex. create-table payments-table ;; function calls ;; ex. pay ;; ex. get-balance While you may not fully understand each line of code quite yet, there are a few important things to note here. First, schemas and tables are defined inside of modules, but tables are created outside of modules. Table and schema definitions include built in functions including defschema, deftable, and create-table. You\u2019ll learn more about each of these functions in the Pact Schemas and Tables tutorial . Next, there are some new Pact built in functions that you may have not seen before. Contract Built-in functions include: enforce insert with-read We\u2019ll also go over each of these in more detail in later tutorials. You can explore the Pact Language Reference built-in functions to learn more about each of them now if you\u2019d like. Explore Other Modules Other modules include the same basic framework as those included in these simple smart contracts. Take some time now to explore each of the other Smart Contract examples to get more familiar with how they work. Example Modules International Payment Verification Accounts Focus on understanding the structure of each module. Gain some familiarity with the different techniques used to create each smart contract. Review That wraps up this tutorial on Pact Modules . In this tutorial you were introduced to modules, one of the core features of the Pact Programming Language. You learned what modules are, why they\u2019re important, and went over a few examples. The goal for this tutorial wasn\u2019t to help you learn all of the code that can possibly go into creating a module. That\u2019s what most of the entire Pact programming language is built to accomplish. You\u2019ll learn much more about this in later tutorials. For now, the important takeaway is to understand what a module is, as well as to recognize the key elements that belong inside and outside of Pact modules. Take some time now to continue exploring the examples provided in the Pact Online Editor. When you\u2019re ready, you can learn more about the Pact programming language in our next tutorial.","title":"5. Modules"},{"location":"beginner/pact-modules/#pact-modules","text":"This tutorial introduces an essential feature in Pact known as modules. We\u2019ll discuss what modules are, why they\u2019re important, and how they relate to smart contracts. Tutorial Overview Introduction to Pact Modules Create a Module Example Modules Key Takeaway A Pact Module contains the logic necessary to create your application. It is where all code is written to for a smart contract. All API and data definitions exist within the Module.","title":"Pact Modules"},{"location":"beginner/pact-modules/#pact-modules-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact Modules Tutorial"},{"location":"beginner/pact-modules/#introduction-to-pact-modules","text":"A Pact Module contains the logic necessary to create your application. It is where all code is written to for a smart contract. All API and data definitions exist within the Module. Modules contain the following code Schema Definitions Table Definitions Functions Definitions Pact Special Functions Const Values Modules do not contain the following code While modules contain the code needed to create a smart contract, some things are not included in a module. Keysets Table Creation Function Calls For more information on keysets, see our Pact Keysets Tutorial.","title":"Introduction to Pact Modules"},{"location":"beginner/pact-modules/#module-vs-smart-contract","text":"When starting with Pact, you\u2019ll often create single modules that contain the full functionality of your smart contract. This raises an important question... Why aren\u2019t modules called smart contracts? The reason for this becomes clear once you begin creating more complicated smart contracts. These smart contracts will often contain many modules that work together to create your application. The goal of each module should be to create a focused set of functionality and clear organization within your files. While one module can make one smart contract, many modules can also make one smart contract. For that reason, we refer to the logic within a Pact file as a module. For more information see modules in the developer documentation.","title":"Module vs Smart Contract"},{"location":"beginner/pact-modules/#create-a-module","text":"To create a module, you write the module keyword and name followed by the keyset that has access to call this module. Here is a module named example that gives access to an admin-keyset . ;; define and read keysets ( module example admin-keyset ;; module code goes here ) ;; function calls The entire module is written within these parentheses. The top level code, like keysets, are defined outside of these parentheses. The basic idea of modules is simple, but the structure of the code and the actual logic within the module can get pretty complicated. For that reason, it\u2019s helpful to start by focusing on the basic syntax and structure of existing modules.","title":"Create a Module"},{"location":"beginner/pact-modules/#example-modules","text":"You can find examples using the Module Explorer in the Pact Online Editor .","title":"Example Modules"},{"location":"beginner/pact-modules/#hello-world","text":"From the Module Explorer, open the Hello World Smart Contract. If you\u2019re interested, this smart contract is explained in depth in the Hello World with Pact . Notice that the pattern of this smart contract is similar to the outline described above. ;; define and read keysets ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module helloWorld admin-keyset ;; module code goes here ( defun hello ( name ) ( format Hello {}! [ name ])) ) ;; function calls ( hello world ) In this case, the module code only contains a simple function named hello . Later modules will include much more complexity.","title":"Hello World"},{"location":"beginner/pact-modules/#simple-payment","text":"Next, take some time to look through the simple payment module. From the Module Explorer, select open on Simple Payment to open this smart contract in the online editor. Once again, you\u2019ll notice the same pattern. This time, the smart contract includes a few other features. Included in the Simple Payment Smart Contract Schema Definitions Table Definitions Table Creation Functions Function Calls View the summary of this contract below and take some time to investigate the actual code provided in the Simple Payment Module . ;; define and read keysets ( define-keyset admin-keyset ( read-keyset admin-keyset )) ( module payments admin-keyset ;; module code goes here ;; define schemas ;; ex. defschema payments... ;; define tables ;; ex. deftable payments-table:{payments}) ;; define functions ;; ex. defun create-account... ;; ex. defun get-balance... ;; ex. defun pay... ) ;; create tables ;; ex. create-table payments-table ;; function calls ;; ex. pay ;; ex. get-balance While you may not fully understand each line of code quite yet, there are a few important things to note here. First, schemas and tables are defined inside of modules, but tables are created outside of modules. Table and schema definitions include built in functions including defschema, deftable, and create-table. You\u2019ll learn more about each of these functions in the Pact Schemas and Tables tutorial . Next, there are some new Pact built in functions that you may have not seen before. Contract Built-in functions include: enforce insert with-read We\u2019ll also go over each of these in more detail in later tutorials. You can explore the Pact Language Reference built-in functions to learn more about each of them now if you\u2019d like.","title":"Simple Payment"},{"location":"beginner/pact-modules/#explore-other-modules","text":"Other modules include the same basic framework as those included in these simple smart contracts. Take some time now to explore each of the other Smart Contract examples to get more familiar with how they work. Example Modules International Payment Verification Accounts Focus on understanding the structure of each module. Gain some familiarity with the different techniques used to create each smart contract.","title":"Explore Other Modules"},{"location":"beginner/pact-modules/#review","text":"That wraps up this tutorial on Pact Modules . In this tutorial you were introduced to modules, one of the core features of the Pact Programming Language. You learned what modules are, why they\u2019re important, and went over a few examples. The goal for this tutorial wasn\u2019t to help you learn all of the code that can possibly go into creating a module. That\u2019s what most of the entire Pact programming language is built to accomplish. You\u2019ll learn much more about this in later tutorials. For now, the important takeaway is to understand what a module is, as well as to recognize the key elements that belong inside and outside of Pact modules. Take some time now to continue exploring the examples provided in the Pact Online Editor. When you\u2019re ready, you can learn more about the Pact programming language in our next tutorial.","title":"Review"},{"location":"beginner/pact-on-atom-sdk/","text":"Pact Development on Atom SDK Welcome to this tutorial on Pact Development on Atom SDK! Topics covered in this tutorial Pact in Atom SDK Overview Install Homebrew Install the Pact Programming Language Install Atom Install the Atom language-pact package Run Code Locally The goal of this tutorial is to get you up and running with the Pact environment and the Pact Atom SDK to begin running Pact programs locally. Key Takeaway Pact and the Atom SDK provide a powerful development environment that allows you to run Pact programs locally. Pact Development on Atom SDK Tutorial Getting started with Pact on your local device allows you to work in a powerful development environment to run your smart contracts locally. This environment can be set up on Mac, Windows, and Linux operating systems. This tutorial will go over the details of getting up and running on a Mac operating system. Windows and Linux Users More instructions on installing Pact with Windows or Linux can be found on the GitHub page. Install Pact To get started with Pact you\u2019ll first need to install the Pact programming language. The easiest way to do this is by using Homebrew for Mac. If you have Homebrew, run the following line in your terminal. brew install kadena-io/pact/pact This will install Pact on your computer. Homebrew If you don\u2019t have Homebrew, you\u2019ll need to get that first. To find instructions for this go to brew.sh . This is a popular package manager used to install many packages for Mac. If you\u2019re just getting started with it I\u2019m sure you\u2019ll also find it valuable in the future. To install Homebrew, copy the command provided on the center of the screen and run it in your terminal window. After a few moments you\u2019ll have Homebrew installed on your computer. To verify your installation type brew --version . This should return the current version of your installation. Pact Programming Langauge Now that you have Homebrew, you can use it to install the Pact language. As I mentioned earlier, you\u2019ll do this with the following command. brew install kadena-io/pact/pact To check the installation go to your terminal and type Pact. This should open up the Pact environment. You can run any commands available in Pact from this environment. For example, typing ( + 1 2 ) will add these 2 numbers and return a value of 3. You can find other commands in the documentation and we\u2019ll go over many of these throughout other tutorials. Atom SDK The terminal is helpful, but you\u2019ll often want to create larger programs from within your editor. The best way to write smart contracts locally is by using the Atom editor. Pact provides Atom integration giving you syntax highlighting, continuous integration with a directory, .repl scripts, and errors/warnings linting. To install the Atom editor, navigate to atom.io and select download . From there, follow the installation instructions to get up and running with Atom. Language-pact Package To install the language-pact package, open Atom , go to Atom in the menu and select preferences . From within preferences select packages and type language-pact . Once you do this you should see the package appear. Click install to install this package. At this point Atom is set up to run the Pact programming language. Language-pact Package To install the language-pact package, open Atom, go to Atom in the menu and select preferences. From within preferences select packages and type language-pact. Once you do this you should see the package appear. Click install to install this package. At this point Atom is set up to run the Pact programming language. Hello World from your Local Environment Before wrapping up, try running your first Hello World smart contract in Atom. To do this, open your terminal and navigate into whichever folder you would like as a project directory. cd Desktop Next, clone the pact examples GitHub repository found here . git clone https://github.com/kadena-io/pact-examples This clones a directory with many Pact examples. For now, navigate to the Hello World example. cd pact-examples/hello-world From within this folder, open the Pact terminal. pact pact Using the Pact terminal, run the hello-world.repl file. (load hello-world.repl ) Note The .repl file loads the smart contract from the .pact file to run the code. This file contains the code behind the Load into REPL feature that has so far been available automatically from the online editor allowing you to run code locally. The contents of this .repl file are explained in more detail in the next tutorial. After running this file, you should see the following output to your terminal. Loading hello-world.repl... Setting transaction data Setting transaction keys Loading hello-world.pact... Keyset defined Loaded module \\ hello\\ , hash \\ a493bb7d096c786891bde5d2125c5acbdcd769ba68c50d38691d173b3b7c03ee85cfcde2db34afb0c6c20c5cde3433ab129829ae4283ed789bd7a9d40837fe88\\ TableCreated Write succeeded Hello, world! Hello, world! Receiving this message means that you have run the code correctly! You can check the contents of this smart contract by opening it in Atom. First, exit the Pact terminal (or open a new terminal in this directory) Press Control + D to exit the Pact terminal. Enter atom . to open the directory in Atom. Look through the code provided to better understand the contents of this smart contract. It is slightly different than the hello world smart contract you had seen previously in the online editor. As you\u2019ll see, it stores the value in a table and then returns that value using some of the Pact built-in functions you learned in previous tutorials. Review That wraps up this tutorial. The goal of this tutorial was to get you up and running with Pact on the Atom SDK. In this tutorial, you got started with Pact locally. You installed Homebrew, Atom, the language-pact package, and the Pact language. You also ran your first hello-world Pact program on your local computer. Depending on your needs, you can now use both the online editor and the Atom editor to create Pact programs.","title":"8. Atom SDK"},{"location":"beginner/pact-on-atom-sdk/#pact-development-on-atom-sdk","text":"Welcome to this tutorial on Pact Development on Atom SDK! Topics covered in this tutorial Pact in Atom SDK Overview Install Homebrew Install the Pact Programming Language Install Atom Install the Atom language-pact package Run Code Locally The goal of this tutorial is to get you up and running with the Pact environment and the Pact Atom SDK to begin running Pact programs locally. Key Takeaway Pact and the Atom SDK provide a powerful development environment that allows you to run Pact programs locally.","title":"Pact Development on Atom SDK"},{"location":"beginner/pact-on-atom-sdk/#pact-development-on-atom-sdk-tutorial","text":"Getting started with Pact on your local device allows you to work in a powerful development environment to run your smart contracts locally. This environment can be set up on Mac, Windows, and Linux operating systems. This tutorial will go over the details of getting up and running on a Mac operating system. Windows and Linux Users More instructions on installing Pact with Windows or Linux can be found on the GitHub page.","title":"Pact Development on Atom SDK Tutorial"},{"location":"beginner/pact-on-atom-sdk/#install-pact","text":"To get started with Pact you\u2019ll first need to install the Pact programming language. The easiest way to do this is by using Homebrew for Mac. If you have Homebrew, run the following line in your terminal. brew install kadena-io/pact/pact This will install Pact on your computer.","title":"Install Pact"},{"location":"beginner/pact-on-atom-sdk/#homebrew","text":"If you don\u2019t have Homebrew, you\u2019ll need to get that first. To find instructions for this go to brew.sh . This is a popular package manager used to install many packages for Mac. If you\u2019re just getting started with it I\u2019m sure you\u2019ll also find it valuable in the future. To install Homebrew, copy the command provided on the center of the screen and run it in your terminal window. After a few moments you\u2019ll have Homebrew installed on your computer. To verify your installation type brew --version . This should return the current version of your installation.","title":"Homebrew"},{"location":"beginner/pact-on-atom-sdk/#pact-programming-langauge","text":"Now that you have Homebrew, you can use it to install the Pact language. As I mentioned earlier, you\u2019ll do this with the following command. brew install kadena-io/pact/pact To check the installation go to your terminal and type Pact. This should open up the Pact environment. You can run any commands available in Pact from this environment. For example, typing ( + 1 2 ) will add these 2 numbers and return a value of 3. You can find other commands in the documentation and we\u2019ll go over many of these throughout other tutorials.","title":"Pact Programming Langauge"},{"location":"beginner/pact-on-atom-sdk/#atom-sdk","text":"The terminal is helpful, but you\u2019ll often want to create larger programs from within your editor. The best way to write smart contracts locally is by using the Atom editor. Pact provides Atom integration giving you syntax highlighting, continuous integration with a directory, .repl scripts, and errors/warnings linting. To install the Atom editor, navigate to atom.io and select download . From there, follow the installation instructions to get up and running with Atom.","title":"Atom SDK"},{"location":"beginner/pact-on-atom-sdk/#language-pact-package","text":"To install the language-pact package, open Atom , go to Atom in the menu and select preferences . From within preferences select packages and type language-pact . Once you do this you should see the package appear. Click install to install this package. At this point Atom is set up to run the Pact programming language.","title":"Language-pact Package"},{"location":"beginner/pact-on-atom-sdk/#language-pact-package_1","text":"To install the language-pact package, open Atom, go to Atom in the menu and select preferences. From within preferences select packages and type language-pact. Once you do this you should see the package appear. Click install to install this package. At this point Atom is set up to run the Pact programming language.","title":"Language-pact Package"},{"location":"beginner/pact-on-atom-sdk/#hello-world-from-your-local-environment","text":"Before wrapping up, try running your first Hello World smart contract in Atom. To do this, open your terminal and navigate into whichever folder you would like as a project directory. cd Desktop Next, clone the pact examples GitHub repository found here . git clone https://github.com/kadena-io/pact-examples This clones a directory with many Pact examples. For now, navigate to the Hello World example. cd pact-examples/hello-world From within this folder, open the Pact terminal. pact pact Using the Pact terminal, run the hello-world.repl file. (load hello-world.repl ) Note The .repl file loads the smart contract from the .pact file to run the code. This file contains the code behind the Load into REPL feature that has so far been available automatically from the online editor allowing you to run code locally. The contents of this .repl file are explained in more detail in the next tutorial. After running this file, you should see the following output to your terminal. Loading hello-world.repl... Setting transaction data Setting transaction keys Loading hello-world.pact... Keyset defined Loaded module \\ hello\\ , hash \\ a493bb7d096c786891bde5d2125c5acbdcd769ba68c50d38691d173b3b7c03ee85cfcde2db34afb0c6c20c5cde3433ab129829ae4283ed789bd7a9d40837fe88\\ TableCreated Write succeeded Hello, world! Hello, world! Receiving this message means that you have run the code correctly! You can check the contents of this smart contract by opening it in Atom. First, exit the Pact terminal (or open a new terminal in this directory) Press Control + D to exit the Pact terminal. Enter atom . to open the directory in Atom. Look through the code provided to better understand the contents of this smart contract. It is slightly different than the hello world smart contract you had seen previously in the online editor. As you\u2019ll see, it stores the value in a table and then returns that value using some of the Pact built-in functions you learned in previous tutorials.","title":"Hello World from your Local Environment"},{"location":"beginner/pact-on-atom-sdk/#review","text":"That wraps up this tutorial. The goal of this tutorial was to get you up and running with Pact on the Atom SDK. In this tutorial, you got started with Pact locally. You installed Homebrew, Atom, the language-pact package, and the Pact language. You also ran your first hello-world Pact program on your local computer. Depending on your needs, you can now use both the online editor and the Atom editor to create Pact programs.","title":"Review"},{"location":"beginner/pact-schemas-and-tables/","text":"Pact Schemas and Tables Welcome to this introduction to Pact Schemas and Tables! Topics covered in this tutorial Introduction to Schemas and Tables Define Schemas Define Tables Create Tables Table built-in functions The goal of this tutorial is to get you familiar with what schemas and tables are, why they\u2019re useful, and to demonstrate how to implement these within a Pact smart contract. Key Takeaway Tables are one of the three core elements of Pact smart contracts. Tables are defined using deftable , which references a schema defined by defschema , and are later created using create-table . There are many ways to build functions that store, manipulate, and read data from smart contract tables. Pact Schemas and Tables Subscribe to our YouTube channel to access the latest Pact tutorials. Introduction to Tables and Schemas Tables in Pact are responsible for holding all of the data for application. Data is stored in a key-row structure similar to other relational databases. Tables are defined by schemas that define both the field values and field types. Before completing this tutorial, it may be helpful to read through some of the existing materials on schemas, types, and tables. This material includes some of the prerequisites needed to understand the conceptual foundations behind what tables are and how they provide value to your Pact smart contracts. Pact Language Reference Table Creation Types and Schemas Define Schemas Before creating a table in Pact, you need to define its schema, which describes the structure of the table. Schemas specify the columns and data types that are meant to be in a table. Schemas are defined within Pact modules using defschema and consist of a series of field names and field types . Each field name specifies a column in the table, and each field type specifies the type of data held in that table. The example table below contains field names and field types. In this example, there are 3 fields; balance , amount , and ccy (currency), each with their own field type. Accounts Table field name field type balance decimal amount decimal ccy string You can create this schema in Pact using defschema as shown below. ( defschema accounts Schema for accounts table. balance :decimal amount :decimal ccy :string ) All table schemas you create will look similar to this but will contain different field names and types. Field names can include whatever works best for your application, and fields types can include any of the types supported by Pact. Note The data types supported by Pact can be found here . Define Tables Tables hold data created by the smart contract. These are defined within Pact modules and there is no limit to the number of tables you can define. This data can be added, read, or changed using functions, and access to this data can be restricted using what is known as table guards . Tables are defined after the prerequisite schema is defined, using deftable followed by the table name and a reference to the table\u2019s schema. Accounts Example ( deftable table-name : { schema-name }) Given the schema from the earlier defined schema, you can define the table as shown below. ( deftable accounts-table : { accounts }) Notes on Syntax Notice that the table and schema are represented as a pair, separated by a \u201c:\u201d. The { } around the schema-name are there because the schema is an object. The schema name and table names must be different from one another. It\u2019s best practice to make names that resemble each other but are not identical. ( deftable cat-table : { cat }) ( deftable asset-tracker : { asset }) Keeping names similar helps you track your schemas and tables more effectively while avoiding confusion between their names. Create Tables Once tables are defined, they still need to be created. Though tables are defined within the module, creating tables in Pact is done outside of the module. This is done to ensure that the module may be redefined or updated later without having to re-create the table. The relationship of modules to tables is important, as described in table guards Tables are created outside of the module using create-table followed by the table name as defined within the module. ( deftable cat-table : { cat }) ( deftable asset-tracker : { asset }) This syntax for creating tables is simple. The main concern here is to make sure that you follow through with creating each of the tables that are defined within the module. Table Built-in Functions When working with tables, there are many built-in functions available for you to work with table data. function type purpose Insert Insert new rows into a table. Read Read values from a table. Update Update values within a table. Delete Not possible in Pact. Notice that these functions are similar to common options available in other databases (CRUD - create, read, update, delete). Note Delete is not available because, as you may know, you cannot delete data from a blockchain. Also, rather than create, the Pact built-in function is named insert. Insert Insert functions are used to add new data into a table. These are useful when creating new artifacts such as entities, loans, accounts, and in any other case where you may want to add data. For an example of an insert function, pretend you have the following empty table. entity-table key entityName To add a row to this table with an entityName of \u201cMy Entity\u201d at the key of entity-1 , you would write the following Pact code. ( insert entity-table \u201c entity-1 \u201d { entityName : My Entity }) Note It is required that the key be entered as a string. You can also place insert within a function and using the inputs to add new data to rows within a table. This will help you add rows more dynamically from within your application. Here is an example using insert from within a function. ( defun create-entity ( entityName ) ( insert entity-table entityId { entityName : entityName } ) ) In each of the previous cases, the final result would insert the data similar to the following into the entity-table . key entityName entity-1 My Entity Read Read allows you to read rows from a table for a given key. For this example, imagine you had the following table and you wanted to read the balance and currency at the key of entity-1 . Accounts Table key balance ccy account-1 4.00 USD account-2 3.00 USD Using read, you can specify the id and you\u2019ll get back the information you request. ( read accounts account-1 [ balance ccy ]) Here is an example of how to get similar functionality by using read from within a function. ( defun read-accounts ( 1 ) ( read accounts id [ \u2018 balance \u2018 ccy ]) ) ) In each of the cases shown above, the functions would return the following values. balance ccy 4.00 USD Update Update functions can be used to update a values in an existing row of a table. Updating is helpful in situations where you need to change the status of a column or amend the initial dataset to a new value. Using update , you can specify the row id to update a value within that row. This value would generally be passed in by the user as a function parameter. ( update table-name id { value : new-value } For example, pretend you had the following table and wanted to update the assetPrice . Assets Table key assetName assetPrice status entity-1 My Asset 5.0 todo The amend-assetPrice function below updates the assetId column of an assets-table . It then reads the value of the updated column. ( defun amend-assetPrice ( assetPrice :decimal ) ( update assets-table assetPrice { assetPrice :assetPrice } ) ( read asset-table assetId ) ) This same pattern can be used in many different ways. For example, you may be creating an asset and want to track its progress throughout the creation process with fields like todo, in progress, or done. In this case, you could use the function below asset-update , to change the status of the asset as it progresses through the process. ( defun asset-update ( assetId :string new-status :string ) ( update assets-table assetId { status : new-status }) ( read asset-table assetId ) ) Select Select is used to read values from a table. This is similar to read but select includes more specificity allowing you greater flexibility in what information you choose to select. The syntax for selecting from tables closely resembles SQL statements. The simplest select statement you can create would be to select all values of an existing table. ( select table-name ) Similar to other built-in functions, you can run this from within another function. For example, here is the assets-table from earlier. Assets Table key assetName assetPrice status entity-1 My Asset 5.0 todo entity-2 Asset 2 6.0 in progress entity-3 Asset 3 7.0 done You can run the following select statement to return all values from this table. ( defun select-assets () ( select assets-table ( constantly true )) ) This query will return the following values from the assets-table . key assetName assetPrice status entity-1 My Asset 5.0 todo entity-2 Asset 2 6.0 in progress entity-3 Asset 3 7.0 done Along with select, you can also use a where statement to further refine your query as shown below. ( select assets-table [ assetName , assetPrice ] ( where assetName ( = Asset 2 ))) This query would return the following values from the assets-table . assetName assetPrice Asset 2 6.0 You can also specify operators such as greater than or less than from within the WHERE clause as shown below. ( select assets-table ( where assetPrice ( 6.0 ))) This query would return the following values from the assets-table . key assetName assetPrice status entity-3 Asset 3 7.0 done Keys Keys allows you to return all the key values in a table. Given the previously shown assets-table , you could return each of the keys using the code below. ( keys assets-table ) This can also be done within a function as shown below. ( defun get-keys ( table-name ) ( keys table-name ) ) Review That wraps up this tutorial on schemas and tables with Pact. By completing this tutorial, you\u2019ve mastered many of the core ideas surrounding schemas and tables. You\u2019ve also seen some of the basic functions that are useful for manipulating data from within a table. You can try building out your own database from scratch or by using existing database examples to work from. An excellent resource for finding existing schemas for well designed databases can be found here . If you\u2019re unfamiliar with database design, you can review most of what you need to know here . That website goes into a lots of detail, so if you\u2019d like to focus more on specifically what might be useful to you right now, you can find that here . Try finding a database you\u2019re interested in to practice recreating some of its functionality. And if you\u2019re not quite ready to try that, you can check out the next tutorial instead. You\u2019ll see many more examples of tables, schemas, and their related functions throughout the rest of this series.","title":"7. Schemas and Tables"},{"location":"beginner/pact-schemas-and-tables/#pact-schemas-and-tables","text":"Welcome to this introduction to Pact Schemas and Tables! Topics covered in this tutorial Introduction to Schemas and Tables Define Schemas Define Tables Create Tables Table built-in functions The goal of this tutorial is to get you familiar with what schemas and tables are, why they\u2019re useful, and to demonstrate how to implement these within a Pact smart contract. Key Takeaway Tables are one of the three core elements of Pact smart contracts. Tables are defined using deftable , which references a schema defined by defschema , and are later created using create-table . There are many ways to build functions that store, manipulate, and read data from smart contract tables.","title":"Pact Schemas and Tables"},{"location":"beginner/pact-schemas-and-tables/#pact-schemas-and-tables_1","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact Schemas and Tables"},{"location":"beginner/pact-schemas-and-tables/#introduction-to-tables-and-schemas","text":"Tables in Pact are responsible for holding all of the data for application. Data is stored in a key-row structure similar to other relational databases. Tables are defined by schemas that define both the field values and field types. Before completing this tutorial, it may be helpful to read through some of the existing materials on schemas, types, and tables. This material includes some of the prerequisites needed to understand the conceptual foundations behind what tables are and how they provide value to your Pact smart contracts. Pact Language Reference Table Creation Types and Schemas","title":"Introduction to Tables and Schemas"},{"location":"beginner/pact-schemas-and-tables/#define-schemas","text":"Before creating a table in Pact, you need to define its schema, which describes the structure of the table. Schemas specify the columns and data types that are meant to be in a table. Schemas are defined within Pact modules using defschema and consist of a series of field names and field types . Each field name specifies a column in the table, and each field type specifies the type of data held in that table. The example table below contains field names and field types. In this example, there are 3 fields; balance , amount , and ccy (currency), each with their own field type. Accounts Table field name field type balance decimal amount decimal ccy string You can create this schema in Pact using defschema as shown below. ( defschema accounts Schema for accounts table. balance :decimal amount :decimal ccy :string ) All table schemas you create will look similar to this but will contain different field names and types. Field names can include whatever works best for your application, and fields types can include any of the types supported by Pact. Note The data types supported by Pact can be found here .","title":"Define Schemas"},{"location":"beginner/pact-schemas-and-tables/#define-tables","text":"Tables hold data created by the smart contract. These are defined within Pact modules and there is no limit to the number of tables you can define. This data can be added, read, or changed using functions, and access to this data can be restricted using what is known as table guards . Tables are defined after the prerequisite schema is defined, using deftable followed by the table name and a reference to the table\u2019s schema. Accounts Example ( deftable table-name : { schema-name }) Given the schema from the earlier defined schema, you can define the table as shown below. ( deftable accounts-table : { accounts }) Notes on Syntax Notice that the table and schema are represented as a pair, separated by a \u201c:\u201d. The { } around the schema-name are there because the schema is an object. The schema name and table names must be different from one another. It\u2019s best practice to make names that resemble each other but are not identical. ( deftable cat-table : { cat }) ( deftable asset-tracker : { asset }) Keeping names similar helps you track your schemas and tables more effectively while avoiding confusion between their names.","title":"Define Tables"},{"location":"beginner/pact-schemas-and-tables/#create-tables","text":"Once tables are defined, they still need to be created. Though tables are defined within the module, creating tables in Pact is done outside of the module. This is done to ensure that the module may be redefined or updated later without having to re-create the table. The relationship of modules to tables is important, as described in table guards Tables are created outside of the module using create-table followed by the table name as defined within the module. ( deftable cat-table : { cat }) ( deftable asset-tracker : { asset }) This syntax for creating tables is simple. The main concern here is to make sure that you follow through with creating each of the tables that are defined within the module.","title":"Create Tables"},{"location":"beginner/pact-schemas-and-tables/#table-built-in-functions","text":"When working with tables, there are many built-in functions available for you to work with table data. function type purpose Insert Insert new rows into a table. Read Read values from a table. Update Update values within a table. Delete Not possible in Pact. Notice that these functions are similar to common options available in other databases (CRUD - create, read, update, delete). Note Delete is not available because, as you may know, you cannot delete data from a blockchain. Also, rather than create, the Pact built-in function is named insert.","title":"Table Built-in Functions"},{"location":"beginner/pact-schemas-and-tables/#insert","text":"Insert functions are used to add new data into a table. These are useful when creating new artifacts such as entities, loans, accounts, and in any other case where you may want to add data. For an example of an insert function, pretend you have the following empty table. entity-table key entityName To add a row to this table with an entityName of \u201cMy Entity\u201d at the key of entity-1 , you would write the following Pact code. ( insert entity-table \u201c entity-1 \u201d { entityName : My Entity }) Note It is required that the key be entered as a string. You can also place insert within a function and using the inputs to add new data to rows within a table. This will help you add rows more dynamically from within your application. Here is an example using insert from within a function. ( defun create-entity ( entityName ) ( insert entity-table entityId { entityName : entityName } ) ) In each of the previous cases, the final result would insert the data similar to the following into the entity-table . key entityName entity-1 My Entity","title":"Insert"},{"location":"beginner/pact-schemas-and-tables/#read","text":"Read allows you to read rows from a table for a given key. For this example, imagine you had the following table and you wanted to read the balance and currency at the key of entity-1 . Accounts Table key balance ccy account-1 4.00 USD account-2 3.00 USD Using read, you can specify the id and you\u2019ll get back the information you request. ( read accounts account-1 [ balance ccy ]) Here is an example of how to get similar functionality by using read from within a function. ( defun read-accounts ( 1 ) ( read accounts id [ \u2018 balance \u2018 ccy ]) ) ) In each of the cases shown above, the functions would return the following values. balance ccy 4.00 USD","title":"Read"},{"location":"beginner/pact-schemas-and-tables/#update","text":"Update functions can be used to update a values in an existing row of a table. Updating is helpful in situations where you need to change the status of a column or amend the initial dataset to a new value. Using update , you can specify the row id to update a value within that row. This value would generally be passed in by the user as a function parameter. ( update table-name id { value : new-value } For example, pretend you had the following table and wanted to update the assetPrice . Assets Table key assetName assetPrice status entity-1 My Asset 5.0 todo The amend-assetPrice function below updates the assetId column of an assets-table . It then reads the value of the updated column. ( defun amend-assetPrice ( assetPrice :decimal ) ( update assets-table assetPrice { assetPrice :assetPrice } ) ( read asset-table assetId ) ) This same pattern can be used in many different ways. For example, you may be creating an asset and want to track its progress throughout the creation process with fields like todo, in progress, or done. In this case, you could use the function below asset-update , to change the status of the asset as it progresses through the process. ( defun asset-update ( assetId :string new-status :string ) ( update assets-table assetId { status : new-status }) ( read asset-table assetId ) )","title":"Update"},{"location":"beginner/pact-schemas-and-tables/#select","text":"Select is used to read values from a table. This is similar to read but select includes more specificity allowing you greater flexibility in what information you choose to select. The syntax for selecting from tables closely resembles SQL statements. The simplest select statement you can create would be to select all values of an existing table. ( select table-name ) Similar to other built-in functions, you can run this from within another function. For example, here is the assets-table from earlier. Assets Table key assetName assetPrice status entity-1 My Asset 5.0 todo entity-2 Asset 2 6.0 in progress entity-3 Asset 3 7.0 done You can run the following select statement to return all values from this table. ( defun select-assets () ( select assets-table ( constantly true )) ) This query will return the following values from the assets-table . key assetName assetPrice status entity-1 My Asset 5.0 todo entity-2 Asset 2 6.0 in progress entity-3 Asset 3 7.0 done Along with select, you can also use a where statement to further refine your query as shown below. ( select assets-table [ assetName , assetPrice ] ( where assetName ( = Asset 2 ))) This query would return the following values from the assets-table . assetName assetPrice Asset 2 6.0 You can also specify operators such as greater than or less than from within the WHERE clause as shown below. ( select assets-table ( where assetPrice ( 6.0 ))) This query would return the following values from the assets-table . key assetName assetPrice status entity-3 Asset 3 7.0 done","title":"Select"},{"location":"beginner/pact-schemas-and-tables/#keys","text":"Keys allows you to return all the key values in a table. Given the previously shown assets-table , you could return each of the keys using the code below. ( keys assets-table ) This can also be done within a function as shown below. ( defun get-keys ( table-name ) ( keys table-name ) )","title":"Keys"},{"location":"beginner/pact-schemas-and-tables/#review","text":"That wraps up this tutorial on schemas and tables with Pact. By completing this tutorial, you\u2019ve mastered many of the core ideas surrounding schemas and tables. You\u2019ve also seen some of the basic functions that are useful for manipulating data from within a table. You can try building out your own database from scratch or by using existing database examples to work from. An excellent resource for finding existing schemas for well designed databases can be found here . If you\u2019re unfamiliar with database design, you can review most of what you need to know here . That website goes into a lots of detail, so if you\u2019d like to focus more on specifically what might be useful to you right now, you can find that here . Try finding a database you\u2019re interested in to practice recreating some of its functionality. And if you\u2019re not quite ready to try that, you can check out the next tutorial instead. You\u2019ll see many more examples of tables, schemas, and their related functions throughout the rest of this series.","title":"Review"},{"location":"beginner/project-loans/","text":"Pact Loans App Welcome to the Loans app project tutorial! In this tutorial, you will build an example loans application using many of the techniques you learned in earlier tutorials Topics covered in this tutorial Loans Smart Contract Module and Keyset Define Schemas Define Tables Define Consts Define Functions Create Tables Deploy Smart Contract The goal of this tutorial is to ensure you understand the building blocks of Pact applications, eventually navigating you toward building more complex applications. It\u2019s also meant to push you toward solving problems that you may not have seen before to build valuable new applications. Key Takeaway Loan creation and management is an excellent use case of Pact smart contracts. By combining what you know about modules, schemas, tables, and functions in new ways, you can already build useful and simple applications for complex problems. Loans Smart Contract Throughout this tutorial, you\u2019ll get hands on and build a smart contract used to create, distribute, and manage loans. This smart contract uses schemas and tables pretty extensively and will give you great experience setting up tables as well as writing many different functions that can be used to create and manipulate data within these tables. A brief overview of each feature you\u2019ll build is provided below. As you can see, there are many different tables, const values, and functions meant to help provide a range of functionality for your users. Note There is a lot of code in this application, and it will force you to think more proactively about how to solve each problem than earlier tutorials had done. If you get stuck, try using all of the resources provided, and look to the solution for further guidance if needed. When you\u2019re ready, continue to the next section to start building your Loans smart contract! Project Environment Setup To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the loans directory to begin working on this project. cd pact-lang.org-code/loans Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like to. 1. Module and Keyset The first step is to create the module and keysets for your smart contract. Code Challenge Create a keyset named loans-admin-keyset and a module named loans that specifies access to this keyset. Challenge Solution Note If you\u2019re unfamiliar with modules and keyset, our Pact Modules Tutorial is a great place to get started. 2. Define Schemas The first step to build your module is to create the schema definitions for each table. The loans smart contract will consist of 3 tables as shown below. For this challenge, you\u2019ll see each table presented as fields and types. Your goal is to create the schema definition for each of these tables. Note Schema definitions are introduced in the Pact Schemas and Tables Tutorial . 2.1 Loan Schema The loan table will be used to hold loan entries. loan table fieldname fieldtype loanName string entityName string loanAmount integer status string Code Challenge Take some time now to define the schema for the loan table. Challenge Solution 2.2 Loan History Schema The loan-history table will be used to track the loan\u2019s histories. It includes each of the field names and field types shown below. loan-history table fieldname fieldtype loanId string buyer string seller string amount integer Code Challenge Take some time now to define the schema for the loan-history table. Challenge Solution 2.3 Loan Inventory Schema The loan-inventory table will be used to hold inventory balance. loan-inventory table fieldname fieldtype balance integer Code Challenge Take some time now to define the schema for the loan-inventory table. Challenge Solution 3. Define Tables Having defined each of the schemas for each table in your smart contract, you are now ready to define the tables. Code Challenge Take some time now to define each of the tables for the loans smart contract. Challenge Solution Note Table definitions are covered in the Pact Schemas and Tables Tutorial . 4. Define Consts The loans smart contract contains a few const values that will be used to pass values into functions and tables. The purpose of each of these constants will be more clear as you begin integrating them into functionality of your contract using functions. For now, complete the challenge to define the constants within your smart contract. Code Challenge Take some time now to define each of the const values INITIATED and ASSIGNED in the loans smart contract. Challenge Solution Note Constant definitions are covered in the documentation here . 5. Functions When working with tables, there are four useful types of functions that you\u2019ll be using in your smart contract. type purpose Utility Functions Perform routine operations callable by other functions. Insert Functions Insert new rows into a table. Update Functions Update values within a table. Read Functions Read values from a table. The functions you\u2019ll create in the loans smart contract will use combinations of these built in functions to insert, update, and read data from the tables in your smart contract. Note You can review each of these function types in the Pact Schemas and Tables Tutorial . Utility Functions Your first function will be a utility function meant to help combine the parameters into an inventory key. 5.1 Inventory-key Code Challenge Create a function named inventory-key that creates a key from the owner and loanId in the format \u201cloanId:owner\u201d . Challenge Solution The reason for starting with this function is so that you can use it as a tool as you progress through other functions in the smart contract. Hint Try using the format function to combine inputs into a string. Insert and Update Functions The following 3 functions use a combination of read, insert, and update to add and update data in each of the tables you created. These functions will allow your users to accomplish important tasks like creating a loan, assigning a loan, and selling a loan. 5.2 Create-a-loan First, you\u2019ll need to create a function to create a loan. Creating a loan can be done by populating specific columns with the appropriate loan data. Take a look at the tables below to see each of the columns that you will insert data into. loans-table column-name value loanName loanName entityName entityName loanAmount loanAmount Status INITIATED loan-inventory-table column-name value balance loanAmount Code Challenge Given these requirements, construct a function named create-a-loan that accepts parameters loanId , loanName , entityName , and loanAmount to add the appropriate information to each table. Challenge Solution 5.3 Assign-a-loan Now that you can create a loan, it is important to be able to assign that loan to a specific entity when needed. To do that, you will both collect data from inputs and read existing data from tables. Using the combination of this data, you can then assign a loan and update the appropriate data. For the loans-table , you will need to both read and update data using the correct built-in functions. loans-table column function source \u201centityName\u201d:= entityName read loans-table \u201cloanAmount\u201d:= issuerBalance read loans-table \u201cstatus\u201d: ASSIGNED update loanId For the loan-history-table, you will need to insert data from inputs and data that is read from other tables. loan-history-table column function source \u201cloanId\u201d: loanId insert input \u201cbuyer\u201d: buyer insert input \u201cseller\u201d: entityName insert loans-table \u201camount\u201d: amount insert input The loan-inventory-table will have new data added and updated as needed. loan-inventory-table column function source \u201cbalance\u201d: amount insert inventory-key \u201cbalance\u201d: (- issuerBalance amount) update inventory-key Code Challenge This code challenge is complex, so take your time and don\u2019t worry if you get stuck. Follow each line as shown and try to construct the functionality needed to assign-a-loan . Challenge Solution Hint Break up the needs of each table into separate functions. This will help you read, insert, and update data in the appropriate order. 5.4 Sell-a-loan The goal of the next function is similar to allow users to sell a loan. This function create a new row in the loan-history-table. This time, there is no table provided to help guide you. Try creating one for yourself if it is useful or follow the comments to complete the challenge. Code Challenge This is another difficult problem. Take your time and leverage what you learned in the previous section to help create this function. Challenge Solution Hint Consult the documentation and Schema and Tables tutorial for guidance on built-in functions like bind, insert, with-read, and others. Read Functions The next set of functions will allow you to read important information from the tables you created. These functions are much shorter than previous functions and the comments within the challenge files are hopefully enough to get you started. 5.5 read-a-loan Code Challenge Create a function named read-a-loan that returns the values at a given loanId. Challenge Solution 5.6 read-loan-tx Code Challenge Create a function named read-loan-tx that reads loan txids. Challenge Solution 5.7 read-all-loans Code Challenge Create a function named read-all-loans that selects all values from the loans table. Challenge Solution 5.8 read-inventory-pair Code Challenge Create a function named read-inventory-pair that reads the balance of a given key. Challenge Solution 5.9 read-loan-inventory Code Challenge Create a function named read-loan-inventory that reads the loan-inventory-table. Challenge Solution 5.10 read-loans-with-status Code Challenge Create a function named read-loans-with-status that reads all loans with a specific status. Challenge Solution 6. Create Tables Earlier in the smart contract, you defined 3 schemas and tables. Now that the module is complete, you are ready to move outside of the module to create each of these tables. Code Challenge Take some time now to create each of the tables for the loans smart contract. Challenge Solution Note Table creation is covered in the Tables and Schemas tutorial . Deploy the Smart Contract Congratulations, at this point you have completed the Loans smart contract! If you\u2019d like, you can try deploying this smart contract. You can deploy this contract using the Pact Onine Editor or from the Pact Atom SDK . If you choose to deploy this locally, you\u2019ll need the REPL file which you can find inside of the repository you cloned. For help getting started and deploying in each of these environments, try the following tutorials. Pact Online Editor Pact Development on Atom SDK Tutorial Review That wraps up this tutorial on the Loans app. By completing this tutorial, you\u2019ve mastered many of the core ideas surrounding modules, schemas, tables, and functions, to tackle unfamiliar problems in new ways. Not only that, you\u2019ve put each of these ideas into practice to create a smart contract that solves a very complex real world problem. The same ideas you learned here can be applied to many other industries. Having the ability to create tables and manipulate data to create useful applications encompasses everything it means to build the back end of a blockchain application using Pact.","title":"12. Project: Loans"},{"location":"beginner/project-loans/#pact-loans-app","text":"Welcome to the Loans app project tutorial! In this tutorial, you will build an example loans application using many of the techniques you learned in earlier tutorials Topics covered in this tutorial Loans Smart Contract Module and Keyset Define Schemas Define Tables Define Consts Define Functions Create Tables Deploy Smart Contract The goal of this tutorial is to ensure you understand the building blocks of Pact applications, eventually navigating you toward building more complex applications. It\u2019s also meant to push you toward solving problems that you may not have seen before to build valuable new applications. Key Takeaway Loan creation and management is an excellent use case of Pact smart contracts. By combining what you know about modules, schemas, tables, and functions in new ways, you can already build useful and simple applications for complex problems.","title":"Pact Loans App"},{"location":"beginner/project-loans/#loans-smart-contract","text":"Throughout this tutorial, you\u2019ll get hands on and build a smart contract used to create, distribute, and manage loans. This smart contract uses schemas and tables pretty extensively and will give you great experience setting up tables as well as writing many different functions that can be used to create and manipulate data within these tables. A brief overview of each feature you\u2019ll build is provided below. As you can see, there are many different tables, const values, and functions meant to help provide a range of functionality for your users. Note There is a lot of code in this application, and it will force you to think more proactively about how to solve each problem than earlier tutorials had done. If you get stuck, try using all of the resources provided, and look to the solution for further guidance if needed. When you\u2019re ready, continue to the next section to start building your Loans smart contract!","title":"Loans Smart Contract"},{"location":"beginner/project-loans/#project-environment-setup","text":"To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the loans directory to begin working on this project. cd pact-lang.org-code/loans Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like to.","title":"Project Environment Setup"},{"location":"beginner/project-loans/#1-module-and-keyset","text":"The first step is to create the module and keysets for your smart contract. Code Challenge Create a keyset named loans-admin-keyset and a module named loans that specifies access to this keyset. Challenge Solution Note If you\u2019re unfamiliar with modules and keyset, our Pact Modules Tutorial is a great place to get started.","title":"1. Module and Keyset"},{"location":"beginner/project-loans/#2-define-schemas","text":"The first step to build your module is to create the schema definitions for each table. The loans smart contract will consist of 3 tables as shown below. For this challenge, you\u2019ll see each table presented as fields and types. Your goal is to create the schema definition for each of these tables. Note Schema definitions are introduced in the Pact Schemas and Tables Tutorial .","title":"2. Define Schemas"},{"location":"beginner/project-loans/#21-loan-schema","text":"The loan table will be used to hold loan entries. loan table fieldname fieldtype loanName string entityName string loanAmount integer status string Code Challenge Take some time now to define the schema for the loan table. Challenge Solution","title":"2.1 Loan Schema"},{"location":"beginner/project-loans/#22-loan-history-schema","text":"The loan-history table will be used to track the loan\u2019s histories. It includes each of the field names and field types shown below. loan-history table fieldname fieldtype loanId string buyer string seller string amount integer Code Challenge Take some time now to define the schema for the loan-history table. Challenge Solution","title":"2.2 Loan History Schema"},{"location":"beginner/project-loans/#23-loan-inventory-schema","text":"The loan-inventory table will be used to hold inventory balance. loan-inventory table fieldname fieldtype balance integer Code Challenge Take some time now to define the schema for the loan-inventory table. Challenge Solution","title":"2.3 Loan Inventory Schema"},{"location":"beginner/project-loans/#3-define-tables","text":"Having defined each of the schemas for each table in your smart contract, you are now ready to define the tables. Code Challenge Take some time now to define each of the tables for the loans smart contract. Challenge Solution Note Table definitions are covered in the Pact Schemas and Tables Tutorial .","title":"3. Define Tables"},{"location":"beginner/project-loans/#4-define-consts","text":"The loans smart contract contains a few const values that will be used to pass values into functions and tables. The purpose of each of these constants will be more clear as you begin integrating them into functionality of your contract using functions. For now, complete the challenge to define the constants within your smart contract. Code Challenge Take some time now to define each of the const values INITIATED and ASSIGNED in the loans smart contract. Challenge Solution Note Constant definitions are covered in the documentation here .","title":"4. Define Consts"},{"location":"beginner/project-loans/#5-functions","text":"When working with tables, there are four useful types of functions that you\u2019ll be using in your smart contract. type purpose Utility Functions Perform routine operations callable by other functions. Insert Functions Insert new rows into a table. Update Functions Update values within a table. Read Functions Read values from a table. The functions you\u2019ll create in the loans smart contract will use combinations of these built in functions to insert, update, and read data from the tables in your smart contract. Note You can review each of these function types in the Pact Schemas and Tables Tutorial .","title":"5. Functions"},{"location":"beginner/project-loans/#utility-functions","text":"Your first function will be a utility function meant to help combine the parameters into an inventory key.","title":"Utility Functions"},{"location":"beginner/project-loans/#51-inventory-key","text":"Code Challenge Create a function named inventory-key that creates a key from the owner and loanId in the format \u201cloanId:owner\u201d . Challenge Solution The reason for starting with this function is so that you can use it as a tool as you progress through other functions in the smart contract. Hint Try using the format function to combine inputs into a string.","title":"5.1 Inventory-key"},{"location":"beginner/project-loans/#insert-and-update-functions","text":"The following 3 functions use a combination of read, insert, and update to add and update data in each of the tables you created. These functions will allow your users to accomplish important tasks like creating a loan, assigning a loan, and selling a loan.","title":"Insert and Update Functions"},{"location":"beginner/project-loans/#52-create-a-loan","text":"First, you\u2019ll need to create a function to create a loan. Creating a loan can be done by populating specific columns with the appropriate loan data. Take a look at the tables below to see each of the columns that you will insert data into. loans-table column-name value loanName loanName entityName entityName loanAmount loanAmount Status INITIATED loan-inventory-table column-name value balance loanAmount Code Challenge Given these requirements, construct a function named create-a-loan that accepts parameters loanId , loanName , entityName , and loanAmount to add the appropriate information to each table. Challenge Solution","title":"5.2 Create-a-loan"},{"location":"beginner/project-loans/#53-assign-a-loan","text":"Now that you can create a loan, it is important to be able to assign that loan to a specific entity when needed. To do that, you will both collect data from inputs and read existing data from tables. Using the combination of this data, you can then assign a loan and update the appropriate data. For the loans-table , you will need to both read and update data using the correct built-in functions. loans-table column function source \u201centityName\u201d:= entityName read loans-table \u201cloanAmount\u201d:= issuerBalance read loans-table \u201cstatus\u201d: ASSIGNED update loanId For the loan-history-table, you will need to insert data from inputs and data that is read from other tables. loan-history-table column function source \u201cloanId\u201d: loanId insert input \u201cbuyer\u201d: buyer insert input \u201cseller\u201d: entityName insert loans-table \u201camount\u201d: amount insert input The loan-inventory-table will have new data added and updated as needed. loan-inventory-table column function source \u201cbalance\u201d: amount insert inventory-key \u201cbalance\u201d: (- issuerBalance amount) update inventory-key Code Challenge This code challenge is complex, so take your time and don\u2019t worry if you get stuck. Follow each line as shown and try to construct the functionality needed to assign-a-loan . Challenge Solution Hint Break up the needs of each table into separate functions. This will help you read, insert, and update data in the appropriate order.","title":"5.3 Assign-a-loan"},{"location":"beginner/project-loans/#54-sell-a-loan","text":"The goal of the next function is similar to allow users to sell a loan. This function create a new row in the loan-history-table. This time, there is no table provided to help guide you. Try creating one for yourself if it is useful or follow the comments to complete the challenge. Code Challenge This is another difficult problem. Take your time and leverage what you learned in the previous section to help create this function. Challenge Solution Hint Consult the documentation and Schema and Tables tutorial for guidance on built-in functions like bind, insert, with-read, and others.","title":"5.4 Sell-a-loan"},{"location":"beginner/project-loans/#read-functions","text":"The next set of functions will allow you to read important information from the tables you created. These functions are much shorter than previous functions and the comments within the challenge files are hopefully enough to get you started.","title":"Read Functions"},{"location":"beginner/project-loans/#55-read-a-loan","text":"Code Challenge Create a function named read-a-loan that returns the values at a given loanId. Challenge Solution","title":"5.5 read-a-loan"},{"location":"beginner/project-loans/#56-read-loan-tx","text":"Code Challenge Create a function named read-loan-tx that reads loan txids. Challenge Solution","title":"5.6 read-loan-tx"},{"location":"beginner/project-loans/#57-read-all-loans","text":"Code Challenge Create a function named read-all-loans that selects all values from the loans table. Challenge Solution","title":"5.7 read-all-loans"},{"location":"beginner/project-loans/#58-read-inventory-pair","text":"Code Challenge Create a function named read-inventory-pair that reads the balance of a given key. Challenge Solution","title":"5.8 read-inventory-pair"},{"location":"beginner/project-loans/#59-read-loan-inventory","text":"Code Challenge Create a function named read-loan-inventory that reads the loan-inventory-table. Challenge Solution","title":"5.9 read-loan-inventory"},{"location":"beginner/project-loans/#510-read-loans-with-status","text":"Code Challenge Create a function named read-loans-with-status that reads all loans with a specific status. Challenge Solution","title":"5.10 read-loans-with-status"},{"location":"beginner/project-loans/#6-create-tables","text":"Earlier in the smart contract, you defined 3 schemas and tables. Now that the module is complete, you are ready to move outside of the module to create each of these tables. Code Challenge Take some time now to create each of the tables for the loans smart contract. Challenge Solution Note Table creation is covered in the Tables and Schemas tutorial .","title":"6. Create Tables"},{"location":"beginner/project-loans/#deploy-the-smart-contract","text":"Congratulations, at this point you have completed the Loans smart contract! If you\u2019d like, you can try deploying this smart contract. You can deploy this contract using the Pact Onine Editor or from the Pact Atom SDK . If you choose to deploy this locally, you\u2019ll need the REPL file which you can find inside of the repository you cloned. For help getting started and deploying in each of these environments, try the following tutorials. Pact Online Editor Pact Development on Atom SDK Tutorial","title":"Deploy the Smart Contract"},{"location":"beginner/project-loans/#review","text":"That wraps up this tutorial on the Loans app. By completing this tutorial, you\u2019ve mastered many of the core ideas surrounding modules, schemas, tables, and functions, to tackle unfamiliar problems in new ways. Not only that, you\u2019ve put each of these ideas into practice to create a smart contract that solves a very complex real world problem. The same ideas you learned here can be applied to many other industries. Having the ability to create tables and manipulate data to create useful applications encompasses everything it means to build the back end of a blockchain application using Pact.","title":"Review"},{"location":"beginner/project-rotatable-wallet/","text":"Pact Rotatable Wallet Welcome to this Rotatable Wallet project tutorial! Here you\u2019ll create a smart contract named Rotatable Wallets that demonstrates many important Pact features that you learned throughout previous tutorials. Topics covered in this tutorial Project Overview Define Keysets Define Module Define Schema and Table Functions Create Table Deploy the Contract Key Takeaway Modules can be permissioned to ensure the security of running your code on a decentralized network and allow for row level permissions when necessary. Rotatable Wallet Module Demonstration The module you will build is called the Auth Module and allows for a feature known as a Rotatable Wallet. This builds on earlier knowledge and helps demonstrate how keysets can be used at the \"row level\" to guard assets. It\u2019s an example of how a Pact smart contract can manage user keysets in a decentralized fashion allowing users to update information based on their keyset. The ability to change keyset values is referred to as rotating keysets . By creating this module, you\u2019ll be able to effectively create smart contracts that guard assets at a row level and take advantage of functions that allow users to update information in tables. Project Overview Before getting into the code, take some time to review what you\u2019ll be building. This smart contract can be broken down into steps focused on 4 core areas that include the keysets, module, table, and functions. The details of each step will be described as you progress through the tutorial. Each step will include a short description ending with a code challenge. If you get stuck, you can always look at the hints or solutions we provide. Project Environment Setup To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the loans directory to begin working on this project. cd pact-lang.org-code/rotatable-wallet Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like to. When you\u2019re set up to begin, follow along with each step to create your own Rotatable Wallet Smart Contract! 1. Define Keysets Get started with your smart contract by defining it\u2019s keysets. The 2 keysets required for this smart contract are a module-admin-keyset that will allow users to define and update modules, and an module-operate-keyset that will allow users to create accounts. Each of these keysets play a specific role that will be defined later in the application. Code Challenge Complete define and read the module-admin-keyset and the module-operate-keyset . Challenge Solution Note View define-keyset for more information on defining and reading keysets. 2. Define Module The next step is to create the module that will contain the logic of your smart contract. Code Challenge Define a module named auth that specifies access to the module-admin keyset. Challenge Solution Note View module for more information on creating modules. 3. Define Schema and Table This smart contract contains a schema named user with 2 columns; nickname held as a string and keyset which is held as a keyset. Use this schema to both define and create a table named users . Code Challenge Define the user schema and table. Challenge Solution Note View defschema and deftable for more information on creating schemas and tables. 4. Create Functions You're now ready to complete the functions for this module. function purpose create-user Allows operate-admin to add rows to the user table. enforce-user-auth Restrict access permissions to users with a given id. change-nickname Allow users with a specific keyset to update their nickname. rotate-keyset Allow the owner of a keyset to change their keyset. The goal of these functions is to allow users the flexibility they need to create and manage their accounts. 4.1 Create User In this step, you will create a function that allows the operate-admin to add rows to the users table. Code Challenge Define a function named create-user that takes 3 arguments; id, nickname, and keyset. Next, restrict access for function calls to the operate-admin . Finally, insert a row into the users table using the inputs specified by the user. Challenge Solution Note View enforce-keyset and insert for more information related to completing this challenge. 4.2 Enforce User It\u2019s sometimes useful to restrict access to data to specific users. For example, users may not want others to see the balance of their account or other sensitive information. This can be done in Pact by enforcing access to rows of data using row-level keysets. The first step toward making this happen is to be able to view the keyset associated with a specific id. The following function shows an example of reading a keyset in a specific row from a given id. ( defun enforce-keyset-of-id ( id ) ( with-read table id { keyset := keyset } ( enforce-keyset keyset ) keyset ) ) This function doesn\u2019t yet give any access to the data in a row. It\u2019s purpose is for other functions to call on it in the case that they want to do something like place row level restrictions on data. This will be valuable shortly when you write code that needs to call this function. Code Challenge Define a function named enforce-user-auth that returns the keyset associated with a given id. Challenge Solution Note View enforce-keyset , with-read , and bind for more information related to completing this challenge. 4.3 Change Nickname Once you can restrict access to data, you\u2019re ready to allow users to take specific actions based on the data they have access to. For example, a user may want to update their profile name, or make changes to sensitive information that other users should not be able to access. To do that, you can write a function that utilizes the previous function you created. From there, you can add in functionality that allows users to update their data. Here is an example function update-data that allows users to update existing information. It leverages the previous example function enforce-keyset-of-id to make an update to a row in the table example-table . ( defun update-data ( id new-data ) ( enforce-keyset-of-id id ) ( update example-table id { data : new-data }) ( format Data updated in row {} to {} [ id new-data ])) This function combined with the previous function allows users with a specific keyset to make updates to restricted information. Code Challenge Define a function named change-nickname that allows users with a specific keyset to update their nickname in the users table. Challenge Solution Note View update and format for more information related to completing this challenge. 4.4 Rotate Keyset Now that users can update their name, you can apply this same functionality to other information. For example, you can allow users to update their keyset. The ability to update keysets is known as \u2018rotating keysets\u2019 and this is where the name \u2018Rotatable wallets\u2019 came from for this demonstration. This feature is comparable to being able to update a password, and it\u2019s an extremely useful feature to have in an application. For this final function, use the information learned from previous steps to add rotating keysets as a feature of your smart contract. Code Challenge Define a function named rotate-keyset that allows the owner of a keyset to change their keyset. Challenge Solution Note View update and format for more information related to completing this challenge. 5. Create Table The last step is to create the user table defined within the module. Code Challenge Create the user table. Challenge Solution Deploy the Smart Contract Your Rotatable Wallet smart contract is complete! If you\u2019d like, you can deploy this contract similar to how you would deploy other smart contracts. For more information on deploying this smart contract, view the following tutorials. Hello World with Pact Pact Online Editor Pact Development on Atom SDK Review That wraps up this tutorial on the Rotatable Wallet application. Throughout this tutorial, you built a smart contract named Rotatable Wallets that demonstrated many important Pact features that you learned throughout previous tutorials. Most importantly, you showed how modules can be permissioned to ensure the security of running your code on a decentralized network and allow for row level permissions when necessary. Having the ability to permission modules is an extremely valuable feature of Pact, and you can use this in many other applications in the future. Take some time now to experiment with this feature to try applying it in new situations. When you\u2019re ready, move to the next tutorial to continue building Pact applications!","title":"11. Project: Rotatable Wallet"},{"location":"beginner/project-rotatable-wallet/#pact-rotatable-wallet","text":"Welcome to this Rotatable Wallet project tutorial! Here you\u2019ll create a smart contract named Rotatable Wallets that demonstrates many important Pact features that you learned throughout previous tutorials. Topics covered in this tutorial Project Overview Define Keysets Define Module Define Schema and Table Functions Create Table Deploy the Contract Key Takeaway Modules can be permissioned to ensure the security of running your code on a decentralized network and allow for row level permissions when necessary.","title":"Pact Rotatable Wallet"},{"location":"beginner/project-rotatable-wallet/#rotatable-wallet-module-demonstration","text":"The module you will build is called the Auth Module and allows for a feature known as a Rotatable Wallet. This builds on earlier knowledge and helps demonstrate how keysets can be used at the \"row level\" to guard assets. It\u2019s an example of how a Pact smart contract can manage user keysets in a decentralized fashion allowing users to update information based on their keyset. The ability to change keyset values is referred to as rotating keysets . By creating this module, you\u2019ll be able to effectively create smart contracts that guard assets at a row level and take advantage of functions that allow users to update information in tables.","title":"Rotatable Wallet Module Demonstration"},{"location":"beginner/project-rotatable-wallet/#project-overview","text":"Before getting into the code, take some time to review what you\u2019ll be building. This smart contract can be broken down into steps focused on 4 core areas that include the keysets, module, table, and functions. The details of each step will be described as you progress through the tutorial. Each step will include a short description ending with a code challenge. If you get stuck, you can always look at the hints or solutions we provide.","title":"Project Overview"},{"location":"beginner/project-rotatable-wallet/#project-environment-setup","text":"To get started, choose a project directory and clone the project resources into your local environment. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the loans directory to begin working on this project. cd pact-lang.org-code/rotatable-wallet Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like to. When you\u2019re set up to begin, follow along with each step to create your own Rotatable Wallet Smart Contract!","title":"Project Environment Setup"},{"location":"beginner/project-rotatable-wallet/#1-define-keysets","text":"Get started with your smart contract by defining it\u2019s keysets. The 2 keysets required for this smart contract are a module-admin-keyset that will allow users to define and update modules, and an module-operate-keyset that will allow users to create accounts. Each of these keysets play a specific role that will be defined later in the application. Code Challenge Complete define and read the module-admin-keyset and the module-operate-keyset . Challenge Solution Note View define-keyset for more information on defining and reading keysets.","title":"1. Define Keysets"},{"location":"beginner/project-rotatable-wallet/#2-define-module","text":"The next step is to create the module that will contain the logic of your smart contract. Code Challenge Define a module named auth that specifies access to the module-admin keyset. Challenge Solution Note View module for more information on creating modules.","title":"2. Define Module"},{"location":"beginner/project-rotatable-wallet/#3-define-schema-and-table","text":"This smart contract contains a schema named user with 2 columns; nickname held as a string and keyset which is held as a keyset. Use this schema to both define and create a table named users . Code Challenge Define the user schema and table. Challenge Solution Note View defschema and deftable for more information on creating schemas and tables.","title":"3. Define Schema and Table"},{"location":"beginner/project-rotatable-wallet/#4-create-functions","text":"You're now ready to complete the functions for this module. function purpose create-user Allows operate-admin to add rows to the user table. enforce-user-auth Restrict access permissions to users with a given id. change-nickname Allow users with a specific keyset to update their nickname. rotate-keyset Allow the owner of a keyset to change their keyset. The goal of these functions is to allow users the flexibility they need to create and manage their accounts.","title":"4. Create Functions"},{"location":"beginner/project-rotatable-wallet/#41-create-user","text":"In this step, you will create a function that allows the operate-admin to add rows to the users table. Code Challenge Define a function named create-user that takes 3 arguments; id, nickname, and keyset. Next, restrict access for function calls to the operate-admin . Finally, insert a row into the users table using the inputs specified by the user. Challenge Solution Note View enforce-keyset and insert for more information related to completing this challenge.","title":"4.1 Create User"},{"location":"beginner/project-rotatable-wallet/#42-enforce-user","text":"It\u2019s sometimes useful to restrict access to data to specific users. For example, users may not want others to see the balance of their account or other sensitive information. This can be done in Pact by enforcing access to rows of data using row-level keysets. The first step toward making this happen is to be able to view the keyset associated with a specific id. The following function shows an example of reading a keyset in a specific row from a given id. ( defun enforce-keyset-of-id ( id ) ( with-read table id { keyset := keyset } ( enforce-keyset keyset ) keyset ) ) This function doesn\u2019t yet give any access to the data in a row. It\u2019s purpose is for other functions to call on it in the case that they want to do something like place row level restrictions on data. This will be valuable shortly when you write code that needs to call this function. Code Challenge Define a function named enforce-user-auth that returns the keyset associated with a given id. Challenge Solution Note View enforce-keyset , with-read , and bind for more information related to completing this challenge.","title":"4.2 Enforce User"},{"location":"beginner/project-rotatable-wallet/#43-change-nickname","text":"Once you can restrict access to data, you\u2019re ready to allow users to take specific actions based on the data they have access to. For example, a user may want to update their profile name, or make changes to sensitive information that other users should not be able to access. To do that, you can write a function that utilizes the previous function you created. From there, you can add in functionality that allows users to update their data. Here is an example function update-data that allows users to update existing information. It leverages the previous example function enforce-keyset-of-id to make an update to a row in the table example-table . ( defun update-data ( id new-data ) ( enforce-keyset-of-id id ) ( update example-table id { data : new-data }) ( format Data updated in row {} to {} [ id new-data ])) This function combined with the previous function allows users with a specific keyset to make updates to restricted information. Code Challenge Define a function named change-nickname that allows users with a specific keyset to update their nickname in the users table. Challenge Solution Note View update and format for more information related to completing this challenge.","title":"4.3 Change Nickname"},{"location":"beginner/project-rotatable-wallet/#44-rotate-keyset","text":"Now that users can update their name, you can apply this same functionality to other information. For example, you can allow users to update their keyset. The ability to update keysets is known as \u2018rotating keysets\u2019 and this is where the name \u2018Rotatable wallets\u2019 came from for this demonstration. This feature is comparable to being able to update a password, and it\u2019s an extremely useful feature to have in an application. For this final function, use the information learned from previous steps to add rotating keysets as a feature of your smart contract. Code Challenge Define a function named rotate-keyset that allows the owner of a keyset to change their keyset. Challenge Solution Note View update and format for more information related to completing this challenge.","title":"4.4 Rotate Keyset"},{"location":"beginner/project-rotatable-wallet/#5-create-table","text":"The last step is to create the user table defined within the module. Code Challenge Create the user table. Challenge Solution","title":"5. Create Table"},{"location":"beginner/project-rotatable-wallet/#deploy-the-smart-contract","text":"Your Rotatable Wallet smart contract is complete! If you\u2019d like, you can deploy this contract similar to how you would deploy other smart contracts. For more information on deploying this smart contract, view the following tutorials. Hello World with Pact Pact Online Editor Pact Development on Atom SDK","title":"Deploy the Smart Contract"},{"location":"beginner/project-rotatable-wallet/#review","text":"That wraps up this tutorial on the Rotatable Wallet application. Throughout this tutorial, you built a smart contract named Rotatable Wallets that demonstrated many important Pact features that you learned throughout previous tutorials. Most importantly, you showed how modules can be permissioned to ensure the security of running your code on a decentralized network and allow for row level permissions when necessary. Having the ability to permission modules is an extremely valuable feature of Pact, and you can use this in many other applications in the future. Take some time now to experiment with this feature to try applying it in new situations. When you\u2019re ready, move to the next tutorial to continue building Pact applications!","title":"Review"},{"location":"beginner/testing-pact-code-in-the-sdk/","text":"Testing Pact Code in the SDK Welcome to this introduction to Testing in the SDK! This tutorial covers the following topics REPL Overview Built-in Functions Load Environment Data Note on Transactions Load Pact File Call Functions Run REPL file Built-in Error Messages In this tutorial, you will learn the basics of testing in the SDK to build your own REPL file. This is a great start to begin testing the smart contracts you build locally. Key Takeaway Pact and the Atom SDK provide a powerful testing environment that allows you to build and test Pact programs locally. Testing Pact Code in the SDK Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Pre-requisites Before starting this tutorial, it helps to have completed the following pre-requisites. Pact Development on Atom SDK : The SDK is required for testing in the SDK. You can get up and running with the SDK using this tutorial. Project: Loans : You will be building a REPL file for the Loans project covered in a separate tutorial. This isn\u2019t required but is a helpful way to better understand the smart contract used throughout this tutorial. REPL Overview REPL files are used to load and run Pact files using the SDK. REPL stands for read - eval - print - loop. This acronym refers to the idea that given a Pact file, a REPL file is responsible for reading, evaluating, printing, and looping through the code as needed to both run and provide the output of the Pact file. These are a common part of LISP-like languages such as Pact and they allow you to quickly test the smart contracts you build. A simple way to load a REPL file is from your terminal as shown below. Using your terminal window, you will load the REPL file. This includes code that both loads and runs the pact file. The pact file then returns data to the REPL file which sends the output to your terminal window. Comparison to Online Editor To better grasp the importance of the REPL file, it helps to look at a tool you may be more familiar with - the online editor . Many features provided by the online editor\u2019s UI are things that you will need to code for yourself in a local or production environment. Things like loading the pact file into the REPL, setting up the environment data and keys, and making function calls will all be done from within the REPL file. You will complete all of this and other important testing features using the Pact REPL only built-in functions. Built-in Functions When building a REPL file, there are many built-in functions available to you. These functions are known as the REPL only functions because they cannot be used in pact files. While all of these built-in functions are valuable, there are some that are more commonly used. Take some time now to review each of the functions in the documentation as well as the summary of commonly used functions provided below. function purpose begin-tx Begin a transaction. commit-tx Commit a transaction. env-data Set transaction data. env-keys Set transaction signature keys. expect Evaluate expression and verify that it equals what is expected. load Load and evaluate a file. Coming up, you will create a .REPL file for yourself that uses many of the functions listed above. Project Environment Setup Throughout the rest of this tutorial, you will build a REPL file for yourself. To follow along from your local environment, clone the repo pact-lang.org-code GitHub repo. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the test-in-sdk directory to begin working on this project. cd pact-lang.org-code/test-in-sdk Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like. 1. Load Environment Data The first step in creating a .repl file is to load the environment keys and data. This is similar to what you have seen in the online editor . Rather than creating this data from the UI like you did before, you now need to program this information into your .repl file. The online editor allowed you to create keys and keysets using the tool panel as shown below. The result tab shows data similar to what you will be writing into your .repl file. You can view the code that represents your keys and keysets using the Result tab. To set up this environment using the .repl file, you will use two separate built in functions; env-keys and env-data . function purpose env-keys Set transaction signature keys. env-data Set transaction JSON data, either as encoded string, or as pact types coerced to JSON. env-keys example ( env-keys [ my-key admin-key ]) Setting transaction keys env-data example ( env-data { keyset : { keys : [ my-key admin-key ] , pred : keys-any } }) Setting transaction data Code Challenge For this code challenge, you will use env-keys and env-data to load the keys and environment data into the .repl file. Use the comments to help guide you, and if you\u2019re unsure how to move forward, take a look at the solution for more details. Challenge Solution Note Looking at the loans.pact file could be a helpful way to understand what you are trying to do in the loans.repl file. This file exists in the project directory under 3-finish . Note About Transactions Before moving on, there\u2019s an important note to make about transactions. When working within REPL files, you can make as many calls to the pact code within a transaction as you like. Any command sent to the blockchain is a transaction, but a command too can have multiple calls, for instance, defining a module with module and creating its tables with create-table calls. To successfully execute a transaction you need to both begin the transaction and commit the transaction. This is done using begin-tx and commit-tx . function purpose begin-tx Begin transaction with optional NAME. commit-tx Commit transaction. It\u2019s valuable to use these built-in functions to group calls into small transactions within your REPL file. Here\u2019s why this is useful. Error Example Any error that occurs in a transaction will cause it to roll back and fail to run. While it's possible to place all of your calls within a single transaction, this isn\u2019t a good habit to get into. This will make it difficult to tell where your file is failing and make it difficult to continue testing. For that reason, be sure to break up your test files into smaller transactions. ( begin-tx ) ;; This could fail and I would know where the problem is ( commit-tx ) ( begin-tx ) ;; This could fail and I would know where the problem is ( commit-tx ) ( begin-tx ) ;; This could fail and I would know where the problem is ( commit-tx ) Transactions can be grouped together however is most convenient for your testing. Try maintaining a logical order in your transactions for ease of maintenance and readability. 2. Load Pact File Pact files are not run by your computer directly, they\u2019re loaded into the .repl file and run from there. Now that you have loaded the environment data, you need to load the pact file into the .repl file. This is done using the built-in load function. function purpose load Load and evaluate FILE. The syntax for this is simple. load example ( load accounts.pact ) All you need to do type load then specify the file path as a string. Pact and REPL files are generally kept in the same folder so you usually only need to specify the name of the pact file. Code Challenge Load the loans.pact file into the REPL. Challenge Solution 3. Call Functions Now that the pact file is loaded into the REPL file, you are ready to start calling its functions. To do this, specify the module name with use , then call the functions from within the module. Function Call Example ( begin-tx ) ( use module-name ) ( function-name input-1 input-2 ) ( commit-tx ) 3.1 Generate Data For this code challenge, you will need to make calls to a few functions from the loans project. Here is a brief overview of each of the functions you will call. function purpose create-a-loan Accepts parameters to add the appropriate information to each table assign-a-loan Assigns a loan to an entity. sell-a-loan Sell a loan and log details in the loan history table. Follow the links provided or view the loans.pact file for more details. Code Challenge Call the create-a-loan , assign-a-loan , and sell-a-loan functions from the loans.pact file and provide your own inputs as needed. Challenge Solution Note If you have not already completed the Project: Loans tutorial , try working through this tutorial to build the entire Loans smart contract for yourself! 3.2. Read Loans After calling functions used to create, assign, and sell a loan, you can now read some of the data that you created. Similar to before, you will be calling functions from the loans.pact file. Feel free to reference the previous challenge for guidance. Here is a brief overview of the functions you will call in this challenge. function purpose read-loan-inventory Reads all loans in the loan inventory table. read-loans-with-status Reads all loans with a specific status. Code Challenge Call the read-loan-inventory and read-loans-with-status functions from the loans.pact file and provide your inputs as needed. Challenge Solution Run REPL File At this point you have completed the REPL file. Congratulations! The last step is to run the file from your terminal to view the output. To do this, open your terminal and navigate to the 3-finish directory from your project folder. cd 3-finish Run pact. pact Loan the loans.repl file pact (load loans.repl ) You should see an output to your terminal similar to the data shown below. Notice the flags similar to those that you\u2019ve seen throughout the challenges. This is to help you see where the code you wrote is corresponding to the output in the terminal. Take some time now to view the output and see how it aligns with the code you wrote in the REPL file. ;; ======================================================== ;; 1-load-environment-data ;; ======================================================== Loading loans.repl... Setting transaction keys Setting transaction data ;; ======================================================== ;; 2-load-pact-file ;; ======================================================== Loading loans.pact... Keyset defined Loaded module \\ loans\\ , hash \\ 552198d5bc3a6cf8e84919a1b0f8c5cc764f65455e8dc687e3b6680b225e2684801fbfd42d6c734f798e3e210a03d5c9d6100c74433e3e16428903c95292466e\\ TableCreated TableCreated TableCreated ;; ======================================================== ;; 3-call-functions ;; ======================================================== Using \\ loans\\ Write succeeded Write succeeded Write succeeded Write succeeded ;; ======================================================== ;; 4-read-loans ;; ======================================================== Using \\ loans\\ [{ inventory-key : loanId-1:Capital One , balance : 40000} { inventory-key : loanId-1:buyer1 , balance : 6000} { inventory-key : loanId-1:buyer2 , balance : 2000} { inventory-key : loanId-1:buyer3 , balance : 2000}] [] [{ entityName : Capital One , loanAmount : 50000, loanName : loan1 , status : assigned }] You can experiment with changing the .repl or .pact files to see how this changes the output in your terminal. Built-in Error Messages As you\u2019ve seen, you can run REPL files from your terminal to test Pact code. Another valuable feature in the SDK is that it actually runs these files for you without using the terminal. This helps you spot errors from directly within Atom. Two features that help you spot errors are the error highlighting and the error message. Error Highlighting Shows up as red dot on line that includes error. REPL files with errors in them will have a red squiggly line under the file name. Error Message Gives details about the error source. These are both valuable ways to effectively test and debug your Pact code. Pact Examples To view these features take a look at our pact-examples repo. Change into your pact-examples directory or clone this repo into your project folder if you have not set this project up before. git clone https://github.com/kadena-io/pact-examples.git Change into the pact-examples directory. cd pact-examples Open this directory in atom. atom . Here you will see many more examples of REPL files along with the smart contracts they are testing. Navigate to atoz keysets keysets.repl to view one of these examples. In this file you will notice the use of a new built-in function named expect-failure . Both expect-failure and expect allow you to test if the outcome of an expression is what you would have expected. expect Evaluate expression and verify that it equals what is expected. expect-failure Evaluates the expression and succeed only if it throws an error. On line 35, notice the line that states that it expects the real-keyset should fail. ( expect-failure real keyset should fail ( enforce-keyset keyset-real )) You can tell that this test is passing because there is no error message or highlighting. To make this test fail, try changing keyset-real to keyset-carol . ( expect-failure real keyset should fail ( enforce-keyset keyset-carol )) After making this change, the filename keysets.repl should now have a red squiggle under it and line 35 should have a red dot next to it. Both of these indicate that a test is failing within the REPL file. To get more information, you can click the dot on line 35 and select the triangle to view the source of the error as shown below. Using this detailed information you can better test and debug the code from within your Pact smart contract. Note To understand exactly what is failing and why, it helps to look through both the .pact and .repl files for more information. Take some time now to study the keyset example files as well as a few other examples to practice testing code and debugging errors. Review Congratulations on completing this introduction to Testing Pact Code in the SDK ! In this tutorial, you learned both the basics of testing in the SDK and how to build your own REPL file. This is a great start to begin testing the smart contracts you build locally. From here, you can experiment with changing the .repl or .pact files to see how this changes the output in your terminal. Using this workflow, you can begin building and testing files however you would like.","title":"13. Test in the SDK"},{"location":"beginner/testing-pact-code-in-the-sdk/#testing-pact-code-in-the-sdk","text":"Welcome to this introduction to Testing in the SDK! This tutorial covers the following topics REPL Overview Built-in Functions Load Environment Data Note on Transactions Load Pact File Call Functions Run REPL file Built-in Error Messages In this tutorial, you will learn the basics of testing in the SDK to build your own REPL file. This is a great start to begin testing the smart contracts you build locally. Key Takeaway Pact and the Atom SDK provide a powerful testing environment that allows you to build and test Pact programs locally.","title":"Testing Pact Code in the SDK"},{"location":"beginner/testing-pact-code-in-the-sdk/#testing-pact-code-in-the-sdk-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Testing Pact Code in the SDK Tutorial"},{"location":"beginner/testing-pact-code-in-the-sdk/#pre-requisites","text":"Before starting this tutorial, it helps to have completed the following pre-requisites. Pact Development on Atom SDK : The SDK is required for testing in the SDK. You can get up and running with the SDK using this tutorial. Project: Loans : You will be building a REPL file for the Loans project covered in a separate tutorial. This isn\u2019t required but is a helpful way to better understand the smart contract used throughout this tutorial.","title":"Pre-requisites"},{"location":"beginner/testing-pact-code-in-the-sdk/#repl-overview","text":"REPL files are used to load and run Pact files using the SDK. REPL stands for read - eval - print - loop. This acronym refers to the idea that given a Pact file, a REPL file is responsible for reading, evaluating, printing, and looping through the code as needed to both run and provide the output of the Pact file. These are a common part of LISP-like languages such as Pact and they allow you to quickly test the smart contracts you build. A simple way to load a REPL file is from your terminal as shown below. Using your terminal window, you will load the REPL file. This includes code that both loads and runs the pact file. The pact file then returns data to the REPL file which sends the output to your terminal window.","title":"REPL Overview"},{"location":"beginner/testing-pact-code-in-the-sdk/#comparison-to-online-editor","text":"To better grasp the importance of the REPL file, it helps to look at a tool you may be more familiar with - the online editor . Many features provided by the online editor\u2019s UI are things that you will need to code for yourself in a local or production environment. Things like loading the pact file into the REPL, setting up the environment data and keys, and making function calls will all be done from within the REPL file. You will complete all of this and other important testing features using the Pact REPL only built-in functions.","title":"Comparison to Online Editor"},{"location":"beginner/testing-pact-code-in-the-sdk/#built-in-functions","text":"When building a REPL file, there are many built-in functions available to you. These functions are known as the REPL only functions because they cannot be used in pact files. While all of these built-in functions are valuable, there are some that are more commonly used. Take some time now to review each of the functions in the documentation as well as the summary of commonly used functions provided below. function purpose begin-tx Begin a transaction. commit-tx Commit a transaction. env-data Set transaction data. env-keys Set transaction signature keys. expect Evaluate expression and verify that it equals what is expected. load Load and evaluate a file. Coming up, you will create a .REPL file for yourself that uses many of the functions listed above.","title":"Built-in Functions"},{"location":"beginner/testing-pact-code-in-the-sdk/#project-environment-setup","text":"Throughout the rest of this tutorial, you will build a REPL file for yourself. To follow along from your local environment, clone the repo pact-lang.org-code GitHub repo. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the test-in-sdk directory to begin working on this project. cd pact-lang.org-code/test-in-sdk Open this directory in atom to see each of the files provided. atom . As you\u2019ll see, there are a few separate folders available to you. start Provides a starting point with all comments for every challenge. challenges Challenges in the demo are broken out into separate files, allowing you to build your application over time while having the flexibility to experiment with your own ideas. finish Includes all comments and code for the final application. loans Includes final application without the challenge comments. Each of these options are meant to help support you as you work through these challenges. Feel free to use them however you\u2019d like.","title":"Project Environment Setup"},{"location":"beginner/testing-pact-code-in-the-sdk/#1-load-environment-data","text":"The first step in creating a .repl file is to load the environment keys and data. This is similar to what you have seen in the online editor . Rather than creating this data from the UI like you did before, you now need to program this information into your .repl file. The online editor allowed you to create keys and keysets using the tool panel as shown below. The result tab shows data similar to what you will be writing into your .repl file. You can view the code that represents your keys and keysets using the Result tab. To set up this environment using the .repl file, you will use two separate built in functions; env-keys and env-data . function purpose env-keys Set transaction signature keys. env-data Set transaction JSON data, either as encoded string, or as pact types coerced to JSON. env-keys example ( env-keys [ my-key admin-key ]) Setting transaction keys env-data example ( env-data { keyset : { keys : [ my-key admin-key ] , pred : keys-any } }) Setting transaction data Code Challenge For this code challenge, you will use env-keys and env-data to load the keys and environment data into the .repl file. Use the comments to help guide you, and if you\u2019re unsure how to move forward, take a look at the solution for more details. Challenge Solution Note Looking at the loans.pact file could be a helpful way to understand what you are trying to do in the loans.repl file. This file exists in the project directory under 3-finish .","title":"1. Load Environment Data"},{"location":"beginner/testing-pact-code-in-the-sdk/#note-about-transactions","text":"Before moving on, there\u2019s an important note to make about transactions. When working within REPL files, you can make as many calls to the pact code within a transaction as you like. Any command sent to the blockchain is a transaction, but a command too can have multiple calls, for instance, defining a module with module and creating its tables with create-table calls. To successfully execute a transaction you need to both begin the transaction and commit the transaction. This is done using begin-tx and commit-tx . function purpose begin-tx Begin transaction with optional NAME. commit-tx Commit transaction. It\u2019s valuable to use these built-in functions to group calls into small transactions within your REPL file. Here\u2019s why this is useful. Error Example Any error that occurs in a transaction will cause it to roll back and fail to run. While it's possible to place all of your calls within a single transaction, this isn\u2019t a good habit to get into. This will make it difficult to tell where your file is failing and make it difficult to continue testing. For that reason, be sure to break up your test files into smaller transactions. ( begin-tx ) ;; This could fail and I would know where the problem is ( commit-tx ) ( begin-tx ) ;; This could fail and I would know where the problem is ( commit-tx ) ( begin-tx ) ;; This could fail and I would know where the problem is ( commit-tx ) Transactions can be grouped together however is most convenient for your testing. Try maintaining a logical order in your transactions for ease of maintenance and readability.","title":"Note About Transactions"},{"location":"beginner/testing-pact-code-in-the-sdk/#2-load-pact-file","text":"Pact files are not run by your computer directly, they\u2019re loaded into the .repl file and run from there. Now that you have loaded the environment data, you need to load the pact file into the .repl file. This is done using the built-in load function. function purpose load Load and evaluate FILE. The syntax for this is simple. load example ( load accounts.pact ) All you need to do type load then specify the file path as a string. Pact and REPL files are generally kept in the same folder so you usually only need to specify the name of the pact file. Code Challenge Load the loans.pact file into the REPL. Challenge Solution","title":"2. Load Pact File"},{"location":"beginner/testing-pact-code-in-the-sdk/#3-call-functions","text":"Now that the pact file is loaded into the REPL file, you are ready to start calling its functions. To do this, specify the module name with use , then call the functions from within the module. Function Call Example ( begin-tx ) ( use module-name ) ( function-name input-1 input-2 ) ( commit-tx )","title":"3. Call Functions"},{"location":"beginner/testing-pact-code-in-the-sdk/#31-generate-data","text":"For this code challenge, you will need to make calls to a few functions from the loans project. Here is a brief overview of each of the functions you will call. function purpose create-a-loan Accepts parameters to add the appropriate information to each table assign-a-loan Assigns a loan to an entity. sell-a-loan Sell a loan and log details in the loan history table. Follow the links provided or view the loans.pact file for more details. Code Challenge Call the create-a-loan , assign-a-loan , and sell-a-loan functions from the loans.pact file and provide your own inputs as needed. Challenge Solution Note If you have not already completed the Project: Loans tutorial , try working through this tutorial to build the entire Loans smart contract for yourself!","title":"3.1 Generate Data"},{"location":"beginner/testing-pact-code-in-the-sdk/#32-read-loans","text":"After calling functions used to create, assign, and sell a loan, you can now read some of the data that you created. Similar to before, you will be calling functions from the loans.pact file. Feel free to reference the previous challenge for guidance. Here is a brief overview of the functions you will call in this challenge. function purpose read-loan-inventory Reads all loans in the loan inventory table. read-loans-with-status Reads all loans with a specific status. Code Challenge Call the read-loan-inventory and read-loans-with-status functions from the loans.pact file and provide your inputs as needed. Challenge Solution","title":"3.2. Read Loans"},{"location":"beginner/testing-pact-code-in-the-sdk/#run-repl-file","text":"At this point you have completed the REPL file. Congratulations! The last step is to run the file from your terminal to view the output. To do this, open your terminal and navigate to the 3-finish directory from your project folder. cd 3-finish Run pact. pact Loan the loans.repl file pact (load loans.repl ) You should see an output to your terminal similar to the data shown below. Notice the flags similar to those that you\u2019ve seen throughout the challenges. This is to help you see where the code you wrote is corresponding to the output in the terminal. Take some time now to view the output and see how it aligns with the code you wrote in the REPL file. ;; ======================================================== ;; 1-load-environment-data ;; ======================================================== Loading loans.repl... Setting transaction keys Setting transaction data ;; ======================================================== ;; 2-load-pact-file ;; ======================================================== Loading loans.pact... Keyset defined Loaded module \\ loans\\ , hash \\ 552198d5bc3a6cf8e84919a1b0f8c5cc764f65455e8dc687e3b6680b225e2684801fbfd42d6c734f798e3e210a03d5c9d6100c74433e3e16428903c95292466e\\ TableCreated TableCreated TableCreated ;; ======================================================== ;; 3-call-functions ;; ======================================================== Using \\ loans\\ Write succeeded Write succeeded Write succeeded Write succeeded ;; ======================================================== ;; 4-read-loans ;; ======================================================== Using \\ loans\\ [{ inventory-key : loanId-1:Capital One , balance : 40000} { inventory-key : loanId-1:buyer1 , balance : 6000} { inventory-key : loanId-1:buyer2 , balance : 2000} { inventory-key : loanId-1:buyer3 , balance : 2000}] [] [{ entityName : Capital One , loanAmount : 50000, loanName : loan1 , status : assigned }] You can experiment with changing the .repl or .pact files to see how this changes the output in your terminal.","title":"Run REPL File"},{"location":"beginner/testing-pact-code-in-the-sdk/#built-in-error-messages","text":"As you\u2019ve seen, you can run REPL files from your terminal to test Pact code. Another valuable feature in the SDK is that it actually runs these files for you without using the terminal. This helps you spot errors from directly within Atom. Two features that help you spot errors are the error highlighting and the error message. Error Highlighting Shows up as red dot on line that includes error. REPL files with errors in them will have a red squiggly line under the file name. Error Message Gives details about the error source. These are both valuable ways to effectively test and debug your Pact code.","title":"Built-in Error Messages"},{"location":"beginner/testing-pact-code-in-the-sdk/#pact-examples","text":"To view these features take a look at our pact-examples repo. Change into your pact-examples directory or clone this repo into your project folder if you have not set this project up before. git clone https://github.com/kadena-io/pact-examples.git Change into the pact-examples directory. cd pact-examples Open this directory in atom. atom . Here you will see many more examples of REPL files along with the smart contracts they are testing. Navigate to atoz keysets keysets.repl to view one of these examples. In this file you will notice the use of a new built-in function named expect-failure . Both expect-failure and expect allow you to test if the outcome of an expression is what you would have expected. expect Evaluate expression and verify that it equals what is expected. expect-failure Evaluates the expression and succeed only if it throws an error. On line 35, notice the line that states that it expects the real-keyset should fail. ( expect-failure real keyset should fail ( enforce-keyset keyset-real )) You can tell that this test is passing because there is no error message or highlighting. To make this test fail, try changing keyset-real to keyset-carol . ( expect-failure real keyset should fail ( enforce-keyset keyset-carol )) After making this change, the filename keysets.repl should now have a red squiggle under it and line 35 should have a red dot next to it. Both of these indicate that a test is failing within the REPL file. To get more information, you can click the dot on line 35 and select the triangle to view the source of the error as shown below. Using this detailed information you can better test and debug the code from within your Pact smart contract. Note To understand exactly what is failing and why, it helps to look through both the .pact and .repl files for more information. Take some time now to study the keyset example files as well as a few other examples to practice testing code and debugging errors.","title":"Pact Examples"},{"location":"beginner/testing-pact-code-in-the-sdk/#review","text":"Congratulations on completing this introduction to Testing Pact Code in the SDK ! In this tutorial, you learned both the basics of testing in the SDK and how to build your own REPL file. This is a great start to begin testing the smart contracts you build locally. From here, you can experiment with changing the .repl or .pact files to see how this changes the output in your terminal. Using this workflow, you can begin building and testing files however you would like.","title":"Review"},{"location":"beginner/welcome-to-pact/","text":"Welcome to Pact Welcome to the Pact smart contract programming language! In this tutorial, you\u2019ll learn about Pact, get introduced to its core features, and take your first steps toward becoming a Pact smart contract developer. Topics covered in this tutorial Introduction to Pact Pact Key Features Learn More About Pact The goal is to familiarize you with what Pact is, how its used, and some critical decisions that influenced the design of this new language. Key Takeaway Pact is the safest, most user-friendly language for smart contracts. It\u2019s designed for security and performance. It is turing incomplete, human readable, supports upgradable contracts, and formal verification to make high performant and secure smart contracts. Welcome to Pact Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Introduction to Pact Pact is an open-source programming language for writing smart contracts . It\u2019s designed from the ground up to support the unique challenges of developing solutions to run on a blockchain. Pact empowers developers to create robust and high-performance logic for transactions. It facilitates execution of mission-critical business operations quickly and effectively. Pact is designed with safety in mind. Its design is informed by existing approaches to smart contracts as well as stored procedure languages like SQL and LISP. Pact resembles a general-purpose, Turing-complete language. It includes LISP-like syntax, user functions, modules, and imperative style. Pact Smart Contracts Pact smart contracts contain three core elements: the code module, keysets, and tables. The table below briefly introduces each of these core elements. Module A module defines the logic of a smart contract. It contains functions, pact definitions, tables, and schemas. Keysets Includes relevant documentation links and allows you to load code into the REPL, refresh the repl, or deploy smart contract. Tables Tables store data generated by Pact modules. These tables have a \u201ckey-row\u201d structure and support schemas as well as a versioned, columnar history. Each of these elements support a wide range of functionality. This ensures that you have the tools you need to create robust solutions for real-world problems. Pact Key Features There are many valuable features make Pact such a safe and high-performance language. Here are a few that we\u2019ll focus on throughout this tutorial. Pact Key Features Turing Incomplete Human Readable Upgradable Contracts Formal Verification Type Inference Total Governance RDBMS Integration Pacts Turing Incomplete Pact contracts are Turing incomplete. A Turing complete language has the power to run any possible program. In some languages, Turing completeness is an extremely important feature. For smart contracts, it\u2019s an incredibly dangerous feature. For that reason, Pact is designed to be Turing incomplete which places deliberate constraints on its computational ability. This supports its design goal of \u201cjust enough\u201d power for transactional blockchain solutions and helps ensure the security of its smart contracts. The first restriction in Pact is that there is no unbounded looping or recursion. Pact detects recursion and fails immediately. Looping is also only supported in special circumstances. The key benefits of this are to reduce cost and improve performance. This feature makes some of the most infamous and costly bugs discovered in other platforms not even possible with Pact. For more information on this topic, see our blog post - Turing Completeness and Smart Contract Security . Human Readable Pact smart contracts are human readable. All Pact code gets stored as written in a human-readable form on the ledger. Pact smart contracts install directly onto the blockchain. This allows you to review the running code as it was written and be sure of exactly what it's doing. This is important because smart contracts solve business problems that require both technical and non-technical expertise. Building the best smart contract solution requires everyone to understand and contribute to the development of the smart contract. For that reason, Pact was built to be simple to read and write. This simplicity helps provide complete transparency for the logic within its smart contracts. This approach also encourages shorter programs. The code executes directly on the ledger where it can be read easily by anyone. As a result, Pact is easy to understand. For example, here\u2019s a \u201cHello World\u201d smart contract using Pact. ( module helloWorld admin-keyset ( defun hello ( name ) ( format Hello {}! [ name ])) ) ( hello world ) Without having learned anything about the Pact language, you can already start to see how it works. With these few simple lines of code, you see a fully functioning Pact \u201cHello World\u201d smart contract. Once written, smart contracts are deployed to a blockchain. In Pact, the code on the blockchain is the same as the code that was written. Maintaining this code means that no matter when you see the code it will always be as it was written. This allows you to understand the code so you can continue to moderate and improve your application over time. Upgradable Contracts Pact contracts are upgradable. Upgradable contracts allow you to revise and improve your smart contracts over time. This allows you to offer new features and fix bugs as you continue developing your smart contract. None of this is possible with other smart contract languages, and it\u2019s a powerful feature when building impactful applications for your business. Pact's tooling ecosystem further amplifies the simplicity of upgrading contracts. Compiler and runtime errors offer detailed information, with stack traces and function documentation to ensure you\u2019re making the best version of your smart contract. Pact\u2019s iterative development process is also supported by a feature-rich REPL helping you to improve and deploy new smart contracts rapidly. It includes features such as incremental transaction execution and environment and database inspection. Formal Verification Pact comes equipped with a powerful validation tool suite in the form of formal verification . Pact uses Z3, an open-source tool developed by Microsoft, to mathematically verify and test for bugs present in the code. This means that Pact allows smart contract authors to express, automatically check, and formally verify that their code does not contain any bugs. Formal verification is the same system used to protect mission-critical environments like nuclear power plants or air and space autopilot systems. You now have this same high level of security in every smart contract you write with Pact. Formal verification is a huge topic that\u2019s been covered well in the Kadena blog. See the blog post - Pact Formal Verification: Making Blockchain Smart Contracts Safer for more information on this topic. Type Inference Pact includes type inference. This feature makes it possible for code to be strongly-typed without declaring type information. It also has the added benefit of limiting run-time type enforcement. Developers can use a typecheck to add \u201cjust enough types\u201d. Typecheck eliminates warnings and only enforces types at runtime where needed. Total Governance Similar to RDBMS systems, Pact offers the benefit of total governance. This benefit allows changes to commit to the database only if the code runs successfully. Any errors roll back changes, abort execution, and avoid costly mistakes. RDBMS Integration Pact is also designed to allow direct integration with an industrial RDBMS. This design is helpful in cases that need efficient publication of historical data. Confidential Computing with \u201cPacts\u201d The Pact programming language comes from one of its key features, known as \u201cPacts\u201d. \u201cPacts\u201d solve a significant blockchain problem in privacy-preserving blockchains. To maintain privacy on a blockchain, participants can only run a subset of smart contracts. In these cases, the databases of each of the participants become disjointed. Pact solves this problem using coroutines. Coroutines are functions that can start and stop at critical points in a function\u2019s execution. These coroutines are called pacts. They define the steps to be executed by different entities as sequential transactions on the blockchain. Learn More The features described in this post are only a few of the crucial features that make Pact such a powerful language for writing smart contracts. There are many resources available to help you learn more about Pact. Here are a list of resources you can use to get started. Where to go next Join the Discord Channel for community discussion. Read The Pact Smart-Contract Language White Paper to learn more about the creation of Pact. Read the Pact documentation for a detailed look at everything the language offers. Follow the Pact GitHub page for the latest updates on Pact development. Ask questions on Stack Overflow using #pact-lang . Along with all of these resources, you can also continue this tutorial series. Throughout these tutorials, you\u2019ll learn all about Pact by walking through each of its features, building real-world applications, and exploring new ideas for yourself that take the language in directions no one has even thought of yet. Feel free to join the community and reach out if you have any questions. We\u2019re incredibly excited to help you start your journey as a Pact smart contract developer.","title":"1. Welcome to Pact"},{"location":"beginner/welcome-to-pact/#welcome-to-pact","text":"Welcome to the Pact smart contract programming language! In this tutorial, you\u2019ll learn about Pact, get introduced to its core features, and take your first steps toward becoming a Pact smart contract developer. Topics covered in this tutorial Introduction to Pact Pact Key Features Learn More About Pact The goal is to familiarize you with what Pact is, how its used, and some critical decisions that influenced the design of this new language. Key Takeaway Pact is the safest, most user-friendly language for smart contracts. It\u2019s designed for security and performance. It is turing incomplete, human readable, supports upgradable contracts, and formal verification to make high performant and secure smart contracts.","title":"Welcome to Pact"},{"location":"beginner/welcome-to-pact/#welcome-to-pact-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Welcome to Pact Tutorial"},{"location":"beginner/welcome-to-pact/#introduction-to-pact","text":"Pact is an open-source programming language for writing smart contracts . It\u2019s designed from the ground up to support the unique challenges of developing solutions to run on a blockchain. Pact empowers developers to create robust and high-performance logic for transactions. It facilitates execution of mission-critical business operations quickly and effectively. Pact is designed with safety in mind. Its design is informed by existing approaches to smart contracts as well as stored procedure languages like SQL and LISP. Pact resembles a general-purpose, Turing-complete language. It includes LISP-like syntax, user functions, modules, and imperative style.","title":"Introduction to Pact"},{"location":"beginner/welcome-to-pact/#pact-smart-contracts","text":"Pact smart contracts contain three core elements: the code module, keysets, and tables. The table below briefly introduces each of these core elements. Module A module defines the logic of a smart contract. It contains functions, pact definitions, tables, and schemas. Keysets Includes relevant documentation links and allows you to load code into the REPL, refresh the repl, or deploy smart contract. Tables Tables store data generated by Pact modules. These tables have a \u201ckey-row\u201d structure and support schemas as well as a versioned, columnar history. Each of these elements support a wide range of functionality. This ensures that you have the tools you need to create robust solutions for real-world problems.","title":"Pact Smart Contracts"},{"location":"beginner/welcome-to-pact/#pact-key-features","text":"There are many valuable features make Pact such a safe and high-performance language. Here are a few that we\u2019ll focus on throughout this tutorial. Pact Key Features Turing Incomplete Human Readable Upgradable Contracts Formal Verification Type Inference Total Governance RDBMS Integration Pacts","title":"Pact Key Features"},{"location":"beginner/welcome-to-pact/#turing-incomplete","text":"Pact contracts are Turing incomplete. A Turing complete language has the power to run any possible program. In some languages, Turing completeness is an extremely important feature. For smart contracts, it\u2019s an incredibly dangerous feature. For that reason, Pact is designed to be Turing incomplete which places deliberate constraints on its computational ability. This supports its design goal of \u201cjust enough\u201d power for transactional blockchain solutions and helps ensure the security of its smart contracts. The first restriction in Pact is that there is no unbounded looping or recursion. Pact detects recursion and fails immediately. Looping is also only supported in special circumstances. The key benefits of this are to reduce cost and improve performance. This feature makes some of the most infamous and costly bugs discovered in other platforms not even possible with Pact. For more information on this topic, see our blog post - Turing Completeness and Smart Contract Security .","title":"Turing Incomplete"},{"location":"beginner/welcome-to-pact/#human-readable","text":"Pact smart contracts are human readable. All Pact code gets stored as written in a human-readable form on the ledger. Pact smart contracts install directly onto the blockchain. This allows you to review the running code as it was written and be sure of exactly what it's doing. This is important because smart contracts solve business problems that require both technical and non-technical expertise. Building the best smart contract solution requires everyone to understand and contribute to the development of the smart contract. For that reason, Pact was built to be simple to read and write. This simplicity helps provide complete transparency for the logic within its smart contracts. This approach also encourages shorter programs. The code executes directly on the ledger where it can be read easily by anyone. As a result, Pact is easy to understand. For example, here\u2019s a \u201cHello World\u201d smart contract using Pact. ( module helloWorld admin-keyset ( defun hello ( name ) ( format Hello {}! [ name ])) ) ( hello world ) Without having learned anything about the Pact language, you can already start to see how it works. With these few simple lines of code, you see a fully functioning Pact \u201cHello World\u201d smart contract. Once written, smart contracts are deployed to a blockchain. In Pact, the code on the blockchain is the same as the code that was written. Maintaining this code means that no matter when you see the code it will always be as it was written. This allows you to understand the code so you can continue to moderate and improve your application over time.","title":"Human Readable"},{"location":"beginner/welcome-to-pact/#upgradable-contracts","text":"Pact contracts are upgradable. Upgradable contracts allow you to revise and improve your smart contracts over time. This allows you to offer new features and fix bugs as you continue developing your smart contract. None of this is possible with other smart contract languages, and it\u2019s a powerful feature when building impactful applications for your business. Pact's tooling ecosystem further amplifies the simplicity of upgrading contracts. Compiler and runtime errors offer detailed information, with stack traces and function documentation to ensure you\u2019re making the best version of your smart contract. Pact\u2019s iterative development process is also supported by a feature-rich REPL helping you to improve and deploy new smart contracts rapidly. It includes features such as incremental transaction execution and environment and database inspection.","title":"Upgradable Contracts"},{"location":"beginner/welcome-to-pact/#formal-verification","text":"Pact comes equipped with a powerful validation tool suite in the form of formal verification . Pact uses Z3, an open-source tool developed by Microsoft, to mathematically verify and test for bugs present in the code. This means that Pact allows smart contract authors to express, automatically check, and formally verify that their code does not contain any bugs. Formal verification is the same system used to protect mission-critical environments like nuclear power plants or air and space autopilot systems. You now have this same high level of security in every smart contract you write with Pact. Formal verification is a huge topic that\u2019s been covered well in the Kadena blog. See the blog post - Pact Formal Verification: Making Blockchain Smart Contracts Safer for more information on this topic.","title":"Formal Verification"},{"location":"beginner/welcome-to-pact/#type-inference","text":"Pact includes type inference. This feature makes it possible for code to be strongly-typed without declaring type information. It also has the added benefit of limiting run-time type enforcement. Developers can use a typecheck to add \u201cjust enough types\u201d. Typecheck eliminates warnings and only enforces types at runtime where needed.","title":"Type Inference"},{"location":"beginner/welcome-to-pact/#total-governance","text":"Similar to RDBMS systems, Pact offers the benefit of total governance. This benefit allows changes to commit to the database only if the code runs successfully. Any errors roll back changes, abort execution, and avoid costly mistakes.","title":"Total Governance"},{"location":"beginner/welcome-to-pact/#rdbms-integration","text":"Pact is also designed to allow direct integration with an industrial RDBMS. This design is helpful in cases that need efficient publication of historical data.","title":"RDBMS Integration"},{"location":"beginner/welcome-to-pact/#confidential-computing-with-pacts","text":"The Pact programming language comes from one of its key features, known as \u201cPacts\u201d. \u201cPacts\u201d solve a significant blockchain problem in privacy-preserving blockchains. To maintain privacy on a blockchain, participants can only run a subset of smart contracts. In these cases, the databases of each of the participants become disjointed. Pact solves this problem using coroutines. Coroutines are functions that can start and stop at critical points in a function\u2019s execution. These coroutines are called pacts. They define the steps to be executed by different entities as sequential transactions on the blockchain.","title":"Confidential Computing with \u201cPacts\u201d"},{"location":"beginner/welcome-to-pact/#learn-more","text":"The features described in this post are only a few of the crucial features that make Pact such a powerful language for writing smart contracts. There are many resources available to help you learn more about Pact. Here are a list of resources you can use to get started. Where to go next Join the Discord Channel for community discussion. Read The Pact Smart-Contract Language White Paper to learn more about the creation of Pact. Read the Pact documentation for a detailed look at everything the language offers. Follow the Pact GitHub page for the latest updates on Pact development. Ask questions on Stack Overflow using #pact-lang . Along with all of these resources, you can also continue this tutorial series. Throughout these tutorials, you\u2019ll learn all about Pact by walking through each of its features, building real-world applications, and exploring new ideas for yourself that take the language in directions no one has even thought of yet. Feel free to join the community and reach out if you have any questions. We\u2019re incredibly excited to help you start your journey as a Pact smart contract developer.","title":"Learn More"},{"location":"intermediate/coming-soon/","text":"Coming Soon We're working hard to bring you more tutorials! These intermediate Pact Tutorials are currently under development. Stay in touch while you wait Subscribe to our YouTube channel to access the latest Pact tutorials. Join the Discord Channel for community discussion Follow the Pact GitHub page for the latest updates on Pact development Ask questions about Pact on Stack Overflow using #pact-lang Get the latest Kadena updates and workshop announcements from our Newsletter or on Twitter @kadena_io View our Pact Beginner Tutorials to get an overview of the Pact language basics.","title":"Coming Soon"},{"location":"intermediate/coming-soon/#coming-soon","text":"We're working hard to bring you more tutorials! These intermediate Pact Tutorials are currently under development.","title":"Coming Soon"},{"location":"intermediate/coming-soon/#stay-in-touch-while-you-wait","text":"Subscribe to our YouTube channel to access the latest Pact tutorials. Join the Discord Channel for community discussion Follow the Pact GitHub page for the latest updates on Pact development Ask questions about Pact on Stack Overflow using #pact-lang Get the latest Kadena updates and workshop announcements from our Newsletter or on Twitter @kadena_io View our Pact Beginner Tutorials to get an overview of the Pact language basics.","title":"Stay in touch while you wait"},{"location":"intermediate/deploy-local-server/","text":"Set up and Deploy a Local Test Server Welcome to this introduction to the Pact local Test server! The goal of this tutorial is to help you run and deploy a working Pact test server locally. Topics covered in this tutorial Install Dependencies Package.json YAML API Request Endpoint Types Exercise: Write a YAML file In this tutorial you will go into depth on the pact-lang-api including topics like yaml API requests and endpoint types. Aside from letting you explore even more of pact\u2019s functionality, it puts you in a good position to complete our next tutorial, Pact and Javascript. In that tutorial you bring all the pieces together and get your first look at developing your first full stack blockchain application with pact. Set up and Deploy a Local Test Server Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Install Dependencies Pact and the pact-lang-api are required to successfully complete this tutorial. If you haven\u2019t already installed these, follow the steps below to install each of them on your device. Install Pact First, install Pact on your computer using homebrew by running the following code in your terminal. brew install kadena-io/pact/pact Note For more information on installing Pact, you can view the Pact GitHub page . You can also view 8. Atom SDK from the Pact Beginner tutorial series for more information. Install pact-lang-API Install the pact-lang-api by running the following code in your terminal. npm install pact-lang-api Note You can view more about installing the Pact Lang API here . Further details about the pact-lang-api are here . Project Overview To get started, here is a brief overview of the project you will build. The goal is to run a Pact server locally that you can communicate with using various pact-lang-api commands from your terminal. Starting in your terminal, you will create a project directory along with an example.yaml and a config.yaml file to store your code. The example.yaml file will include the program you are trying to run, and the config.yaml file will specify things such as the port, which will be on 8080 , and the path to the log folder that will log the data. Next, you will populate each of the yaml files, create the log folder, and run the Pact server . After the server is running you will need a way to send the code in the example.yaml file to the pact server. This is done by first converting the code into JSON, then by sending this json to the server using a variety of commands including send, local, listen, or poll depending on your needs. I\u2019ll show you each of these commands in more detail as we go through the tutorial. For now, this hopefully helped you organize some of your thoughts around what we are planning to build. Let\u2019s start building! Project Demonstration To begin your project, open your terminal and navigate to your preferred project directory. Within that directory, create a new directory named deploy-tutorial to house your project files. mkdir deploy-tutorial Create Project files Navigate into the folder and create both a config.yaml file and an example.yaml file. cd deploy-tutorial touch config.yaml touch example.yaml Populate Project Files The config.yaml file follows a standard format, and you can find the code for this here . It is also included below. Copy the code below into your config.yaml and save the file. # Config file for pact http server. Launch with `pact -s config.yaml` # HTTP server port port: 8080 # directory for HTTP logs logDir: log # persistence directory persistDir: log # SQLite pragmas for pact back-end pragmas: [] # verbose: provide log output verbose: True Next, populate the example.yaml file with the example provided below. This code is also included in the Pact language documentation here . Copy this text, paste it into your example.yaml file, and save the file. code: (+ 1 2) data: name: Stuart language: Pact keyPairs: - public: ba54b224d1924dd98403f5c751abdd10de6cd81b0121800bf7bdbdcfaec7388d secret: 8693e641ae2bbe9ea802c736f42027b03f86afe63cae315e7169c9c496c17332 Config.yaml Details Navigate back to the config.yaml file to view the details of this code. Here you can see 5 fields. HTTP Server The HTTP server port specifies 8080. This can change depending on which port you need but we often use 8080 in our examples so you can leave this as it is for now. Logdir/PersistDir The directory and persistence directory for http logs states where the applications data will be stored. This specifies a folder location that you will create for yourself shortly. Sqlite Pragmas The SQLite pragmas. Verbose Specifies whether or not you want to provide log output using true or false. Example.yaml Details Navigate back to the example.yaml file to view the details of this code. Here you can see the code that will be running on the Pact server. In this case it includes the code 1 + 2 , the name Stuart , and the language Pact . You can also view the keyPairs for this code. This code is formatted using the Request YAML file format specified in the Pact language documentation here . code : Transaction code codeFile : Transaction code file data : JSON transaction data dataFile : JSON transaction data file keyPairs : list of key pairs for signing ( use pact - g to generate ): [ public : base 16 public key secret : base 16 secret key ] nonce : optional request nonce , will use current time if not provided from : entity name for addressing private messages to : entity names for addressing private messages Here you\u2019ll see that the format includes keys such as code, codefile, data, datafile, keypairs, nonce, from, and to. Each of these have their own use case but only the code and keypairs are required. Looking at your example.yaml file, you can see that these 2 keys are included. Note Some things to note are that if you use the data key it defaults to an empty object, and nonce defaults to the current date and time. Other details about each of these keys can be found in the documentation . Create Log folder Having seen the code, you can now focus on working from the terminal. To start, you\u2019ll need to create the log folder that was specified in the config.yaml file as the log directory. From your terminal, create a log folder in your project directory. mkdir log Next, check the directory to make sure you\u2019re all set up with your log and yaml files. ls Finally, run pact -s (-s stands for serve) and provide it the config.yaml file. pact -s config.yaml After running this you can see that you initialized a pact server and that it\u2019s currently running on port 8080. You can now run API calls on the server. Endpoint types The Pact server contains multiple endpoint types that you can access using the pact-lang-api. Send /send takes in cmd object and returns tx hash Listen /listen takes in a hash and returns tx result. Poll /poll is similar to listen but works with multiple hashes and returns multiple tx results. Local /local takes in cmd object with code that queries from blockchain. It only runs in local server and does not impact the blockchain - and returns tx result. To get more familiar with each of these endpoints, we can run each of them from our terminal now. /send demo Now that the Pact server is running, you use your terminal and the pact-lang-api to /send code to the Pact endpoint. /send takes in cmd object and returns tx hash. To run this command you need to do 2 things. First, you will format the existing example.yaml file into JSON. Next, you will send it to the Pact end point. JSON Format In a new terminal window within the same directory, run the following code. pact -a example.yaml This line formats the example file into type JSON. After running this command, you should see the JSON data appear in the terminal. Looking at the data you\u2019ll see the hash, the signature, the payload and a few other details. Something you may recognize is that within the payload you\u2019ll see the data including name Stuart , language Pact , and the code (+ 1 2) . Note By default -a formats the YAML file into API requests for the /send endpoint. Adding the -l flag after the command formats the api request for the local endpoint. Now that you have the data in the format you need you can send it to the REST endpoint. Use /send To send data to the REST endpoint, you need to use a curl command with a header of content type application json along with server and endpoint. Run the following command in your terminal to /send data to the REST endpoint. pact -a example.yaml | curl -H Content-Type: application/json -d @- http://localhost:8080/api/v1/send This command starts with the code you ran previously and adds on a few important details. First, it states the content type as application/json . It then sets the destination of the API call. In this case it sends an API call to the localhost on port 8080/ . Note By running this full command you\u2019re both converting the file to JSON and making an API request call to the /send endpoint. After running this command, you will receive request key as the response. This is the hash value of the command you sent to the REST endpoint. { requestKeys :[ 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 ]} Note: The hash value shown above is different than the one you will receive. /poll demo Using the pact-lang-api, you can also run code and return the result of running that code. This is done using another command, known as /poll . /poll is similar to listen but works with multiple hashes and returns multiple tx results. Run the following command in your terminal. Note that you will need to include the requestKeys by pasting the key you received when running /send into the space labeled . curl -H Content-Type: application/json -d { requestKeys :[ REQUEST-KEY ]} -X POST http://localhost:8080/api/v1/poll The code you run should look end up looking similar to the command shown below. curl -H Content-Type: application/json -d { requestKeys :[ 18_CToCa_JXDvOPIHF-CceDw9gCpEMbpJKgLmot7I9M ]} -X POST http://localhost:8080/api/v1/poll Note As you may have noticed, you don\u2019t need to convert the yaml file into JSON as you did when using /send. This is because you are sending the request key which is already in JSON format. This command will return the result of the request made in the /send demo as shown below. { 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 :{ gas :0, result :{ status : success , data :3}, reqKey : 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 , logs : wsATyGqckuIvlm89hhd2j4t6RMkCrcwJe_oeCYr7Th8 , metaData :null, continuation :null, txId :1}} /listen demo Listen is similar to poll in that it can request the result of a transaction. /listen takes in a hash and returns tx result. The difference between these commands is subtle but important. You would use /listen when working with a single hash to return the result, and /poll when working with multiple hashes to return multiple transaction results. The format of a /listen command looks like this. curl -H Content-Type: application/json -d { listen : pdjiSC6IN_enbolWiuLVynXYVv1os8E9YfptltXjckU } -X POST http://localhost:8080/api/v1/listen This command returns the result of the request made in the /send demo. { gas :0, result :{ status : success , data :3}, reqKey : 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 , logs : wsATyGqckuIvlm89hhd2j4t6RMkCrcwJe_oeCYr7Th8 , metaData :null, continuation :null, txId :1} Why /listen? As you may have noticed, /listen is similar /poll . The difference here is that you are listening to the hash value and that you are making an API request to the listen endpoint. What you\u2019ll get back, like with poll, is the result of running the code, which is again 3. Note /listen and /poll are very similar in this case but use /listen in cases that you only need to take in the result of a single hash and return a single transaction result. Use /poll if you need multiple hash values and multiple results. /local demo The final command you can use to access the Pact REST endpoint is /local. /local takes in cmd object with code that queries from blockchain - only runs in local server and does not impact the blockchain - and returns tx result. The format of a /local command looks like this. pact -a example.yaml -l | curl -H Content-Type: application/json -d @- http://localhost:8080/api/v1/local This command is structured very similar to send. It converts the exampl.yaml file to JSON then makes an API request to the local endpoint. When running this, you\u2019ll see that it returns data along with the request key. Why /local? /local takes in the cmd object with code that queries from blockchain. It only runs in the local server and does not impact the blockchain when returning tx results. This is helpful to use when running a function that doesn\u2019t need to touch the blockchain. This is different than /send , which you would use when changing data in the blockchain, or when deploying contracts. Local is a great choice when you are working with simple functions or fetching data from the blockchain. EXERCISE: Write a YAML File At this point you hopefully have a local Pact server running and have some practice with running commands to access the variety of endpoints available to you. We\u2019ve set up a challenge to help you get even more familiar with setting up YAML files for your local pact server deployments. On the Kadena GitHub page, there is a repo named pact-lang.org-code found here that includes the code samples and challenges used throughout our tutorials. You can clone this folder to get started with this challenge. git clone https://github.com/kadena-io/pact-lang.org-code.git From there navigate into the folder intermediate set-up-and-deploy challenge . Your challenge is to acclimate yourself to the project structure and use what you\u2019ve learned to both deploy the smart contract and call the helloWorld function. Review Here\u2019s a quick recap of what you accomplished throughout this tutorial. Starting in your terminal, you created a project directory along with an example.yaml and a config.yaml file to store your code. You then populated each of these files with their code. You then created a log folder that holds the data from the Pact server and then ran the server on port 8080 . After the server was running you converted the example.yaml file into JSON, then used curl commands to send it to the Pact server; either to store the data or to read the result of running it\u2019s code. And that\u2019s everything you need to know to set up and deploy your local test server. Good luck with your challenge, and when you\u2019re ready, I\u2019ll see you in the next tutorial.","title":"1. Deploy to a Local Server"},{"location":"intermediate/deploy-local-server/#set-up-and-deploy-a-local-test-server","text":"Welcome to this introduction to the Pact local Test server! The goal of this tutorial is to help you run and deploy a working Pact test server locally. Topics covered in this tutorial Install Dependencies Package.json YAML API Request Endpoint Types Exercise: Write a YAML file In this tutorial you will go into depth on the pact-lang-api including topics like yaml API requests and endpoint types. Aside from letting you explore even more of pact\u2019s functionality, it puts you in a good position to complete our next tutorial, Pact and Javascript. In that tutorial you bring all the pieces together and get your first look at developing your first full stack blockchain application with pact.","title":"Set up and Deploy a Local Test Server"},{"location":"intermediate/deploy-local-server/#set-up-and-deploy-a-local-test-server-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Set up and Deploy a Local Test Server Tutorial"},{"location":"intermediate/deploy-local-server/#install-dependencies","text":"Pact and the pact-lang-api are required to successfully complete this tutorial. If you haven\u2019t already installed these, follow the steps below to install each of them on your device.","title":"Install Dependencies"},{"location":"intermediate/deploy-local-server/#install-pact","text":"First, install Pact on your computer using homebrew by running the following code in your terminal. brew install kadena-io/pact/pact Note For more information on installing Pact, you can view the Pact GitHub page . You can also view 8. Atom SDK from the Pact Beginner tutorial series for more information.","title":"Install Pact"},{"location":"intermediate/deploy-local-server/#install-pact-lang-api","text":"Install the pact-lang-api by running the following code in your terminal. npm install pact-lang-api Note You can view more about installing the Pact Lang API here . Further details about the pact-lang-api are here .","title":"Install pact-lang-API"},{"location":"intermediate/deploy-local-server/#project-overview","text":"To get started, here is a brief overview of the project you will build. The goal is to run a Pact server locally that you can communicate with using various pact-lang-api commands from your terminal. Starting in your terminal, you will create a project directory along with an example.yaml and a config.yaml file to store your code. The example.yaml file will include the program you are trying to run, and the config.yaml file will specify things such as the port, which will be on 8080 , and the path to the log folder that will log the data. Next, you will populate each of the yaml files, create the log folder, and run the Pact server . After the server is running you will need a way to send the code in the example.yaml file to the pact server. This is done by first converting the code into JSON, then by sending this json to the server using a variety of commands including send, local, listen, or poll depending on your needs. I\u2019ll show you each of these commands in more detail as we go through the tutorial. For now, this hopefully helped you organize some of your thoughts around what we are planning to build. Let\u2019s start building!","title":"Project Overview"},{"location":"intermediate/deploy-local-server/#project-demonstration","text":"To begin your project, open your terminal and navigate to your preferred project directory. Within that directory, create a new directory named deploy-tutorial to house your project files. mkdir deploy-tutorial","title":"Project Demonstration"},{"location":"intermediate/deploy-local-server/#create-project-files","text":"Navigate into the folder and create both a config.yaml file and an example.yaml file. cd deploy-tutorial touch config.yaml touch example.yaml","title":"Create Project files"},{"location":"intermediate/deploy-local-server/#populate-project-files","text":"The config.yaml file follows a standard format, and you can find the code for this here . It is also included below. Copy the code below into your config.yaml and save the file. # Config file for pact http server. Launch with `pact -s config.yaml` # HTTP server port port: 8080 # directory for HTTP logs logDir: log # persistence directory persistDir: log # SQLite pragmas for pact back-end pragmas: [] # verbose: provide log output verbose: True Next, populate the example.yaml file with the example provided below. This code is also included in the Pact language documentation here . Copy this text, paste it into your example.yaml file, and save the file. code: (+ 1 2) data: name: Stuart language: Pact keyPairs: - public: ba54b224d1924dd98403f5c751abdd10de6cd81b0121800bf7bdbdcfaec7388d secret: 8693e641ae2bbe9ea802c736f42027b03f86afe63cae315e7169c9c496c17332","title":"Populate Project Files"},{"location":"intermediate/deploy-local-server/#configyaml-details","text":"Navigate back to the config.yaml file to view the details of this code. Here you can see 5 fields. HTTP Server The HTTP server port specifies 8080. This can change depending on which port you need but we often use 8080 in our examples so you can leave this as it is for now. Logdir/PersistDir The directory and persistence directory for http logs states where the applications data will be stored. This specifies a folder location that you will create for yourself shortly. Sqlite Pragmas The SQLite pragmas. Verbose Specifies whether or not you want to provide log output using true or false.","title":"Config.yaml Details"},{"location":"intermediate/deploy-local-server/#exampleyaml-details","text":"Navigate back to the example.yaml file to view the details of this code. Here you can see the code that will be running on the Pact server. In this case it includes the code 1 + 2 , the name Stuart , and the language Pact . You can also view the keyPairs for this code. This code is formatted using the Request YAML file format specified in the Pact language documentation here . code : Transaction code codeFile : Transaction code file data : JSON transaction data dataFile : JSON transaction data file keyPairs : list of key pairs for signing ( use pact - g to generate ): [ public : base 16 public key secret : base 16 secret key ] nonce : optional request nonce , will use current time if not provided from : entity name for addressing private messages to : entity names for addressing private messages Here you\u2019ll see that the format includes keys such as code, codefile, data, datafile, keypairs, nonce, from, and to. Each of these have their own use case but only the code and keypairs are required. Looking at your example.yaml file, you can see that these 2 keys are included. Note Some things to note are that if you use the data key it defaults to an empty object, and nonce defaults to the current date and time. Other details about each of these keys can be found in the documentation .","title":"Example.yaml Details"},{"location":"intermediate/deploy-local-server/#create-log-folder","text":"Having seen the code, you can now focus on working from the terminal. To start, you\u2019ll need to create the log folder that was specified in the config.yaml file as the log directory. From your terminal, create a log folder in your project directory. mkdir log Next, check the directory to make sure you\u2019re all set up with your log and yaml files. ls Finally, run pact -s (-s stands for serve) and provide it the config.yaml file. pact -s config.yaml After running this you can see that you initialized a pact server and that it\u2019s currently running on port 8080. You can now run API calls on the server.","title":"Create Log folder"},{"location":"intermediate/deploy-local-server/#endpoint-types","text":"The Pact server contains multiple endpoint types that you can access using the pact-lang-api. Send /send takes in cmd object and returns tx hash Listen /listen takes in a hash and returns tx result. Poll /poll is similar to listen but works with multiple hashes and returns multiple tx results. Local /local takes in cmd object with code that queries from blockchain. It only runs in local server and does not impact the blockchain - and returns tx result. To get more familiar with each of these endpoints, we can run each of them from our terminal now.","title":"Endpoint types"},{"location":"intermediate/deploy-local-server/#send-demo","text":"Now that the Pact server is running, you use your terminal and the pact-lang-api to /send code to the Pact endpoint. /send takes in cmd object and returns tx hash. To run this command you need to do 2 things. First, you will format the existing example.yaml file into JSON. Next, you will send it to the Pact end point.","title":"/send demo"},{"location":"intermediate/deploy-local-server/#json-format","text":"In a new terminal window within the same directory, run the following code. pact -a example.yaml This line formats the example file into type JSON. After running this command, you should see the JSON data appear in the terminal. Looking at the data you\u2019ll see the hash, the signature, the payload and a few other details. Something you may recognize is that within the payload you\u2019ll see the data including name Stuart , language Pact , and the code (+ 1 2) . Note By default -a formats the YAML file into API requests for the /send endpoint. Adding the -l flag after the command formats the api request for the local endpoint. Now that you have the data in the format you need you can send it to the REST endpoint.","title":"JSON Format"},{"location":"intermediate/deploy-local-server/#use-send","text":"To send data to the REST endpoint, you need to use a curl command with a header of content type application json along with server and endpoint. Run the following command in your terminal to /send data to the REST endpoint. pact -a example.yaml | curl -H Content-Type: application/json -d @- http://localhost:8080/api/v1/send This command starts with the code you ran previously and adds on a few important details. First, it states the content type as application/json . It then sets the destination of the API call. In this case it sends an API call to the localhost on port 8080/ . Note By running this full command you\u2019re both converting the file to JSON and making an API request call to the /send endpoint. After running this command, you will receive request key as the response. This is the hash value of the command you sent to the REST endpoint. { requestKeys :[ 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 ]} Note: The hash value shown above is different than the one you will receive.","title":"Use /send"},{"location":"intermediate/deploy-local-server/#poll-demo","text":"Using the pact-lang-api, you can also run code and return the result of running that code. This is done using another command, known as /poll . /poll is similar to listen but works with multiple hashes and returns multiple tx results. Run the following command in your terminal. Note that you will need to include the requestKeys by pasting the key you received when running /send into the space labeled . curl -H Content-Type: application/json -d { requestKeys :[ REQUEST-KEY ]} -X POST http://localhost:8080/api/v1/poll The code you run should look end up looking similar to the command shown below. curl -H Content-Type: application/json -d { requestKeys :[ 18_CToCa_JXDvOPIHF-CceDw9gCpEMbpJKgLmot7I9M ]} -X POST http://localhost:8080/api/v1/poll Note As you may have noticed, you don\u2019t need to convert the yaml file into JSON as you did when using /send. This is because you are sending the request key which is already in JSON format. This command will return the result of the request made in the /send demo as shown below. { 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 :{ gas :0, result :{ status : success , data :3}, reqKey : 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 , logs : wsATyGqckuIvlm89hhd2j4t6RMkCrcwJe_oeCYr7Th8 , metaData :null, continuation :null, txId :1}}","title":"/poll demo"},{"location":"intermediate/deploy-local-server/#listen-demo","text":"Listen is similar to poll in that it can request the result of a transaction. /listen takes in a hash and returns tx result. The difference between these commands is subtle but important. You would use /listen when working with a single hash to return the result, and /poll when working with multiple hashes to return multiple transaction results. The format of a /listen command looks like this. curl -H Content-Type: application/json -d { listen : pdjiSC6IN_enbolWiuLVynXYVv1os8E9YfptltXjckU } -X POST http://localhost:8080/api/v1/listen This command returns the result of the request made in the /send demo. { gas :0, result :{ status : success , data :3}, reqKey : 5Fu1m0crUk7MKL0Yyjg3gMPGcKuC0U4dx5Z5kBEQUz8 , logs : wsATyGqckuIvlm89hhd2j4t6RMkCrcwJe_oeCYr7Th8 , metaData :null, continuation :null, txId :1}","title":"/listen demo"},{"location":"intermediate/deploy-local-server/#why-listen","text":"As you may have noticed, /listen is similar /poll . The difference here is that you are listening to the hash value and that you are making an API request to the listen endpoint. What you\u2019ll get back, like with poll, is the result of running the code, which is again 3. Note /listen and /poll are very similar in this case but use /listen in cases that you only need to take in the result of a single hash and return a single transaction result. Use /poll if you need multiple hash values and multiple results.","title":"Why /listen?"},{"location":"intermediate/deploy-local-server/#local-demo","text":"The final command you can use to access the Pact REST endpoint is /local. /local takes in cmd object with code that queries from blockchain - only runs in local server and does not impact the blockchain - and returns tx result. The format of a /local command looks like this. pact -a example.yaml -l | curl -H Content-Type: application/json -d @- http://localhost:8080/api/v1/local This command is structured very similar to send. It converts the exampl.yaml file to JSON then makes an API request to the local endpoint. When running this, you\u2019ll see that it returns data along with the request key.","title":"/local demo"},{"location":"intermediate/deploy-local-server/#why-local","text":"/local takes in the cmd object with code that queries from blockchain. It only runs in the local server and does not impact the blockchain when returning tx results. This is helpful to use when running a function that doesn\u2019t need to touch the blockchain. This is different than /send , which you would use when changing data in the blockchain, or when deploying contracts. Local is a great choice when you are working with simple functions or fetching data from the blockchain.","title":"Why /local?"},{"location":"intermediate/deploy-local-server/#exercise-write-a-yaml-file","text":"At this point you hopefully have a local Pact server running and have some practice with running commands to access the variety of endpoints available to you. We\u2019ve set up a challenge to help you get even more familiar with setting up YAML files for your local pact server deployments. On the Kadena GitHub page, there is a repo named pact-lang.org-code found here that includes the code samples and challenges used throughout our tutorials. You can clone this folder to get started with this challenge. git clone https://github.com/kadena-io/pact-lang.org-code.git From there navigate into the folder intermediate set-up-and-deploy challenge . Your challenge is to acclimate yourself to the project structure and use what you\u2019ve learned to both deploy the smart contract and call the helloWorld function.","title":"EXERCISE: Write a YAML File"},{"location":"intermediate/deploy-local-server/#review","text":"Here\u2019s a quick recap of what you accomplished throughout this tutorial. Starting in your terminal, you created a project directory along with an example.yaml and a config.yaml file to store your code. You then populated each of these files with their code. You then created a log folder that holds the data from the Pact server and then ran the server on port 8080 . After the server was running you converted the example.yaml file into JSON, then used curl commands to send it to the Pact server; either to store the data or to read the result of running it\u2019s code. And that\u2019s everything you need to know to set up and deploy your local test server. Good luck with your challenge, and when you\u2019re ready, I\u2019ll see you in the next tutorial.","title":"Review"},{"location":"intermediate/interfaces-with-pact/","text":"Interfaces with Pact Welcome to this introduction to Interfaces with Pact ! Throughout this tutorial you\u2019ll learn why interfaces are valuable and how to implement them with Pact. Topics covered in this tutorial Introduction to Interfaces Interfaces and Modules Interface Declaration Working with Interfaces Declaring Models in an Interface Coin Contract Demo Key Takeaway Interfaces allow you to provide access to the functions within one module to another module. They are defined using the interface statement and can be accessed from within modules using the implement statement. Interfaces with Pact Subscribe to our YouTube channel to access the latest Pact tutorials. Introduction to Interfaces Before getting into interfaces with Pact, I\u2019ll briefly review what interfaces are in general. Interfaces are the point where two systems meet and interact. This definition includes people, organizations, electricity, or any other interactions you can think of. For example, a light socket is a type of interface that gives you access to electricity. In programming, interfaces work similarly, but are used to allow interaction between programs. This isn\u2019t specific to Pact, so if you are familiar with other programming languages, you have likely come across this idea already. If you are unfamiliar with interfaces, you may have at least a basic understanding of what an API is (Application Programming Interface). As you might know, many programs have APIs that allow you to build programs that give access to specific data. For example, you could use Facebook APIs, Twitter APIs, Google APIs, or any other API to add functionality to your application that you wouldn\u2019t have otherwise. Aside from that, you may be familiar with UI, a User Interface. These types of interfaces give users access to elements of a program without using code at all. There are many types of interfaces that have both high level and low level use cases in programming. In this tutorial, you\u2019ll focus specifically on building interfaces using Pact that allow users to create interactions between modules. Interfaces and Modules An interface, as defined in Pact, is a collection of models used for formal verification, constant definitions, and typed function signatures. They contain API specifications and data definitions for smart contracts. They include each of the following elements: Function Specifications Constant Values Models Using these three elements, you can both declare and create interface. Declare the Interface To declare an interface, use the statement interface followed by the name of the interface. ( interface my-interface ;; interface code goes here ) Import a module inside an interface You can also import definitions from modules with a use statement. Import Module with Use Use this module from within an interface. ( interface example-interface ( use example-module ) ;; interface code goes here ) ) This allows for some interesting functionality within your interface. Access the Interface from a Module After declaring an interface, you can access if from a module using the implements statement. ( module my-module ( read-keyset my-keyset ) ( implements my-interface ) ;; module code goes here ) Modules and Interfaces Interfaces allow modules to communicate information between one another. Modules and interfaces look very similar to one another, making them simple to program, but there are some key distinctions and ideas that are worth noting. Interfaces Cannot be Upgraded Interfaces cannot be upgraded and no function implementations exist in an interface aside from constant data. Constant Imports The constants of an interface can be imported with use . Use is not the same as implements and you\u2019ll see some of these important differences throughout the demonstration. Conflicting Module Functions Multiple interfaces may be implemented by a single module. If there are conflicting function names among multiple interfaces, then the two interfaces are incompatible. In these cases you need to either inline the code you want, or redefine the interfaces to resolve the conflict. Unique Interface Names Interface names must be unique within a namespace. Accessing Interfaces Constants declared in an interface can be accessed directly by their fully qualified name. interface.const This makes it so that they do not have the same naming constraints as function signatures. Module Declarations Additionally, interfaces may make use of module declarations. This allows interfaces to import members of other modules. For that reason, interface signatures can be defined in terms of table types defined in an imported module. Declare and Implement an Interface Using the basic ideas described above, you can create more complex interactions by defining interfaces modules along with the implements and use statements . Declare an Interface To start, the example below declares an interface named my-interface including a function named hello-number . ( interface my-interface ( defun hello-number :string ( number :integer ) @ doc Return the string \\ Hello, $number!\\ when given a string ) ( defconst SOME_CONSTANT 3 ) ) Implement the Interface Next, define a module that implements my-interface and makes use of the hello-number function. ( module my-module ( read-keyset my-keyset ) ( implements my-interface ) ( defun hello-number :string ( number :integer ) ( format Hello, {}! [ number ])) ( defun square-three () ( * my-interface.SOME_CONSTANT my-interface.SOME_CONSTANT )) ) Notice also, that within the module, a function named square-three is defined. This function makes use of a constant defined within the interface named SOME_CONSTANT having imported it with the use statement.. Declaring Models in an Interface Formal verification is implemented at multiple levels within an interface in order to provide an extra level of security. Similar to modules, models may be declared within the body or function level of an interface. Models may be declared either within the body of the interface or at the function level in the same way that one would declare them in a module, with the exception of schema invariants. ( interface coin-sig Coin Contract Abstract Interface Example ( use acct-module ) ( defun transfer :string ( from :string to :string amount :integer ) @ doc Transfer money between accounts @ model [( property ( row-enforced accounts ks from )) ( property ( amount 0 )) ( property ( = 0 ( column-delta accounts balance ))) ] ) ) You can't declare tables or schema in an interface, because there's no abstract \"table\" or \"schema\" that you can define or \"implement\" in a meaningful way. It also couples a module too tightly with a particular interface. You can, however, import a module and use the declared tables and schema in that module as types in the function signatures, or in models. Models that you specify in an interface will be added with additional models you declare in a module. This allows you to layer more constraints on as you wish per your business needs in your module. Coin Contract Demo For the rest of this tutorial, you\u2019ll take a closer look interfaces using a version of the coin contract from previous tutorials. You\u2019ll create an interface to the coin contract that allows its functions to be accessed by other modules. Chainweb Repo Rather than using the tutorials GitHub repo like previously, you\u2019ll find this project within the chainweb-node repo here . Chainweb is Kadena\u2019s public blockchain platform. We haven\u2019t discussed this in previous tutorials, but we will cover this in more detail in later tutorials. You don\u2019t need to know what this is for this tutorial, but if you\u2019d like, you can learn more about the basics of Chainweb here . To get started with the demonstration, clone the project and open it in Atom. Clone the project git clone https://github.com/kadena-io/chainweb-node.git Enter the Project File cd chainweb-node/pact/coin-contract/coin-sig.pact Open in Atom atom . Project Visual Overview Looking at the interface, you\u2019ll see that it includes 5 functions. These functions contain inputs and models allowing for the basic functionality of managing coins to be used by other modules. Let\u2019s take a closer look at this code to get a better idea of how it works. Define the Interface First, define an interface using the interface statement followed by the name of the interface. ( interface coin-sig ;; CODE GOES HERE ) Within this interface, you\u2019ll create each of the functions. Function: Create Account Create-account takes inputs account and guard . ( defun create-account :string ( account :string guard :guard ) @ doc Create an account for ACCOUNT, with ACCOUNT as a function of GUARD @ model [ ( property ( not ( = account ))) ] ) Within this function, a model is defined checking that the account is not an empty string. This will ensure that each account is given a name. Function: Transfer Transfer allows users to transfer value between a sender and a receiver. ( defun transfer :string ( sender :string receiver :string amount :decimal ) @ doc Transfer between accounts SENDER and RECEIVER on the same chain. \\ \\This fails if both accounts do not exist. Create-on-transfer can be \\ \\handled by sending in a create command in the same tx. @ model [ ( property ( amount 0.0 )) ( property ( not ( = sender receiver ))) ] ) It checks that the amount is greater than 0 and that the sender is not also the receiver before completing the transfer. The function transfer transfers coins to a known account. If that account doesn\u2019t exist then the coins end up lost in the abyss with no way to retrieve them. For that reason, you may want to instead use the following function, transfer and create. Function: Transfer and Create ( defun transfer-and-create :string ( sender :string receiver :string receiver-guard :guard amount :decimal ) @ doc Transfer between accounts SENDER and RECEIVER on the same chain. \\ \\This fails if SENDER does not exist or RECEIVER exists and RECEIVER-GUARD does not match with the guard in RECEIVER\u2019s account \\Create-on-transfer can be \\ \\handled by sending in a create command in the same tx. @ model [ ( property ( amount 0.0 )) ( property ( not ( = sender receiver ))) ] ) Transfer and create supplies a guard for the receiving account. If the account exists, it checks to see if the guards match. If they do, it will complete the transfer, otherwise the transaction will fail. If the account does not exist, then the account will be created and the coin will be transferred to the new account. Safe vs Unsafe Transfers The previous functions distinguish between \"unsafe\" and \u201csafe\u201d transfers. With unsafe transfers, your tokens could potentially get lost in the crypto abyss. With \u201csafe\u201d transfers, your tokens always end up in some account,otherwise the transaction fails and you are refunded. Function: Account Balance The function account-balance takes an account string and returns the balance of the account. ( defun account-balance :decimal ( account :string ) @ doc Query user account ACCOUNT balance ) Function: Coinbase Coinbase allows users to mint tokens to an address by defining the address, address-guard, and amount. ( defun coinbase :string ( address :string address-guard :guard amount :decimal ) @ doc Mint some number of tokens and allocate them to some address @ model [ ( property ( amount 0.0 )) ( property ( not ( = address ))) ] ) What does Coinbase mean? The Coinbase transaction , or Generation transaction , is a special transaction . It specifically refers to a transaction that creates coins from nothing. In certain blockchain protocols, it is the reward that miner gets for successfully mining a block. It\u2019s also the name of a popular digital asset exchange company named Coinbase. Having created each of these functions within the interface, you can now create modules that use them for whatever purpose they might serve within your application. Review That wraps up this introduction to Interfaces with Pact! Throughout this tutorial you learned why interfaces are valuable and how to implement them with Pact. We introduced interfaces and described how they are different than modules. From there you learned how to declare modules, how to work with interfaces, and viewed a demo app that put these basic ideas to use. Take some time now to explore these ideas further, study the code demonstration, and try building an interface for yourself to get a better idea of how you can use this idea in your future applications.","title":"4. Interfaces with Pact"},{"location":"intermediate/interfaces-with-pact/#interfaces-with-pact","text":"Welcome to this introduction to Interfaces with Pact ! Throughout this tutorial you\u2019ll learn why interfaces are valuable and how to implement them with Pact. Topics covered in this tutorial Introduction to Interfaces Interfaces and Modules Interface Declaration Working with Interfaces Declaring Models in an Interface Coin Contract Demo Key Takeaway Interfaces allow you to provide access to the functions within one module to another module. They are defined using the interface statement and can be accessed from within modules using the implement statement.","title":"Interfaces with Pact"},{"location":"intermediate/interfaces-with-pact/#interfaces-with-pact_1","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Interfaces with Pact"},{"location":"intermediate/interfaces-with-pact/#introduction-to-interfaces","text":"Before getting into interfaces with Pact, I\u2019ll briefly review what interfaces are in general. Interfaces are the point where two systems meet and interact. This definition includes people, organizations, electricity, or any other interactions you can think of. For example, a light socket is a type of interface that gives you access to electricity. In programming, interfaces work similarly, but are used to allow interaction between programs. This isn\u2019t specific to Pact, so if you are familiar with other programming languages, you have likely come across this idea already. If you are unfamiliar with interfaces, you may have at least a basic understanding of what an API is (Application Programming Interface). As you might know, many programs have APIs that allow you to build programs that give access to specific data. For example, you could use Facebook APIs, Twitter APIs, Google APIs, or any other API to add functionality to your application that you wouldn\u2019t have otherwise. Aside from that, you may be familiar with UI, a User Interface. These types of interfaces give users access to elements of a program without using code at all. There are many types of interfaces that have both high level and low level use cases in programming. In this tutorial, you\u2019ll focus specifically on building interfaces using Pact that allow users to create interactions between modules.","title":"Introduction to Interfaces"},{"location":"intermediate/interfaces-with-pact/#interfaces-and-modules","text":"An interface, as defined in Pact, is a collection of models used for formal verification, constant definitions, and typed function signatures. They contain API specifications and data definitions for smart contracts. They include each of the following elements: Function Specifications Constant Values Models Using these three elements, you can both declare and create interface. Declare the Interface To declare an interface, use the statement interface followed by the name of the interface. ( interface my-interface ;; interface code goes here ) Import a module inside an interface You can also import definitions from modules with a use statement. Import Module with Use Use this module from within an interface. ( interface example-interface ( use example-module ) ;; interface code goes here ) ) This allows for some interesting functionality within your interface. Access the Interface from a Module After declaring an interface, you can access if from a module using the implements statement. ( module my-module ( read-keyset my-keyset ) ( implements my-interface ) ;; module code goes here )","title":"Interfaces and Modules"},{"location":"intermediate/interfaces-with-pact/#modules-and-interfaces","text":"Interfaces allow modules to communicate information between one another. Modules and interfaces look very similar to one another, making them simple to program, but there are some key distinctions and ideas that are worth noting. Interfaces Cannot be Upgraded Interfaces cannot be upgraded and no function implementations exist in an interface aside from constant data. Constant Imports The constants of an interface can be imported with use . Use is not the same as implements and you\u2019ll see some of these important differences throughout the demonstration. Conflicting Module Functions Multiple interfaces may be implemented by a single module. If there are conflicting function names among multiple interfaces, then the two interfaces are incompatible. In these cases you need to either inline the code you want, or redefine the interfaces to resolve the conflict. Unique Interface Names Interface names must be unique within a namespace. Accessing Interfaces Constants declared in an interface can be accessed directly by their fully qualified name. interface.const This makes it so that they do not have the same naming constraints as function signatures. Module Declarations Additionally, interfaces may make use of module declarations. This allows interfaces to import members of other modules. For that reason, interface signatures can be defined in terms of table types defined in an imported module.","title":"Modules and Interfaces"},{"location":"intermediate/interfaces-with-pact/#declare-and-implement-an-interface","text":"Using the basic ideas described above, you can create more complex interactions by defining interfaces modules along with the implements and use statements . Declare an Interface To start, the example below declares an interface named my-interface including a function named hello-number . ( interface my-interface ( defun hello-number :string ( number :integer ) @ doc Return the string \\ Hello, $number!\\ when given a string ) ( defconst SOME_CONSTANT 3 ) ) Implement the Interface Next, define a module that implements my-interface and makes use of the hello-number function. ( module my-module ( read-keyset my-keyset ) ( implements my-interface ) ( defun hello-number :string ( number :integer ) ( format Hello, {}! [ number ])) ( defun square-three () ( * my-interface.SOME_CONSTANT my-interface.SOME_CONSTANT )) ) Notice also, that within the module, a function named square-three is defined. This function makes use of a constant defined within the interface named SOME_CONSTANT having imported it with the use statement..","title":"Declare and Implement an Interface"},{"location":"intermediate/interfaces-with-pact/#declaring-models-in-an-interface","text":"Formal verification is implemented at multiple levels within an interface in order to provide an extra level of security. Similar to modules, models may be declared within the body or function level of an interface. Models may be declared either within the body of the interface or at the function level in the same way that one would declare them in a module, with the exception of schema invariants. ( interface coin-sig Coin Contract Abstract Interface Example ( use acct-module ) ( defun transfer :string ( from :string to :string amount :integer ) @ doc Transfer money between accounts @ model [( property ( row-enforced accounts ks from )) ( property ( amount 0 )) ( property ( = 0 ( column-delta accounts balance ))) ] ) ) You can't declare tables or schema in an interface, because there's no abstract \"table\" or \"schema\" that you can define or \"implement\" in a meaningful way. It also couples a module too tightly with a particular interface. You can, however, import a module and use the declared tables and schema in that module as types in the function signatures, or in models. Models that you specify in an interface will be added with additional models you declare in a module. This allows you to layer more constraints on as you wish per your business needs in your module.","title":"Declaring Models in an Interface"},{"location":"intermediate/interfaces-with-pact/#coin-contract-demo","text":"For the rest of this tutorial, you\u2019ll take a closer look interfaces using a version of the coin contract from previous tutorials. You\u2019ll create an interface to the coin contract that allows its functions to be accessed by other modules. Chainweb Repo Rather than using the tutorials GitHub repo like previously, you\u2019ll find this project within the chainweb-node repo here . Chainweb is Kadena\u2019s public blockchain platform. We haven\u2019t discussed this in previous tutorials, but we will cover this in more detail in later tutorials. You don\u2019t need to know what this is for this tutorial, but if you\u2019d like, you can learn more about the basics of Chainweb here . To get started with the demonstration, clone the project and open it in Atom. Clone the project git clone https://github.com/kadena-io/chainweb-node.git Enter the Project File cd chainweb-node/pact/coin-contract/coin-sig.pact Open in Atom atom .","title":"Coin Contract Demo"},{"location":"intermediate/interfaces-with-pact/#project-visual-overview","text":"Looking at the interface, you\u2019ll see that it includes 5 functions. These functions contain inputs and models allowing for the basic functionality of managing coins to be used by other modules. Let\u2019s take a closer look at this code to get a better idea of how it works.","title":"Project Visual Overview"},{"location":"intermediate/interfaces-with-pact/#define-the-interface","text":"First, define an interface using the interface statement followed by the name of the interface. ( interface coin-sig ;; CODE GOES HERE ) Within this interface, you\u2019ll create each of the functions.","title":"Define the Interface"},{"location":"intermediate/interfaces-with-pact/#function-create-account","text":"Create-account takes inputs account and guard . ( defun create-account :string ( account :string guard :guard ) @ doc Create an account for ACCOUNT, with ACCOUNT as a function of GUARD @ model [ ( property ( not ( = account ))) ] ) Within this function, a model is defined checking that the account is not an empty string. This will ensure that each account is given a name.","title":"Function: Create Account"},{"location":"intermediate/interfaces-with-pact/#function-transfer","text":"Transfer allows users to transfer value between a sender and a receiver. ( defun transfer :string ( sender :string receiver :string amount :decimal ) @ doc Transfer between accounts SENDER and RECEIVER on the same chain. \\ \\This fails if both accounts do not exist. Create-on-transfer can be \\ \\handled by sending in a create command in the same tx. @ model [ ( property ( amount 0.0 )) ( property ( not ( = sender receiver ))) ] ) It checks that the amount is greater than 0 and that the sender is not also the receiver before completing the transfer. The function transfer transfers coins to a known account. If that account doesn\u2019t exist then the coins end up lost in the abyss with no way to retrieve them. For that reason, you may want to instead use the following function, transfer and create.","title":"Function: Transfer"},{"location":"intermediate/interfaces-with-pact/#function-transfer-and-create","text":"( defun transfer-and-create :string ( sender :string receiver :string receiver-guard :guard amount :decimal ) @ doc Transfer between accounts SENDER and RECEIVER on the same chain. \\ \\This fails if SENDER does not exist or RECEIVER exists and RECEIVER-GUARD does not match with the guard in RECEIVER\u2019s account \\Create-on-transfer can be \\ \\handled by sending in a create command in the same tx. @ model [ ( property ( amount 0.0 )) ( property ( not ( = sender receiver ))) ] ) Transfer and create supplies a guard for the receiving account. If the account exists, it checks to see if the guards match. If they do, it will complete the transfer, otherwise the transaction will fail. If the account does not exist, then the account will be created and the coin will be transferred to the new account. Safe vs Unsafe Transfers The previous functions distinguish between \"unsafe\" and \u201csafe\u201d transfers. With unsafe transfers, your tokens could potentially get lost in the crypto abyss. With \u201csafe\u201d transfers, your tokens always end up in some account,otherwise the transaction fails and you are refunded.","title":"Function: Transfer and Create"},{"location":"intermediate/interfaces-with-pact/#function-account-balance","text":"The function account-balance takes an account string and returns the balance of the account. ( defun account-balance :decimal ( account :string ) @ doc Query user account ACCOUNT balance )","title":"Function: Account Balance"},{"location":"intermediate/interfaces-with-pact/#function-coinbase","text":"Coinbase allows users to mint tokens to an address by defining the address, address-guard, and amount. ( defun coinbase :string ( address :string address-guard :guard amount :decimal ) @ doc Mint some number of tokens and allocate them to some address @ model [ ( property ( amount 0.0 )) ( property ( not ( = address ))) ] ) What does Coinbase mean? The Coinbase transaction , or Generation transaction , is a special transaction . It specifically refers to a transaction that creates coins from nothing. In certain blockchain protocols, it is the reward that miner gets for successfully mining a block. It\u2019s also the name of a popular digital asset exchange company named Coinbase. Having created each of these functions within the interface, you can now create modules that use them for whatever purpose they might serve within your application.","title":"Function: Coinbase"},{"location":"intermediate/interfaces-with-pact/#review","text":"That wraps up this introduction to Interfaces with Pact! Throughout this tutorial you learned why interfaces are valuable and how to implement them with Pact. We introduced interfaces and described how they are different than modules. From there you learned how to declare modules, how to work with interfaces, and viewed a demo app that put these basic ideas to use. Take some time now to explore these ideas further, study the code demonstration, and try building an interface for yourself to get a better idea of how you can use this idea in your future applications.","title":"Review"},{"location":"intermediate/pact-and-javascript/","text":"Pact and Javascript Welcome to this tutorial introducing Pact and Javascript! The goal of this tutorial is to help you connect your Pact development environment to a front end application. Topics covered in this tutorial Introduction Install Project Dependencies Project Setup Interact with the Application View Project Files Smart Contract Code Javascript Review Key Takeaway Full stack blockchain applications can be developed by pairing javascript with Pact. You can use any javascript code, library, or framework you\u2019d like to create complex applications fully supported by Pact smart contracts attached to a blockchain base. Prerequisites Having at least a basic understanding of each of the following topics will help you be successful in this tutorial. Programming in Javascript Programming in React Programming Pact Smart Contracts Pact and Javascript Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Introduction This tutorial runs through a working demonstration of a simple todo app. The app will look like this. It allows you to organize your agenda by adding tasks with due dates that you can later update or delete if needed. You can add, complete, and clear tasks, and you can view tasks based on their status. Like other Todo apps, it\u2019s a great way to look at the basic functionality of the language while creating a useful app that you can use for yourself. You can find the github page for this todo app from the Pact language GitHub page here . If you\u2019d like, you can try putting together the application from this documentation, and if you\u2019d prefer, you can follow along with this tutorial where I\u2019ll go through each step in detail. There\u2019s a lot going on in this tutorial. If you stick with it, it\u2019s totally worth it. While this setup helps you get up and running with the todo app, it\u2019s also the same setup you\u2019ll use for many other Pact applications. Install Project Dependencies Before getting started on the project, there are a few project dependencies you will need to run the application on your local computer. In this section, you\u2019ll install each of these dependencies to get ready to run the TodoMVC locally. Dependencies Pact Pact-lang-api TodoMVC Nodejs Key Takeaway In the previous tutorial, you installed Pact and the pact-lang-api . These are required for this tutorial. Note that Pact 3.0 or higher is required for this tutorial. You can check your Pact version using the following command. pact -v Take some time now to re-install Pact if it is a version lower than 3.0. Install Node.js To create a Javascript application on your computer, you\u2019ll need to install and run Node.js. If you don\u2019t already have this on your computer, you can navigate to Download | Node.js to get started. Make sure to install a node version = 8.11.4 You can check your version using the following command in your terminal. node -v Clone Project Files Now that you\u2019ve installed Pact and Nodejs, you can clone the project files into a local directory. From your terminal, navigate into the project directory where you\u2019d like to create the application. cd myProjectDirectory Clone the Pact-todomvc application. git clone https://github.com/kadena-io/Pact-todomvc.git Change into the todo-mvc project directory. cd Pact-todomvc Note We use npm package named pact-lang-api to send Pact commands into the Pact server. This needs to be installed along with other npm packages that the app is built on. The required npm packages are saved in package.json file, and the following command installs all required npm packages \"npm i\" Project Setup Create Log folder Pact features a full REST API HTTP server and SQLite database implementation. The Pact server simulates a single-node blockchain environment and will help you store and manipulate test data for your application. Application data for the server is stored within a log folder. To get started, you need to create the log folder within your project directory. cd Pact-todomvc mkdir log Start the Pact Server Next, run the following command to start the Pact server. npm run start:Pact This Pact server will provide a log of each action that takes place on the application. Note The command, \"Pact --serve server.conf\" launches a Pact server. Everytime the server starts, we want to clear previous server's logs and create a new log directory, so we actually run the following command, \"rm -Rf ./log mkdir log Pact --serve server.conf\" We saved this script in package.json file here and can simply run the command npm run start:Pact Seed the Blockchain Finally, open another terminal window within the same directory and run the following command to seed data into your application. npm run Pact:seed Note Similar to when you ran the server, you\u2019ll see that seeding the database calls another file, initialize-todos.sh. You can find initialize-todos.sh in the project directory. What this does is load the todos.pact contract by making a send request with load-todos.yaml files. Looking at load todos.yaml you can see the codefile, todo-admin-keyset, keypairs, and nonce that is loaded by initialize-todos.sh . The initial seed data will include the status and response shown as a hash value. Package.json Finally you can see how both start:pact and pact:seed are working by looking into the package.json file. Under scripts, you can see that start:pact is set to call the server.conf file and that pact:seed is set to call the initialize-todos.sh file. The script to run this part is also saved in package.json file, so we can simply run npm run Pact:seed . Start the Web Application After starting the Pact server and seeding the blockchain, you can now start the web application on your local server. npm start View the App The project is now available for you to view on your localhost! When you ran npm start your browser may have opened automatically to the application. If not, you can open to http://localhost:3000 to view the application now. The todo app should currently look like this in your browser. Interact with the Application Now that the app is running, try entering some Todos to get used to the functionality of the app. In my application I\u2019ll add the following tasks. Learn Pact Complete Pact and Javascript Tutorial Next, I\u2019ll complete one of the tasks I created. Complete Learn Pact Feel free to add whatever todos you would like to get a better feel for the application. Coming up you\u2019ll take a look at the project files along with the data you generated. View Project Files Having a feel for how the application works, you can now view the project files. To view these files, open a new terminal within the project directory and type the following command to open the project. atom . Project Directory Overview Within the project folder are each of the files installed from the project repository, the dependencies installed with npm install , and the files you created yourself. Most of these files are specific to the front end side of this web application, but the ones unique to the Pact application are in the log folder and Pact folder . View the Log Folder View the log folder you created earlier to see that it\u2019s now filled with sqlite files. These files are a sort of emulated blockchain that you can use to create tables and store or retrieve data. View the Pact Folder The Pact folder contains the .pact and .repl files that build, run, and test the smart contract. In here you\u2019ll see todos.pact and todos.repl . The .pact file is the smart contract for this application, and the .repl file is what loads and runs tests on the Pact file. View the Front End Application Inside of the src folder you will see the front end code for this application including the components , html , jsx , and css files. This is a react application, but the front end could use any library or framework you prefer. If you\u2019re unfamiliar with react you can visit React - A Javascript Library for Building User Interfaces to get started with react applications. Smart Contract Code To understand how each of the UI elements are working with the database, take some time to view the Pact smart contract. As you\u2019ll see, there is a single todo table that you can access using a variety of functions as shown below. Todo Table Here is the schema of the todo table. title string completed bool deleted bool Smart Contract Functions Here is a list of functions from the smart contract along with their purpose. new-todo Adds a new todo to the database. toggle-todo-status Changes the status of the todo within the database. edit-todo Edits the title of the todo within the database. delete-todo Deletes the todo from the database. read-todo Reads a single todo from the database. read-todos Reads all todos from the database. Note While the code here is new, most of the functionality is covered in previous tutorials throughout the Pact beginner tutorials . If you have not completed these tutorials, take some time to look through them now to get a better understanding of this Pact smart contract. As a quick refresher of what this Pact code is doing, here is a look at the code used to create the todo table and add a new todo. Create Todo Schema and Table Here you can see a schema is defined for a table named todo that is later defined and created. This table includes rows for title, completed, and deleted. ;; todo schema and table ( defschema todo Row type for todos. title :string completed :bool deleted :bool ) ( deftable todo-table : { todo }) ;; todo table created outside of module New Todo The function new-todo adds a todo using the title input generated by the user. The application assigns the title a specific ID and uses that to generate the title as specified by the user, and an initial completed and deleted status of false. ( defun new-todo ( id title ) Create new todo with ENTRY and DATE. ( insert todo-table id { title : title , completed : false , deleted : false }) ) A lot of the remaining code works similar to new-todo with slightly different functionality based on its purpose. Take some time to review each of these functions now to familiarize yourself with the application. Javascript React uses the pact-lang-api to interact with Pact and update the database depending on the actions of the user. An understanding of the entire application takes some background in React and Javascript. For this tutorial, we\u2019ll focus on the functionality that is specific to interacting with Pact. To get started, navigate to src components todo-app.jsx Within this file, you\u2019ll see the consts, component, functions, and rendering used to connect react to Pact. Imports First, note that aside from a few standard react imports, this file also imports Pact from the Pact-lang-api, as well as the TodoItem and TodoFooter. import * as React from react ; import uuidv4 from uuid/v4 ; import Pact from Pact-lang-api ; import { TodoItem } from ./todo-item.jsx ; import { TodoFooter } from ./footer.jsx ; Consts There are also a few constants set that you\u2019ll see used throughout the functions below including KP - which calls a specific function within the pact lang api to generate a keypair, API_HOST, and consts related to the TODO state within the database. const ENTER_KEY = 13 ; const KP = Pact . crypto . genKeyPair (); const API_HOST = http://localhost:9001 ; const ALL_TODOS = all ; const ACTIVE_TODOS = active ; const COMPLETED_TODOS = completed ; Here\u2019s a quick overview of how each of their functions are associated. getTodos() read-todos Fetches all todos and returns current information from database. add() new-todo Adds todo to database given title input from user. toggle() toggle-todo-status Toggles single todo-status between active and complete. toggleAll() toggle-todo-status Updates all todo-status between active and complete. destroy() delete-todo Updates deleted field of the todo to true. clearCompleted() delete-todo Clears completed todo\u2019s from the database. save(todo, text) edit-todo Saves todo to the database. One thing to note here is delete-todo, which can be a bit misleading. You can\u2019t actually delete data from a blockchain, so rather than delete the data, it toggling the status of the delete field to true. Note Todo-app imports todo-item and uses some of its functionality throughout each of these functions. Take some time now to familiarize yourself with both of these files in more detail. add() new-todo demo Let\u2019s look at one example in detail. In this case we can look more closely at how add() calls new-todo from todos.pact. New-todo This function is called by add(). ( defun new-todo ( id title ) Create new todo with ENTRY and DATE. ( insert todo-table id { title : title , completed : false , deleted : false }) ) Add() This function is used to add a todo to the database and display it on the website for the user. add ( title ) { const uuid = uuidv4 (); const cmdObj = { pactCode : Pact . lang . mkExp ( todos.new-todo , uuid , title ), keyPairs : KP }; Pact . fetch . send ( cmdObj , API_HOST ) . then (() = this . getTodos ()); } Here are some details about how this function works to add and display a new todo onto the application. Inputs Add() is taking in the title as input by the user in the application. Consts Before sending this to pact, the function sets a const named uuid that utilizes the uuidv4 library that was imported at the top of the file. cmdObj This is used as an object to specify information you\u2019d like to include in the API call. Within the cmdObj we specify the pact code along with the keypairs. Pact Code The pact code we use here is Pact.lang.mkExp. mkExp A helper function for constructing native pact commands. In this case that\u2019s valuable because it allows you to call a the function new-todo from todos.pact, and to specify the inputs of uuid and title. Keypair After the pact code, you\u2019ll see the generated keypair. This is using the constant KP, which as you\u2019ve seen above uses Pact.crypto.genKeyPair to generate a public key. Note You can see more about this on the pact-lang-api website. It generates both a public and secret key as a string. You may recognize the public key as the hash value that was returned in the terminal earlier. Pact.fetch Next, you\u2019ll see Pact.fetch.send which is a request to execute a command on the pact server. In this function, pact.fetch.send includes the cmdObj built above, along with a specified API_HOST . This API_HOST is the constant set above, and is the localhost:9001 that you saw the pact server initiate from your terminal. Once that\u2019s done the todo is in the database. The last step is to show this data on the website for the user. Note There are other pact.fetch functions including local, poll, and listen. Each of these have slightly different use cases that you can explore in the documentation. getTodos() That\u2019s where this last line comes in. After sending the data to the database, this line calls getTodos() which is another function in this javascript file. This function is what fetches data from the database and displays it on the website. It looks like a lot, but having seen the add function in depth, see if you can parse out what is going on in this function. Review At this point you should be in a good place to continue playing around with the TodoMVC application. Try experimenting with the look and feel of it to make it your own. Later you can try tweaking the code to see how it affects the application, and finally you can try writing your own functions that extend the functionality of this application to do whatever you\u2019d like. As a quick recap, you installed each of the dependencies required to create a full stack blockchain application with pact. From there, you set up the todoMVC project, investigated the project files, and then dove into the details of how pact and javascript communicating using the pact-lang-api. After getting comfortable with this application, you\u2019ll be in a great place to build applications of your own for entirely different use cases.","title":"2. Pact and Javascript"},{"location":"intermediate/pact-and-javascript/#pact-and-javascript","text":"Welcome to this tutorial introducing Pact and Javascript! The goal of this tutorial is to help you connect your Pact development environment to a front end application. Topics covered in this tutorial Introduction Install Project Dependencies Project Setup Interact with the Application View Project Files Smart Contract Code Javascript Review Key Takeaway Full stack blockchain applications can be developed by pairing javascript with Pact. You can use any javascript code, library, or framework you\u2019d like to create complex applications fully supported by Pact smart contracts attached to a blockchain base.","title":"Pact and Javascript"},{"location":"intermediate/pact-and-javascript/#prerequisites","text":"Having at least a basic understanding of each of the following topics will help you be successful in this tutorial. Programming in Javascript Programming in React Programming Pact Smart Contracts","title":"Prerequisites"},{"location":"intermediate/pact-and-javascript/#pact-and-javascript-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Pact and Javascript Tutorial"},{"location":"intermediate/pact-and-javascript/#introduction","text":"This tutorial runs through a working demonstration of a simple todo app. The app will look like this. It allows you to organize your agenda by adding tasks with due dates that you can later update or delete if needed. You can add, complete, and clear tasks, and you can view tasks based on their status. Like other Todo apps, it\u2019s a great way to look at the basic functionality of the language while creating a useful app that you can use for yourself. You can find the github page for this todo app from the Pact language GitHub page here . If you\u2019d like, you can try putting together the application from this documentation, and if you\u2019d prefer, you can follow along with this tutorial where I\u2019ll go through each step in detail. There\u2019s a lot going on in this tutorial. If you stick with it, it\u2019s totally worth it. While this setup helps you get up and running with the todo app, it\u2019s also the same setup you\u2019ll use for many other Pact applications.","title":"Introduction"},{"location":"intermediate/pact-and-javascript/#install-project-dependencies","text":"Before getting started on the project, there are a few project dependencies you will need to run the application on your local computer. In this section, you\u2019ll install each of these dependencies to get ready to run the TodoMVC locally. Dependencies Pact Pact-lang-api TodoMVC Nodejs Key Takeaway In the previous tutorial, you installed Pact and the pact-lang-api . These are required for this tutorial. Note that Pact 3.0 or higher is required for this tutorial. You can check your Pact version using the following command. pact -v Take some time now to re-install Pact if it is a version lower than 3.0.","title":"Install Project Dependencies"},{"location":"intermediate/pact-and-javascript/#install-nodejs","text":"To create a Javascript application on your computer, you\u2019ll need to install and run Node.js. If you don\u2019t already have this on your computer, you can navigate to Download | Node.js to get started. Make sure to install a node version = 8.11.4 You can check your version using the following command in your terminal. node -v","title":"Install Node.js"},{"location":"intermediate/pact-and-javascript/#clone-project-files","text":"Now that you\u2019ve installed Pact and Nodejs, you can clone the project files into a local directory. From your terminal, navigate into the project directory where you\u2019d like to create the application. cd myProjectDirectory Clone the Pact-todomvc application. git clone https://github.com/kadena-io/Pact-todomvc.git Change into the todo-mvc project directory. cd Pact-todomvc Note We use npm package named pact-lang-api to send Pact commands into the Pact server. This needs to be installed along with other npm packages that the app is built on. The required npm packages are saved in package.json file, and the following command installs all required npm packages \"npm i\"","title":"Clone Project Files"},{"location":"intermediate/pact-and-javascript/#project-setup","text":"","title":"Project Setup"},{"location":"intermediate/pact-and-javascript/#create-log-folder","text":"Pact features a full REST API HTTP server and SQLite database implementation. The Pact server simulates a single-node blockchain environment and will help you store and manipulate test data for your application. Application data for the server is stored within a log folder. To get started, you need to create the log folder within your project directory. cd Pact-todomvc mkdir log","title":"Create Log folder"},{"location":"intermediate/pact-and-javascript/#start-the-pact-server","text":"Next, run the following command to start the Pact server. npm run start:Pact This Pact server will provide a log of each action that takes place on the application. Note The command, \"Pact --serve server.conf\" launches a Pact server. Everytime the server starts, we want to clear previous server's logs and create a new log directory, so we actually run the following command, \"rm -Rf ./log mkdir log Pact --serve server.conf\" We saved this script in package.json file here and can simply run the command npm run start:Pact","title":"Start the Pact Server"},{"location":"intermediate/pact-and-javascript/#seed-the-blockchain","text":"Finally, open another terminal window within the same directory and run the following command to seed data into your application. npm run Pact:seed Note Similar to when you ran the server, you\u2019ll see that seeding the database calls another file, initialize-todos.sh. You can find initialize-todos.sh in the project directory. What this does is load the todos.pact contract by making a send request with load-todos.yaml files. Looking at load todos.yaml you can see the codefile, todo-admin-keyset, keypairs, and nonce that is loaded by initialize-todos.sh . The initial seed data will include the status and response shown as a hash value.","title":"Seed the Blockchain"},{"location":"intermediate/pact-and-javascript/#packagejson","text":"Finally you can see how both start:pact and pact:seed are working by looking into the package.json file. Under scripts, you can see that start:pact is set to call the server.conf file and that pact:seed is set to call the initialize-todos.sh file. The script to run this part is also saved in package.json file, so we can simply run npm run Pact:seed .","title":"Package.json"},{"location":"intermediate/pact-and-javascript/#start-the-web-application","text":"After starting the Pact server and seeding the blockchain, you can now start the web application on your local server. npm start","title":"Start the Web Application"},{"location":"intermediate/pact-and-javascript/#view-the-app","text":"The project is now available for you to view on your localhost! When you ran npm start your browser may have opened automatically to the application. If not, you can open to http://localhost:3000 to view the application now. The todo app should currently look like this in your browser.","title":"View the App"},{"location":"intermediate/pact-and-javascript/#interact-with-the-application","text":"Now that the app is running, try entering some Todos to get used to the functionality of the app. In my application I\u2019ll add the following tasks. Learn Pact Complete Pact and Javascript Tutorial Next, I\u2019ll complete one of the tasks I created. Complete Learn Pact Feel free to add whatever todos you would like to get a better feel for the application. Coming up you\u2019ll take a look at the project files along with the data you generated.","title":"Interact with the Application"},{"location":"intermediate/pact-and-javascript/#view-project-files","text":"Having a feel for how the application works, you can now view the project files. To view these files, open a new terminal within the project directory and type the following command to open the project. atom .","title":"View Project Files"},{"location":"intermediate/pact-and-javascript/#project-directory-overview","text":"Within the project folder are each of the files installed from the project repository, the dependencies installed with npm install , and the files you created yourself. Most of these files are specific to the front end side of this web application, but the ones unique to the Pact application are in the log folder and Pact folder .","title":"Project Directory Overview"},{"location":"intermediate/pact-and-javascript/#view-the-log-folder","text":"View the log folder you created earlier to see that it\u2019s now filled with sqlite files. These files are a sort of emulated blockchain that you can use to create tables and store or retrieve data.","title":"View the Log Folder"},{"location":"intermediate/pact-and-javascript/#view-the-pact-folder","text":"The Pact folder contains the .pact and .repl files that build, run, and test the smart contract. In here you\u2019ll see todos.pact and todos.repl . The .pact file is the smart contract for this application, and the .repl file is what loads and runs tests on the Pact file.","title":"View the Pact Folder"},{"location":"intermediate/pact-and-javascript/#view-the-front-end-application","text":"Inside of the src folder you will see the front end code for this application including the components , html , jsx , and css files. This is a react application, but the front end could use any library or framework you prefer. If you\u2019re unfamiliar with react you can visit React - A Javascript Library for Building User Interfaces to get started with react applications.","title":"View the Front End Application"},{"location":"intermediate/pact-and-javascript/#smart-contract-code","text":"To understand how each of the UI elements are working with the database, take some time to view the Pact smart contract. As you\u2019ll see, there is a single todo table that you can access using a variety of functions as shown below.","title":"Smart Contract Code"},{"location":"intermediate/pact-and-javascript/#todo-table","text":"Here is the schema of the todo table. title string completed bool deleted bool","title":"Todo Table"},{"location":"intermediate/pact-and-javascript/#smart-contract-functions","text":"Here is a list of functions from the smart contract along with their purpose. new-todo Adds a new todo to the database. toggle-todo-status Changes the status of the todo within the database. edit-todo Edits the title of the todo within the database. delete-todo Deletes the todo from the database. read-todo Reads a single todo from the database. read-todos Reads all todos from the database. Note While the code here is new, most of the functionality is covered in previous tutorials throughout the Pact beginner tutorials . If you have not completed these tutorials, take some time to look through them now to get a better understanding of this Pact smart contract. As a quick refresher of what this Pact code is doing, here is a look at the code used to create the todo table and add a new todo.","title":"Smart Contract Functions"},{"location":"intermediate/pact-and-javascript/#create-todo-schema-and-table","text":"Here you can see a schema is defined for a table named todo that is later defined and created. This table includes rows for title, completed, and deleted. ;; todo schema and table ( defschema todo Row type for todos. title :string completed :bool deleted :bool ) ( deftable todo-table : { todo }) ;; todo table created outside of module","title":"Create Todo Schema and Table"},{"location":"intermediate/pact-and-javascript/#new-todo","text":"The function new-todo adds a todo using the title input generated by the user. The application assigns the title a specific ID and uses that to generate the title as specified by the user, and an initial completed and deleted status of false. ( defun new-todo ( id title ) Create new todo with ENTRY and DATE. ( insert todo-table id { title : title , completed : false , deleted : false }) ) A lot of the remaining code works similar to new-todo with slightly different functionality based on its purpose. Take some time to review each of these functions now to familiarize yourself with the application.","title":"New Todo"},{"location":"intermediate/pact-and-javascript/#javascript","text":"React uses the pact-lang-api to interact with Pact and update the database depending on the actions of the user. An understanding of the entire application takes some background in React and Javascript. For this tutorial, we\u2019ll focus on the functionality that is specific to interacting with Pact. To get started, navigate to src components todo-app.jsx Within this file, you\u2019ll see the consts, component, functions, and rendering used to connect react to Pact.","title":"Javascript"},{"location":"intermediate/pact-and-javascript/#imports","text":"First, note that aside from a few standard react imports, this file also imports Pact from the Pact-lang-api, as well as the TodoItem and TodoFooter. import * as React from react ; import uuidv4 from uuid/v4 ; import Pact from Pact-lang-api ; import { TodoItem } from ./todo-item.jsx ; import { TodoFooter } from ./footer.jsx ;","title":"Imports"},{"location":"intermediate/pact-and-javascript/#consts","text":"There are also a few constants set that you\u2019ll see used throughout the functions below including KP - which calls a specific function within the pact lang api to generate a keypair, API_HOST, and consts related to the TODO state within the database. const ENTER_KEY = 13 ; const KP = Pact . crypto . genKeyPair (); const API_HOST = http://localhost:9001 ; const ALL_TODOS = all ; const ACTIVE_TODOS = active ; const COMPLETED_TODOS = completed ; Here\u2019s a quick overview of how each of their functions are associated. getTodos() read-todos Fetches all todos and returns current information from database. add() new-todo Adds todo to database given title input from user. toggle() toggle-todo-status Toggles single todo-status between active and complete. toggleAll() toggle-todo-status Updates all todo-status between active and complete. destroy() delete-todo Updates deleted field of the todo to true. clearCompleted() delete-todo Clears completed todo\u2019s from the database. save(todo, text) edit-todo Saves todo to the database. One thing to note here is delete-todo, which can be a bit misleading. You can\u2019t actually delete data from a blockchain, so rather than delete the data, it toggling the status of the delete field to true. Note Todo-app imports todo-item and uses some of its functionality throughout each of these functions. Take some time now to familiarize yourself with both of these files in more detail.","title":"Consts"},{"location":"intermediate/pact-and-javascript/#add-new-todo-demo","text":"Let\u2019s look at one example in detail. In this case we can look more closely at how add() calls new-todo from todos.pact.","title":"add() &gt; new-todo demo"},{"location":"intermediate/pact-and-javascript/#new-todo_1","text":"This function is called by add(). ( defun new-todo ( id title ) Create new todo with ENTRY and DATE. ( insert todo-table id { title : title , completed : false , deleted : false }) )","title":"New-todo"},{"location":"intermediate/pact-and-javascript/#add","text":"This function is used to add a todo to the database and display it on the website for the user. add ( title ) { const uuid = uuidv4 (); const cmdObj = { pactCode : Pact . lang . mkExp ( todos.new-todo , uuid , title ), keyPairs : KP }; Pact . fetch . send ( cmdObj , API_HOST ) . then (() = this . getTodos ()); } Here are some details about how this function works to add and display a new todo onto the application. Inputs Add() is taking in the title as input by the user in the application. Consts Before sending this to pact, the function sets a const named uuid that utilizes the uuidv4 library that was imported at the top of the file. cmdObj This is used as an object to specify information you\u2019d like to include in the API call. Within the cmdObj we specify the pact code along with the keypairs. Pact Code The pact code we use here is Pact.lang.mkExp. mkExp A helper function for constructing native pact commands. In this case that\u2019s valuable because it allows you to call a the function new-todo from todos.pact, and to specify the inputs of uuid and title. Keypair After the pact code, you\u2019ll see the generated keypair. This is using the constant KP, which as you\u2019ve seen above uses Pact.crypto.genKeyPair to generate a public key. Note You can see more about this on the pact-lang-api website. It generates both a public and secret key as a string. You may recognize the public key as the hash value that was returned in the terminal earlier.","title":"Add()"},{"location":"intermediate/pact-and-javascript/#pactfetch","text":"Next, you\u2019ll see Pact.fetch.send which is a request to execute a command on the pact server. In this function, pact.fetch.send includes the cmdObj built above, along with a specified API_HOST . This API_HOST is the constant set above, and is the localhost:9001 that you saw the pact server initiate from your terminal. Once that\u2019s done the todo is in the database. The last step is to show this data on the website for the user. Note There are other pact.fetch functions including local, poll, and listen. Each of these have slightly different use cases that you can explore in the documentation.","title":"Pact.fetch"},{"location":"intermediate/pact-and-javascript/#gettodos","text":"That\u2019s where this last line comes in. After sending the data to the database, this line calls getTodos() which is another function in this javascript file. This function is what fetches data from the database and displays it on the website. It looks like a lot, but having seen the add function in depth, see if you can parse out what is going on in this function.","title":"getTodos()"},{"location":"intermediate/pact-and-javascript/#review","text":"At this point you should be in a good place to continue playing around with the TodoMVC application. Try experimenting with the look and feel of it to make it your own. Later you can try tweaking the code to see how it affects the application, and finally you can try writing your own functions that extend the functionality of this application to do whatever you\u2019d like. As a quick recap, you installed each of the dependencies required to create a full stack blockchain application with pact. From there, you set up the todoMVC project, investigated the project files, and then dove into the details of how pact and javascript communicating using the pact-lang-api. After getting comfortable with this application, you\u2019ll be in a great place to build applications of your own for entirely different use cases.","title":"Review"},{"location":"intermediate/safety-with-pact/","text":"Safety Using Control Flow Welcome to this tutorial on Safety Using Control Flow with Pact. While Pact is already a simple and safe language for smart contracts, there are a few patterns and recommendations you can follow to make it even simpler and even safer. Throughout the next few tutorials, we\u2019ll discuss a few of these patterns. In this tutorial, we\u2019ll focus specifically on how Pact approaches control flow to ensure safety. Topics covered in this tutorial Control Flow Project Setup Unsafe/Safe Example #1 Unsafe/Safe Example #2 Key Takeaway When writing Pact smart contracts, avoid using if statements. Instead, use enforce to ensure your code is both simpler and safer. Safety Using Control Flow Tutorial Subscribe to our YouTube channel to access the latest Pact tutorials. Control Flow Control flow is the order in which individual statements, instructions or function calls are evaluated. In Pact, like in many languages, there are a few ways to approach control flow in your applications. Using Pact, you can use either if or enforce as a means to control the flow of your application. While you can technically use either, we recommend using enforce whenever possible. Using if is considered harmful to the application. \u201cIf\u201d considered harmful Here is an example of an if statement using Pact. pact ( if ( = ( + 2 2 ) 4 ) Don\u2019t use if statements Use enforce instead ) Don\u2019t use if statements Consider avoiding if whenever possible. Every branch makes code harder to understand, opening up the possibility of bugs in your code. Pact History Pact\u2019s original design left out if altogether (and looping), but it was decided that users should be able to judiciously use these features as necessary. Use enforce Instead Enforce is considered a safer option for your smart contracts by making code simpler and less prone to bugs. Here is an example of an enforce statement using Pact. pact ( enforce ( != ( + 2 2 ) 4 ) Stay Safe. Enforce the law. ) interactive :0:0 : Stay safe. Enforce the law. If should never be used to enforce business logic invariants. Instead, enforce is the right choice, which will fail the transaction. Note You can view more on Control Flow here . Next, you will walk through a demonstration smart contract using if statements. You will then refactor these to use the safe option, enforce. Code Demonstration For this demonstration, we have built a smart contract named my-coin . This project represents a simple ledger system providing transfer, credit, debit, account creation, and querying. The goal of this demonstration is to develop a smart contract that adheres to the best control flow safety practices. You\u2019ll work on this contract through the remainder of the tutorial. Open Project Locally To start, open your terminal and change into your project directory. cd projectDirectory Clone the project repo. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the control-flow project directory. cd pact-lang.org-code/safety/control-flow Open the project in atom. atom . View the Project In this project you should see both the my-coin.pact and my-coin.repl files. Within the my-coin.pact file you will see both unsafe and safe alternatives for this program. You can view the completed files in the complete folder and the code challenges from within the challenge folder. Throughout the rest of this tutorial, I\u2019ll work in the challenge folder and demonstrate the 2 examples from this file. First, by writing the unsafe alternative using if, then by writing the safer alternative using enforce . Demonstration #1: Unsafe Starting in the debit-if function, you can see that there is an opportunity to use an if statement. Taking a step back, you\u2019ll see that this function is meant to debit a certain AMOUNT from an ACCOUNT balance while recording both the DATE and DATA . The opportunity for the if statement is at the point where we need to check if the balance is sufficient for the transfer. ;; Debit using if ( defun debit-if :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance recording DATE and DATA ( with-read my-coin-table account { balance := balance } ;;Check if balance is sufficient for the transfer ;;STEP 1: UNSAFE IF STATEMENT GOES HERE ;;STEP 2: If condition is true, update my-coin-table ;;STEP 3:If condition is false, print message ) As you can see, we want to check that the amount being transferred is greater than the balance. STEP 1: Write If Statement A perfectly unsafe way to do this would be to write an if statement as shown here. ( if ( balance amount ) STEP 2: If the Condition is TRUE If the statement is true, meaning the balance is sufficient to make the transfer, the if statement will go on to update the account from within the my-coin-table . ( update my-coin-table account { balance : ( - balance amount ) }) STEP 3: If the Condition is FALSE If the statement is false, meaning the balance is insufficient to make the transfer, send an error message. ;;If condition is false, print message Balance is not sufficient for transfer )) Final If Statement Code Here is a look at the final code. ;; Debit using if ( defun debit-if :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance ( with-read my-coin-table account { balance := balance } ;;Check if balance is sufficient for the transfer ( if ( balance amount ) ;;If condition is true, update my-coin-table ( update my-coin-table account { balance : ( - balance amount ) }) ;;If condition is false, print message Balance is not sufficient for transfer ))) This is a clear case where it feels like if makes sense to use in your code. However, for reasons mentioned earlier, we\u2019d like to remove if from our code in favor of enforce . Demonstration #1: Safe Now, let\u2019s refactor this code using enforce. In this case, the function is similar but we\u2019ll make the safe decision and use enforce. ;; refactor with enforce ( defun debit :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance ( with-read my-coin-table account { balance := balance } ;;STEP 1: Enforce the condition, and fail transaction if condition doesn t meet. ;;STEP 2: Update the balance. ) As you can see, you\u2019ll need to enforce the condition without using an if statement, then update the my-coin-table as you had done previously. STEP 1: Write Enforce Statement To start, enforce that the balance is greater than the amount being sent and fail the transaction if the condition isn\u2019t met. ;; Enforce the condition, and fail transaction if condition doesn t meet. ( enforce ( balance amount ) Balance is not sufficient for transfer ) This step is very similar to the if statement but allows us to finish the function using simpler logic. STEP 2: Update the my-coin-table Table Since the enforce statement handled the failing scenario, you can now write the update to the my-coin-table account assuming that the enforce statement has passed. Update the balance of the account in my-coin-table to be the balance minus the amount sent. ( update my-coin-table account { balance : ( - balance amount ) })) Final Enforce Statement By using enforce , you no longer need to create branching logic dependent on the outcome of the if statement. ;; refactor with enforce ( defun debit :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance ( with-read my-coin-table account { balance := balance } ;; Enforce the condition, and fail transaction if condition doesn t meet. ( enforce ( balance amount ) Balance is not sufficient for transfer ) ;;Update the balance. ( update my-coin-table account { balance : ( - balance amount ) }))) Keep this pattern in mind and use enforce rather than if to create simpler, safer Pact code. Demonstration #2: Unsafe Next, I\u2019ll walk through another demonstration showing the difference between if and enforce . This is another situation where it may be tempting to use if . Though it is a similar idea, there are a few subtle differences in this demonstration that will be valuable to understand. Here is a look at the starting code. ;;TEMPTING USE of IF (type 2) ( defun credit-if :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance ;;STEP 1: Fetch all keys in my-coin-table and see if account exists. ;;STEP 2: if the row exists, check keyset and update the balance ;;STEP 3: If the keysets do match, update the balance. ;;Otherwise, print error message. ;;STEP 4: if the row does not exist, insert a row into the table. )) As you can see, you\u2019ll need to check that an account exists, update its balance if the row exists or if the keysets match, or insert a row if it does not exist. Each of these cases make it tempting to use if . For that reason, I\u2019ll walk through now coding each line using if statements. Step 1: Check that Account Exists First, fetch all keys in my-coin-table to see if the account exists. ;;STEP 1: Fetch all keys in my-coin-table and see if account exists.If true, go to step 2, or else go to step 4 ( if ( contains account ( keys my-coin-table )) Step 2: Update Balance if Row Exists Within the if statement, check the keyset and update the balance if it is found that the row exists. ;;STEP 2: if the row exists, bind variables ( with-read my-coin-table account { balance := balance , keyset := retk } Step 3: Update Balance if Keysets Match Then, if the keysets match update the balance. ;;STEP 3: If the keysets do match, update the balance. ;;Otherwise, print error message. ( if ( = retk keyset ) ( update my-coin-table account { balance : ( + amount balance )}) The keysets do not match )) Step 4: Insert Row if it Does not Exist Next, if the row does not exist, insert the balance and keyset into the account on my-coin-table. ;;STEP 4: if the row does not exist, insert a row into the table. ( insert my-coin-table account { balance : amount , keyset : keyset })) Final Unsafe Code Using If Looking back at the final code, we can see that it is working, but that it is using an unsafe if statement. This is causing logic that is more complicated than necessary and is something that would be better written using enforce . ;;TEMPTING USE of IF (type 2) ( defun credit-if :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance recording DATE and DATA ;;STEP 1: Fetch all keys in my-coin-table and see if account exists. ( if ( contains account ( keys my-coin-table )) ;;STEP 2: if the row exists, check keyset and update the balance ( with-read my-coin-table account { balance := balance , keyset := retk } ;;STEP 3: If the keysets do match, update the balance. ;;Otherwise, print error message. ( if ( = retk keyset ) ( update my-coin-table account { balance : ( + amount balance )}) The keysets do not match )) ;;STEP 4: if the row does not exist, insert a row into the table. ( insert my-coin-table account { balance : amount , keyset : keyset }))) This code can be refactored using enforce . Demonstration #2: Safe Take some time now to reconsider the code you wrote previously. Read through the new comments and decide how you may be able to approach writing this same logic with enforce rather than if. ;;refactor with with-default-read write enforce ( defun credit :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance recording DATE and DATA ;;STEP 1: Default the row to balance at 0.0 and keyset at input keyset ;;If row exists, then bind balance and keyset value from the table. ;;This allows one time key lookup - increases efficiency. ;;STEP 2: Check that the input keyset is the same as the row s keyset ;;STEP 3: Writes the row to the table. (write adds the table with the key and the row. ) As you can see, you will again need to check that an account exists, update its balance if the row exists or if the keysets match, or insert a row if it does not exist. You can do all of this using enforce as shown below. Step 1: Create Efficient One Time Key Lookup To start, you will need to reorder the code slightly. You\u2019ll start by setting the default row balance to 0.0 and a keyset at input keyset. If the row exists, then bind the balance and keyset value from the table. ;;STEP 1: Default the row to balance at 0.0 and keyset at input keyset ;;If row exists, then bind balance and keyset value from the table. ;;This allows one time key lookup - increases efficiency. ( with-default-read my-coin-table account { balance : 0.0 , keyset : keyset } { balance := balance , keyset := retg } This is more efficient than the previous code and allows for a one time key lookup. Previous Code Using If As a comparison, look back at steps 2 and 4 from the earlier code you wrote. Take some time to understand how the code above is combining each of these steps by allowing for a single lookup. \u2026 code ;;STEP 2: if the row exists, check keyset and update the balance ( with-read my-coin-table account { balance := balance , keyset := retk } \u2026 code ;;STEP 4: if the row does not exist, insert a row into the table. ( insert my-coin-table account { balance : amount , keyset : keyset \u2026 code Step 2: Check Input Key vs Row\u2019s Keyset Next, use enforce to check that the input keyset is the same as the row\u2019s keyset. If not, return that the account guards do not match. ;;STEP 2: Check that the input keyset is the same as the row s keyset ( enforce ( = retg keyset ) account guards do not match ) Step 3: Write Row to Table Finally, write the account balance and keyset to a row in the my-coin-table. ;;STEP 3: Writes the row to the table. (write adds the table with the key and the row. ( write my-coin-table account { balance : ( + balance amount ) , keyset : retg }))) Final Enforce Statement Looking back at the final version of the code, you can see that we have completed the same logic without ever using an if statement. This again allows for simpler logic and can help you write safer code. ;;refactor with with-default-read write enforce ( defun credit :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance recording DATE and DATA ;;STEP 1: Default the row to balance at 0.0 and keyset at input keyset ;;If row exists, then bind balance and keyset value from the table. ;;This allows one time key lookup - increases efficiency. ( with-default-read my-coin-table account { balance : 0.0 , keyset : keyset } { balance := balance , keyset := retg } ;;STEP 2: Check that the input keyset is the same as the row s keyset ( enforce ( = retg keyset ) account guards do not match ) ;;STEP 3: Writes the row to the table. (write adds the table with the key and the row. ( write my-coin-table account { balance : ( + balance amount ) , keyset : retg }))) ) Take a moment now to look back and compare both versions of this code. Ensure that you keep these patterns in mind as you write your own code. my-coin.repl In my-coin.repl file, you can check that the failing cases of debit-if and credit-if are tested with (expect \u2026 ) by checking if the output matches the expected failure message. The refactored code allows us to test with (expect-failure ...) to check if the function succeeds or not. Note For more information on running .repl files from Atom, see the tutorial Contract Interaction Run REPL file . Review That wraps up this tutorial on Pact safety using control flow. Throughout this tutorial, you learned that using enforce can help make your the control flow of your Pact smart contracts even simpler and safer. You went over a few demonstrations teaching you ways to avoid using if statements in favor of enforce . This is one of a few key patterns that you can use to improve the safety of your smart contracts. Coming up, we\u2019ll go over a few more safety tips to keep in mind as you develop Pact smart contracts.","title":"3. Safety Using Control Flow"},{"location":"intermediate/safety-with-pact/#safety-using-control-flow","text":"Welcome to this tutorial on Safety Using Control Flow with Pact. While Pact is already a simple and safe language for smart contracts, there are a few patterns and recommendations you can follow to make it even simpler and even safer. Throughout the next few tutorials, we\u2019ll discuss a few of these patterns. In this tutorial, we\u2019ll focus specifically on how Pact approaches control flow to ensure safety. Topics covered in this tutorial Control Flow Project Setup Unsafe/Safe Example #1 Unsafe/Safe Example #2 Key Takeaway When writing Pact smart contracts, avoid using if statements. Instead, use enforce to ensure your code is both simpler and safer.","title":"Safety Using Control Flow"},{"location":"intermediate/safety-with-pact/#safety-using-control-flow-tutorial","text":"Subscribe to our YouTube channel to access the latest Pact tutorials.","title":"Safety Using Control Flow Tutorial"},{"location":"intermediate/safety-with-pact/#control-flow","text":"Control flow is the order in which individual statements, instructions or function calls are evaluated. In Pact, like in many languages, there are a few ways to approach control flow in your applications. Using Pact, you can use either if or enforce as a means to control the flow of your application. While you can technically use either, we recommend using enforce whenever possible. Using if is considered harmful to the application.","title":"Control Flow"},{"location":"intermediate/safety-with-pact/#if-considered-harmful","text":"Here is an example of an if statement using Pact. pact ( if ( = ( + 2 2 ) 4 ) Don\u2019t use if statements Use enforce instead ) Don\u2019t use if statements Consider avoiding if whenever possible. Every branch makes code harder to understand, opening up the possibility of bugs in your code. Pact History Pact\u2019s original design left out if altogether (and looping), but it was decided that users should be able to judiciously use these features as necessary.","title":"\u201cIf\u201d considered harmful"},{"location":"intermediate/safety-with-pact/#use-enforce-instead","text":"Enforce is considered a safer option for your smart contracts by making code simpler and less prone to bugs. Here is an example of an enforce statement using Pact. pact ( enforce ( != ( + 2 2 ) 4 ) Stay Safe. Enforce the law. ) interactive :0:0 : Stay safe. Enforce the law. If should never be used to enforce business logic invariants. Instead, enforce is the right choice, which will fail the transaction. Note You can view more on Control Flow here . Next, you will walk through a demonstration smart contract using if statements. You will then refactor these to use the safe option, enforce.","title":"Use enforce Instead"},{"location":"intermediate/safety-with-pact/#code-demonstration","text":"For this demonstration, we have built a smart contract named my-coin . This project represents a simple ledger system providing transfer, credit, debit, account creation, and querying. The goal of this demonstration is to develop a smart contract that adheres to the best control flow safety practices. You\u2019ll work on this contract through the remainder of the tutorial.","title":"Code Demonstration"},{"location":"intermediate/safety-with-pact/#open-project-locally","text":"To start, open your terminal and change into your project directory. cd projectDirectory Clone the project repo. git clone https://github.com/kadena-io/pact-lang.org-code.git Change into the control-flow project directory. cd pact-lang.org-code/safety/control-flow Open the project in atom. atom .","title":"Open Project Locally"},{"location":"intermediate/safety-with-pact/#view-the-project","text":"In this project you should see both the my-coin.pact and my-coin.repl files. Within the my-coin.pact file you will see both unsafe and safe alternatives for this program. You can view the completed files in the complete folder and the code challenges from within the challenge folder. Throughout the rest of this tutorial, I\u2019ll work in the challenge folder and demonstrate the 2 examples from this file. First, by writing the unsafe alternative using if, then by writing the safer alternative using enforce .","title":"View the Project"},{"location":"intermediate/safety-with-pact/#demonstration-1-unsafe","text":"Starting in the debit-if function, you can see that there is an opportunity to use an if statement. Taking a step back, you\u2019ll see that this function is meant to debit a certain AMOUNT from an ACCOUNT balance while recording both the DATE and DATA . The opportunity for the if statement is at the point where we need to check if the balance is sufficient for the transfer. ;; Debit using if ( defun debit-if :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance recording DATE and DATA ( with-read my-coin-table account { balance := balance } ;;Check if balance is sufficient for the transfer ;;STEP 1: UNSAFE IF STATEMENT GOES HERE ;;STEP 2: If condition is true, update my-coin-table ;;STEP 3:If condition is false, print message ) As you can see, we want to check that the amount being transferred is greater than the balance. STEP 1: Write If Statement A perfectly unsafe way to do this would be to write an if statement as shown here. ( if ( balance amount ) STEP 2: If the Condition is TRUE If the statement is true, meaning the balance is sufficient to make the transfer, the if statement will go on to update the account from within the my-coin-table . ( update my-coin-table account { balance : ( - balance amount ) }) STEP 3: If the Condition is FALSE If the statement is false, meaning the balance is insufficient to make the transfer, send an error message. ;;If condition is false, print message Balance is not sufficient for transfer )) Final If Statement Code Here is a look at the final code. ;; Debit using if ( defun debit-if :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance ( with-read my-coin-table account { balance := balance } ;;Check if balance is sufficient for the transfer ( if ( balance amount ) ;;If condition is true, update my-coin-table ( update my-coin-table account { balance : ( - balance amount ) }) ;;If condition is false, print message Balance is not sufficient for transfer ))) This is a clear case where it feels like if makes sense to use in your code. However, for reasons mentioned earlier, we\u2019d like to remove if from our code in favor of enforce .","title":"Demonstration #1: Unsafe"},{"location":"intermediate/safety-with-pact/#demonstration-1-safe","text":"Now, let\u2019s refactor this code using enforce. In this case, the function is similar but we\u2019ll make the safe decision and use enforce. ;; refactor with enforce ( defun debit :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance ( with-read my-coin-table account { balance := balance } ;;STEP 1: Enforce the condition, and fail transaction if condition doesn t meet. ;;STEP 2: Update the balance. ) As you can see, you\u2019ll need to enforce the condition without using an if statement, then update the my-coin-table as you had done previously. STEP 1: Write Enforce Statement To start, enforce that the balance is greater than the amount being sent and fail the transaction if the condition isn\u2019t met. ;; Enforce the condition, and fail transaction if condition doesn t meet. ( enforce ( balance amount ) Balance is not sufficient for transfer ) This step is very similar to the if statement but allows us to finish the function using simpler logic. STEP 2: Update the my-coin-table Table Since the enforce statement handled the failing scenario, you can now write the update to the my-coin-table account assuming that the enforce statement has passed. Update the balance of the account in my-coin-table to be the balance minus the amount sent. ( update my-coin-table account { balance : ( - balance amount ) })) Final Enforce Statement By using enforce , you no longer need to create branching logic dependent on the outcome of the if statement. ;; refactor with enforce ( defun debit :string ( account :string amount :decimal ) @ doc Debit AMOUNT from ACCOUNT balance ( with-read my-coin-table account { balance := balance } ;; Enforce the condition, and fail transaction if condition doesn t meet. ( enforce ( balance amount ) Balance is not sufficient for transfer ) ;;Update the balance. ( update my-coin-table account { balance : ( - balance amount ) }))) Keep this pattern in mind and use enforce rather than if to create simpler, safer Pact code.","title":"Demonstration #1: Safe"},{"location":"intermediate/safety-with-pact/#demonstration-2-unsafe","text":"Next, I\u2019ll walk through another demonstration showing the difference between if and enforce . This is another situation where it may be tempting to use if . Though it is a similar idea, there are a few subtle differences in this demonstration that will be valuable to understand. Here is a look at the starting code. ;;TEMPTING USE of IF (type 2) ( defun credit-if :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance ;;STEP 1: Fetch all keys in my-coin-table and see if account exists. ;;STEP 2: if the row exists, check keyset and update the balance ;;STEP 3: If the keysets do match, update the balance. ;;Otherwise, print error message. ;;STEP 4: if the row does not exist, insert a row into the table. )) As you can see, you\u2019ll need to check that an account exists, update its balance if the row exists or if the keysets match, or insert a row if it does not exist. Each of these cases make it tempting to use if . For that reason, I\u2019ll walk through now coding each line using if statements. Step 1: Check that Account Exists First, fetch all keys in my-coin-table to see if the account exists. ;;STEP 1: Fetch all keys in my-coin-table and see if account exists.If true, go to step 2, or else go to step 4 ( if ( contains account ( keys my-coin-table )) Step 2: Update Balance if Row Exists Within the if statement, check the keyset and update the balance if it is found that the row exists. ;;STEP 2: if the row exists, bind variables ( with-read my-coin-table account { balance := balance , keyset := retk } Step 3: Update Balance if Keysets Match Then, if the keysets match update the balance. ;;STEP 3: If the keysets do match, update the balance. ;;Otherwise, print error message. ( if ( = retk keyset ) ( update my-coin-table account { balance : ( + amount balance )}) The keysets do not match )) Step 4: Insert Row if it Does not Exist Next, if the row does not exist, insert the balance and keyset into the account on my-coin-table. ;;STEP 4: if the row does not exist, insert a row into the table. ( insert my-coin-table account { balance : amount , keyset : keyset })) Final Unsafe Code Using If Looking back at the final code, we can see that it is working, but that it is using an unsafe if statement. This is causing logic that is more complicated than necessary and is something that would be better written using enforce . ;;TEMPTING USE of IF (type 2) ( defun credit-if :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance recording DATE and DATA ;;STEP 1: Fetch all keys in my-coin-table and see if account exists. ( if ( contains account ( keys my-coin-table )) ;;STEP 2: if the row exists, check keyset and update the balance ( with-read my-coin-table account { balance := balance , keyset := retk } ;;STEP 3: If the keysets do match, update the balance. ;;Otherwise, print error message. ( if ( = retk keyset ) ( update my-coin-table account { balance : ( + amount balance )}) The keysets do not match )) ;;STEP 4: if the row does not exist, insert a row into the table. ( insert my-coin-table account { balance : amount , keyset : keyset }))) This code can be refactored using enforce .","title":"Demonstration #2: Unsafe"},{"location":"intermediate/safety-with-pact/#demonstration-2-safe","text":"Take some time now to reconsider the code you wrote previously. Read through the new comments and decide how you may be able to approach writing this same logic with enforce rather than if. ;;refactor with with-default-read write enforce ( defun credit :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance recording DATE and DATA ;;STEP 1: Default the row to balance at 0.0 and keyset at input keyset ;;If row exists, then bind balance and keyset value from the table. ;;This allows one time key lookup - increases efficiency. ;;STEP 2: Check that the input keyset is the same as the row s keyset ;;STEP 3: Writes the row to the table. (write adds the table with the key and the row. ) As you can see, you will again need to check that an account exists, update its balance if the row exists or if the keysets match, or insert a row if it does not exist. You can do all of this using enforce as shown below. Step 1: Create Efficient One Time Key Lookup To start, you will need to reorder the code slightly. You\u2019ll start by setting the default row balance to 0.0 and a keyset at input keyset. If the row exists, then bind the balance and keyset value from the table. ;;STEP 1: Default the row to balance at 0.0 and keyset at input keyset ;;If row exists, then bind balance and keyset value from the table. ;;This allows one time key lookup - increases efficiency. ( with-default-read my-coin-table account { balance : 0.0 , keyset : keyset } { balance := balance , keyset := retg } This is more efficient than the previous code and allows for a one time key lookup. Previous Code Using If As a comparison, look back at steps 2 and 4 from the earlier code you wrote. Take some time to understand how the code above is combining each of these steps by allowing for a single lookup. \u2026 code ;;STEP 2: if the row exists, check keyset and update the balance ( with-read my-coin-table account { balance := balance , keyset := retk } \u2026 code ;;STEP 4: if the row does not exist, insert a row into the table. ( insert my-coin-table account { balance : amount , keyset : keyset \u2026 code Step 2: Check Input Key vs Row\u2019s Keyset Next, use enforce to check that the input keyset is the same as the row\u2019s keyset. If not, return that the account guards do not match. ;;STEP 2: Check that the input keyset is the same as the row s keyset ( enforce ( = retg keyset ) account guards do not match ) Step 3: Write Row to Table Finally, write the account balance and keyset to a row in the my-coin-table. ;;STEP 3: Writes the row to the table. (write adds the table with the key and the row. ( write my-coin-table account { balance : ( + balance amount ) , keyset : retg }))) Final Enforce Statement Looking back at the final version of the code, you can see that we have completed the same logic without ever using an if statement. This again allows for simpler logic and can help you write safer code. ;;refactor with with-default-read write enforce ( defun credit :string ( account :string keyset :keyset amount :decimal ) @ doc Credit AMOUNT to ACCOUNT balance recording DATE and DATA ;;STEP 1: Default the row to balance at 0.0 and keyset at input keyset ;;If row exists, then bind balance and keyset value from the table. ;;This allows one time key lookup - increases efficiency. ( with-default-read my-coin-table account { balance : 0.0 , keyset : keyset } { balance := balance , keyset := retg } ;;STEP 2: Check that the input keyset is the same as the row s keyset ( enforce ( = retg keyset ) account guards do not match ) ;;STEP 3: Writes the row to the table. (write adds the table with the key and the row. ( write my-coin-table account { balance : ( + balance amount ) , keyset : retg }))) ) Take a moment now to look back and compare both versions of this code. Ensure that you keep these patterns in mind as you write your own code.","title":"Demonstration #2: Safe"},{"location":"intermediate/safety-with-pact/#my-coinrepl","text":"In my-coin.repl file, you can check that the failing cases of debit-if and credit-if are tested with (expect \u2026 ) by checking if the output matches the expected failure message. The refactored code allows us to test with (expect-failure ...) to check if the function succeeds or not. Note For more information on running .repl files from Atom, see the tutorial Contract Interaction Run REPL file .","title":"my-coin.repl"},{"location":"intermediate/safety-with-pact/#review","text":"That wraps up this tutorial on Pact safety using control flow. Throughout this tutorial, you learned that using enforce can help make your the control flow of your Pact smart contracts even simpler and safer. You went over a few demonstrations teaching you ways to avoid using if statements in favor of enforce . This is one of a few key patterns that you can use to improve the safety of your smart contracts. Coming up, we\u2019ll go over a few more safety tips to keep in mind as you develop Pact smart contracts.","title":"Review"}]}